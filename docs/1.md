# ğŸ§© 1. Two Sum (Easy)

**[Problem Link (External)]**: [LeetCode - Two Sum](https://leetcode.com/problems/two-sum/)

## ğŸ“ Problem Statement

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

---

## ğŸ§  Approach: Hash Map (One-Pass)

The brute force approach is to use nested loops ($O(n^2)$), but we can significantly optimize this using a **Hash Map** (Python `dict`).

### 1. The Core Idea

Instead of searching the remaining part of the array for the second number, we determine the **complement** required for the current number to reach the target.

* **Current Number:** `nums[i]`
* **Required Complement:** `complement = target - nums[i]`

### 2. Implementation Steps

1.  Initialize an empty dictionary, let's call it `num_map`, where we will store: `key: number, value: its index`.
2.  Iterate through the `nums` array using a single loop.
3.  Inside the loop, for the current number `nums[i]`, calculate the `complement`.
4.  Check if this `complement` is already a **key** in the `num_map`.
    * **If YES:** We found the solution! The indices are `[num_map[complement], i]`.
    * **If NO:** We add the current number and its index to the map: `num_map[nums[i]] = i`.

### Example Walkthrough

Let's use `nums = [2, 7, 11, 15]` and `target = 9`.

| Index (i) | Current Num | Complement (9 - Current) | Is Complement in Map? | Action | `num_map` (key: num, value: index) |
| :---: | :---: | :---: | :---: | :--- | :--- |
| **0** | 2 | 7 | No | Add 2:0 to map | `{2: 0}` |
| **1** | 7 | 2 | **Yes** (Found 2 at index 0) | **RETURN [0, 1]** | `{2: 0}` |

---

## ğŸ’» Python Code Implementation

The `pymdownx.superfences` extension allows us to highlight the code nicely.

```python title="solutions/1_two_sum.py"
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        """
        Finds two numbers in the list that add up to the target.
        Uses a one-pass hash map approach for O(n) complexity.
        """
        # Dictionary to store {number: index}
        num_map = {} 
        
        for i, num in enumerate(nums):
            complement = target - num
            
            # Check if the complement needed is already in the map
            if complement in num_map:
                # Solution found! Return the stored index and the current index
                return [num_map[complement], i]
            
            # If not found, store the current number and its index for future lookups
            num_map[num] = i
            
        # Per problem constraints, a solution always exists, so this line is technically unreachable
        return []

# Example Test Case (Good practice to include locally)
if __name__ == '__main__':
    sol = Solution()
    # Test 1
    result = sol.twoSum([2, 7, 11, 15], 9)
    print(f"Test 1: [2, 7, 11, 15], Target 9 -> {result}") 
    # Test 2
    result = sol.twoSum([3, 2, 4], 6)
    print(f"Test 2: [3, 2, 4], Target 6 -> {result}")