```pyodide
{% 
    include "../python/1.py" 
    preserve-includer-indent=false 
%}
```

```python
{% 
    include "../python/1.py" 
    preserve-includer-indent=false 
%}
```


## 1. Two Sum

### Problem Statement and Core Objective

The LeetCode **Two Sum** problem, designated as problem number 1, is a foundational question in computer science that introduces key concepts in algorithm design, particularly focusing on efficient searching and data structures. The primary objective is straightforward: given an array of integers, let's call it `nums`, and a specific target integer, the task is to identify and return the indices of two distinct numbers within `nums` whose sum equals the `target`.

It is typically specified that the input array will contain exactly one valid solution pair, simplifying the process by eliminating the need to handle multiple possible answers or the non-existence of a solution. Furthermore, the constraint "you may not use the same element twice" means that even if an array contains duplicates (e.g., `[3, 3]` for a target of 6), the solution must involve two separate entries at two different indices.

### The Inefficient Brute Force Approach

The most immediate and intuitive way to solve this problem is through **Brute Force**. This method involves an exhaustive search where every possible pair of numbers in the array is examined. While conceptually simple and always correct, it is highly inefficient, serving mainly as a benchmark for comparison against optimized solutions.

To implement the Brute Force strategy, one would use two nested loops. The outer loop iterates over the array elements using an index $i$, starting from the first element. The inner loop, using an index $j$, starts from $i+1$ to ensure that the same element is never used twice and that pairs are not checked redundantly (since $(i, j)$ and $(j, i)$ are the same pair). Within the inner loop, the condition $nums[i] + nums[j] == \text{target}$ is evaluated. If the equality holds, the indices $[i, j]$ are returned immediately. Because this approach involves comparing every element with every other element, the time complexity is squared, denoted as $O(n^2)$, where $n$ is the number of elements in the array. This quadratic complexity makes the solution impractical for large input arrays.

### The Optimized One-Pass Hash Table Solution

The performance bottleneck in the Brute Force method is the repeated search for the second number. To dramatically improve efficiency, we can leverage the power of **Hash Tables** (also known as Maps or Dictionaries). A Hash Table allows for nearly instantaneous lookups—specifically, $O(1)$ time complexity on average—by mapping keys to values.

The strategy, often referred to as the **One-Pass Hash Table** method, involves iterating through the `nums` array only once. For each element $nums[i]$ encountered, the algorithm calculates the *complement* that would be required to meet the target sum: $\text{complement} = \text{target} - nums[i]$. Instead of searching the *rest* of the array for this complement, which would be $O(n)$, we check if the complement already exists as a key within our Hash Table.

### Details of the Hash Table Logic

If the calculated complement *is* found as a key in the Hash Table, it means we have previously processed the required second number, and its index is stored as the value associated with that key. The indices of the two-sum pair are then the current index $i$ and the index retrieved from the map.  This allows for an immediate return, achieving the required result with minimal effort.

Conversely, if the complement is *not* found in the Hash Table, the current number $nums[i]$ has not yet been used to form a pair. In this case, we simply add $nums[i]$ as a key to the Hash Table, with its index $i$ as the corresponding value. By adding the current number to the map, we prepare it to serve as the complement for any subsequent number that might need it. Because this entire process involves a single $O(n)$ iteration and $O(1)$ Hash Table operations (insertion and lookup), the overall time complexity is reduced to $O(n)$, making it a highly efficient solution for the Two Sum problem. The trade-off for this speed improvement is an increase in space complexity to $O(n)$ to store the Hash Table.