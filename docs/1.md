```python
{% 
    include "../python/1.py" 
    preserve-includer-indent=false 
%}
```


## ðŸ’¡ LeetCode Problem 1: Two Sum

### Problem Description

Given an array of integers, `nums`, and an integer, `target`, return the indices of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

### Example

* **Input:** `nums = [2, 7, 11, 15]`, `target = 9`
* **Output:** `[0, 1]`
* **Explanation:** Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.

---

### Approaches

There are a few ways to solve this problem, but the most efficient uses a **Hash Map** (or dictionary).

#### 1. Brute Force (Inefficient)

The simplest approach is to check every possible pair of numbers.

* Use a nested loop. The outer loop iterates from the first element up to the second-to-last element (`i`).
* The inner loop iterates from the element *after* the outer loop's current element up to the last element (`j`).
* In the inner loop, check if `nums[i] + nums[j]` equals `target`. If it does, return `[i, j]`.

| Complexity | Time | Space |
| :--- | :--- | :--- |
| **Worst-Case** | $O(n^2)$ | $O(1)$ |

#### 2. Two-Pass Hash Map

We can use a Hash Map to reduce the time complexity. A Hash Map allows us to look up an element in $O(1)$ time on average.

1.  **First Pass (Build Map):** Iterate through the `nums` array and store each element's value as the **key** and its index as the **value** in the Hash Map.
2.  **Second Pass (Find Complement):** Iterate through the `nums` array again.
    * For the current number, $n_i = nums[i]$, calculate the **complement** needed: $c = target - n_i$.
    * Check if the complement, $c$, exists as a key in the Hash Map.
    * **Crucially:** Ensure the index stored for the complement is **not** the current index $i$.
    * If the complement is found, return the current index $i$ and the index stored in the map.

| Complexity | Time | Space |
| :--- | :--- | :--- |
| **Worst-Case** | $O(n)$ | $O(n)$ |

#### 3. One-Pass Hash Map (Optimal) 

We can combine the two passes into a single pass for optimal performance.

1.  Initialize an empty Hash Map.
2.  Iterate through the `nums` array with index $i$.
3.  For the current number, $n_i = nums[i]$, calculate the **complement** needed: $c = target - n_i$.
4.  Check if the complement, $c$, already exists as a key in the Hash Map.
    * **If Found:** We have found the solution! Return the complement's index (from the map) and the current index $i$.
    * **If Not Found:** Add the current number $n_i$ and its index $i$ to the Hash Map.

This works because by the time we check for the complement $c$, any element that could be $c$ has already been processed and stored in the map, unless $n_i$ is its own complement (which is handled by the map not containing the *current* element's index).

| Complexity | Time | Space | |
| :--- | :--- | :--- | :--- |
| **Worst-Case** | $O(n)$ | $O(n)$ | |
---

### Why the One-Pass Hash Map is Optimal

The one-pass approach maintains the $O(n)$ time complexity of the Two-Pass approach but only requires a single iteration through the list, making it generally faster in practice and the preferred solution. Both approaches trade extra $O(n)$ space for a significant improvement in time complexity from $O(n^2)$ to $O(n)$.