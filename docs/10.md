## Pyodide

```pyodide
```


## Run

```pyodide
{% 
    include "../python_run/_10.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_10.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/regular-expression-matching/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _10.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Explanation

The problem asks you to implement a regular expression matching algorithm that supports two special characters: `.` (dot) and `*` (asterisk). The dot `.` matches any single character. The asterisk `*` matches zero or more occurrences of the **preceding element**. The matching must cover the **entire** input string $s$ (not partial). You are given an input string $s$ and a pattern $p$. This problem is classified as **Hard** due to the complex state management required by the `*` operator.

The two main approaches to solving this problem are **Recursion with Memoization (Top-Down Dynamic Programming)** and **Tabulation (Bottom-Up Dynamic Programming)**. The recursive approach checks if the current character in $s$ matches the current element in $p$. If the next element in $p$ is `*`, this introduces two possibilities: either the `*` matches zero occurrences of the preceding element (so we move past both the element and `*` in $p$), or it matches one or more occurrences (so we stay at the `*` and move to the next character in $s$). Memoization is crucial to avoid re-calculating the same subproblems, which would otherwise lead to exponential time complexity.

The preferred $O(m \times n)$ solution is the **Bottom-Up Dynamic Programming** approach, where $m$ is the length of $s$ and $n$ is the length of $p$. A 2D boolean array, $DP[i][j]$, is used to store whether the substring $s[0...i-1]$ matches the pattern $p[0...j-1]$. The base cases involve empty strings. The recursive relations are built upon checking the current character match and the two conditions for the `*` operator. The final answer is found at $DP[m][n]$. This approach systematically builds the solution from the smallest subproblems.

##
##