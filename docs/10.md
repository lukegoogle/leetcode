```pyodide
{% 
    include "../python/10.py" 
    preserve-includer-indent=false 
%}
```

```python
{% 
    include "../python/10.py" 
    preserve-includer-indent=false 
%}
```

## 10. Regular Expression Matching

### Problem Statement and Key Features

LeetCode problem 10, "Regular Expression Matching," requires implementing a function that determines if a given text string $s$ matches a pattern string $p$. The pattern $p$ supports two special characters: the dot (`.`) and the asterisk (`*`). The dot matches any single character, while the asterisk matches zero or more occurrences of the preceding element. The match must cover the **entire** input string $s$, not just a part of it.

This problem is highly challenging because the asterisk (`*`) introduces a complex ambiguity. The term preceding the asterisk can be matched zero times, one time, two times, or many times. For example, if the pattern is "a\*b", the "a\*" can match the empty string, "a", or "aa...", against the text "b", "ab", or "aab", respectively. This dynamic matching behavior makes a simple greedy or two-pointer approach insufficient.

### The Necessity of Dynamic Programming

Due to the overlapping subproblems and optimal substructure inherent in deciding how to match the `*` operator, this problem is classically and most effectively solved using **Dynamic Programming (DP)**. The DP approach systematically builds up the solution for larger substrings and sub-patterns based on the solutions to smaller ones, ensuring all possibilities for the `*` operator are explored.

We define a 2D DP array, $\text{dp}[i][j]$, which is a boolean value indicating whether the first $i$ characters of the text $s$ (i.e., $s[0 \dots i-1]$) match the first $j$ characters of the pattern $p$ (i.e., $p[0 \dots j-1]$). The ultimate answer to the problem will be stored in $\text{dp}[m][n]$, where $m$ is the length of $s$ and $n$ is the length of $p$.

### Base Case and Character Matching

The base case initializes the table. $\text{dp}[0][0]$ is set to `true`, as an empty text string matches an empty pattern. For subsequent rows $\text{dp}[0][j]$ where $j>0$, these can only be `true` if the pattern consists of zero or more pairs of $\langle \text{char}, * \rangle$, such as $a^*$, $a^*b^*$, or $(a.)^*$. Specifically, $\text{dp}[0][j]$ is `true` only if $p[j-1]$ is `*` and $\text{dp}[0][j-2]$ is `true`, signifying that the `*` matches zero occurrences of the preceding element $p[j-2]$.

For the general case, the transition logic depends on the character $p[j-1]$:
If $p[j-1]$ is **not** the asterisk (`*`), a match is possible only if $s[i-1]$ matches $p[j-1]$ (either they are identical characters or $p[j-1]$ is a dot `.`) and the preceding subproblem matched: $\text{dp}[i][j] = \text{dp}[i-1][j-1]$ AND $\text{match}(s[i-1], p[j-1])$.

### The Complex Asterisk Transition

The crucial complexity lies when $p[j-1]$ is the asterisk (`*`). The `*` character dictates a choice between two fundamental matching scenarios, derived from the number of times the preceding element $p[j-2]$ is matched: [Diagram showing DP transitions for Regular Expression Matching]

1.  **Zero Occurrences:** The asterisk matches zero occurrences of the preceding element $p[j-2]$. In this case, both $p[j-2]$ and $p[j-1]$ (the `*`) are effectively ignored. The match depends solely on whether $s[i]$ matches the pattern starting at $j-2$. Thus, the solution includes $\text{dp}[i][j-2]$.
2.  **One or More Occurrences:** The asterisk matches one or more occurrences of $p[j-2]$. This is only possible if the current text character $s[i-1]$ successfully matches $p[j-2]$ (or $p[j-2]$ is a dot). If they match, the problem is reduced to checking if the *rest* of the text $s[0 \dots i-2]$ matches the *current* pattern $p[0 \dots j-1]$. This allows the asterisk to continue matching the next character in $s$. Thus, the solution includes $\text{dp}[i-1][j]$ AND $\text{match}(s[i-1], p[j-2])$.

The final recurrence relation for the asterisk case is an OR condition combining these possibilities: $\text{dp}[i][j] = \text{dp}[i][j-2] \lor (\text{match}(s[i-1], p[j-2]) \land \text{dp}[i-1][j])$. By iterating through all possible $i$ and $j$ up to $m$ and $n$, this DP approach correctly explores all matching possibilities, resulting in an overall time complexity of $O(m \times n)$.