```pyodide
{% 
    include "../python/11.py" 
    preserve-includer-indent=false 
%}
```

```python
{% 
    include "../python/11.py" 
    preserve-includer-indent=false 
%}
```

## 11. Container With Most Water

### Problem Statement and Geometrical Interpretation

LeetCode problem 11, "Container With Most Water," is a geometrical optimization problem. We are given an array of $n$ non-negative integers, say $\text{heights}$, where each element $\text{heights}[i]$ represents the height of a vertical line drawn at coordinate $(i, \text{heights}[i])$. The goal is to find two of these lines that, together with the x-axis, form a container capable of holding the maximum amount of water.

The container formed by two lines at indices $L$ and $R$ (where $L < R$) has a height determined by the shorter of the two lines, $\min(\text{heights}[L], \text{heights}[R])$. The width of the container is the distance between the lines, $(R - L)$. The area, which corresponds to the amount of water the container can hold, is calculated as: $\text{Area} = \text{width} \times \text{height} = (R - L) \times \min(\text{heights}[L], \text{heights}[R])$. The challenge is to maximize this area by optimally choosing the indices $L$ and $R$.

### The Inefficient Brute Force Approach

A straightforward, yet inefficient, approach is to use **Brute Force** by checking the area generated by every possible pair of lines. This involves nested loops: the outer loop iterates with index $L$ from 0 to $n-2$, and the inner loop iterates with index $R$ from $L+1$ to $n-1$.

In each iteration, the area is calculated, and the maximum area found so far is tracked. Since every pair is examined, the Brute Force solution yields an $O(n^2)$ time complexity. While this works, it is too slow for large arrays and fails to meet the implicit requirement for an optimal solution. An $O(n)$ solution is required for efficient execution.

### The Optimized Two-Pointer Approach

The necessary optimization comes from recognizing a crucial pattern and applying the **Two-Pointer** technique. This approach starts by considering the container formed by the two lines that are farthest apartâ€”the leftmost line ($L=0$) and the rightmost line ($R=n-1$). This gives the maximum possible width.

After calculating the area for the current $(L, R)$ pair, the strategy is to determine which pointer to move inward to potentially find a larger area. Moving a pointer always results in a decrease in width, $(R - L)$. Therefore, to compensate for the reduced width, the move must aim to find a line with a *greater height*.

### The Governing Movement Logic

The critical decision lies in identifying which of the two pointers, $L$ or $R$, has a shorter line. Since the height of the current container is limited by $\min(\text{heights}[L], \text{heights}[R])$, increasing the height of the container can only be achieved by replacing the shorter of the two boundary lines with a potentially taller line. 

1.  **If $\text{heights}[L] < \text{heights}[R]$:** The current container's height is limited by $\text{heights}[L]$. Any container involving $\text{heights}[L]$ and a line to its right (say, $R' < R$) will have a width less than $(R - L)$ and a height limited by $\min(\text{heights}[L], \text{heights}[R'])$. Because $R'$ is to the left of $R$, $\text{heights}[R]$ is irrelevant. Thus, moving $R$ inward would only decrease the width, and the height would still be restricted by the relatively short $\text{heights}[L]$ or an even shorter height. Moving $L$ inward ($\text{increment } L$) is the only logical move, as it offers the possibility of finding a taller line that can increase the container's height, offsetting the loss of width.

2.  **If $\text{heights}[L] \ge \text{heights}[R]$:** The current container's height is limited by $\text{heights}[R]$. By the same logic, we must move the right pointer inward ($\text{decrement } R$) to search for a potentially taller line at the right boundary.

The loop continues until the two pointers meet ($L < R$). Since $L$ and $R$ traverse the array only once, and each iteration moves at least one pointer, the total time complexity is strictly $O(n)$, making it a highly efficient solution.