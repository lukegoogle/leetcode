## Run

```pyodide
{% 
    include "../python_run/_14.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_14.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/longest-common-prefix/"><input class="verify-button" type="button" value="Verify"/></a>


## 14. Longest Common Prefix

### Problem Statement and Core Objective

LeetCode problem 14, "Longest Common Prefix," is a fundamental string processing task. Given an array of strings, $\text{strs}$, the objective is to find the longest string that is a prefix of *all* strings within the array. If no common prefix exists among the strings (i.e., they all start with different characters), the function must return an empty string, "".

This problem highlights the need for efficient comparison across multiple string inputs. The resulting Longest Common Prefix (LCP) must adhere strictly to the definition of a prefix, meaning it must be a contiguous substring starting at the beginning of each string. For example, in the array ["flower", "flow", "flight"], the LCP is "fl".

### The Brute Force and Vertical Scanning Approaches

A brute force approach might involve checking every possible prefix of the shortest string against all other strings. This involves unnecessary repetition. A slightly more refined, but still potentially inefficient, method is **Vertical Scanning**. This method iterates through the characters of the strings from left to right, column by column.

For index $j=0, 1, 2, \dots$, we check if the character at position $j$ in the first string, $\text{strs}[0][j]$, is the same as the character at position $j$ in *all* subsequent strings, $\text{strs}[i][j]$. If we find a mismatch at any string or if we reach the end of any string, the common prefix is the substring of $\text{strs}[0]$ up to index $j-1$. While easier than Brute Force, Vertical Scanning can be slow if the array contains many long strings with a very long LCP, as it performs many redundant character comparisons. The worst-case time complexity is $O(S)$, where $S$ is the sum of the lengths of all strings, as in the scenario where all strings are identical.

### The Optimized Horizontal Scanning Technique

The most intuitive and often simplest efficient method is **Horizontal Scanning**. This approach works by incrementally refining a candidate LCP string by comparing it sequentially with every string in the input array.

We start by assuming the first string in the array, $\text{strs}[0]$, is the initial LCP candidate. We then iterate through the rest of the strings, from $\text{strs}[1]$ to $\text{strs}[n-1]$. For each string $\text{strs}[i]$, we update the LCP to be the common prefix between the *current* LCP and $\text{strs}[i]$. [Diagram illustrating Horizontal Scanning for LCP]

### Details of the LCP Refinement

The refinement step for a string $\text{strs}[i]$ and the current LCP is performed using a simple check. We ask: "Does $\text{strs}[i]$ start with the current LCP?" In many programming languages, this is done with a function like `indexOf(LCP) == 0`.

If $\text{strs}[i]$ does *not* start with the current LCP, it means the LCP is too long. We must shorten the current LCP by removing its last character ($\text{LCP} = \text{LCP}[:-1]$). We repeatedly shorten the LCP until $\text{strs}[i]$ *does* start with the truncated LCP, or until the LCP becomes empty. If the LCP becomes an empty string, we can immediately terminate the entire process and return "" because no subsequent string can possibly share a prefix with all previous strings. Once $\text{strs}[i]$'s prefix is matched, we move on to the next string in the array with the new, refined LCP. Upon completing the iteration through all strings, the final remaining LCP is the correct answer. The worst-case time complexity for Horizontal Scanning is also $O(S)$, but it often performs better in practice when the LCP is short.

### Other Advanced Approaches (Trie and Divide and Conquer)

More advanced solutions exist, such as using a **Trie (Prefix Tree)** or a **Divide and Conquer** approach.
* **Trie:** By inserting all strings into a Trie, the LCP is represented by the longest path from the root that has only one child node (since it must be common to all strings). This method is optimal in terms of comparisons but adds $O(S)$ overhead for building the Trie.
* **Divide and Conquer:** This recursive approach divides the array of strings into two halves, finds the LCP of each half, and then finds the LCP of those two results. This has the same $O(S)$ time complexity but is often less efficient due to recursion overhead compared to the simple iterative Horizontal Scanning.