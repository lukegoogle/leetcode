## Pyodide

```pyodide
```


## Run

```pyodide
{% 
    include "../python_run/_15.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_15.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/3sum/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _15.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true


## 15. 3Sum

### Problem Statement and The Uniqueness Constraint

LeetCode problem 15, "3Sum," asks us to find all unique triplets $[a, b, c]$ within a given array of $n$ integers, $nums$, such that their sum is zero: $a + b + c = 0$. This problem is an extension of the classic Two Sum problem but adds significant complexity due to the requirement of finding three numbers and, most importantly, ensuring that the resulting set of triplets contains **no duplicates**.

A brute force approach would involve three nested loops, checking every combination of three distinct indices $(i, j, k)$. This would result in an $O(n^3)$ time complexity, which is far too slow for practical purposes, necessitating a more optimized technique. The primary optimization must come from fixing one number and then efficiently searching for the remaining two, while also managing the uniqueness requirement.

### Optimal Approach: Sorting and Two Pointers

The most efficient and standard solution leverages a combination of two powerful techniques: **Sorting** and the **Two-Pointer** method.

1.  **Sorting:** First, the input array $nums$ must be sorted in $O(n \log n)$ time. Sorting is indispensable for two reasons:
    * It allows us to easily **skip duplicates** during iteration.
    * It enables the **Two-Pointer** technique to efficiently search for the remaining two numbers in $O(n)$ time.

2.  **Fixing the First Number:** After sorting, we iterate through the array with a primary pointer $i$. The value $nums[i]$ is fixed as our first number, $a$. Since we need $a + b + c = 0$, the remaining two numbers, $b$ and $c$, must satisfy $b + c = -nums[i]$. We treat $-nums[i]$ as the new "target sum" for the remaining subarray.

### The Inner Two-Pointer Search

For each fixed $a = nums[i]$, we use the two-pointer approach on the remainder of the array, starting from index $i+1$. We initialize a left pointer $L$ at $i+1$ and a right pointer $R$ at the end of the array ($n-1$). The goal is to find pairs $(nums[L], nums[R])$ that sum to the target $-nums[i]$.

The pointers $L$ and $R$ move towards each other, shrinking the search space:
1.  **Case 1: Sum is Too Small:** If $nums[L] + nums[R] < -nums[i]$, the sum needs to be larger. Since the array is sorted, we achieve a larger sum by moving $L$ one step to the right ($\text{increment } L$).
2.  **Case 2: Sum is Too Large:** If $nums[L] + nums[R] > -nums[i]$, the sum needs to be smaller. We achieve a smaller sum by moving $R$ one step to the left ($\text{decrement } R$).
3.  **Case 3: Match Found:** If $nums[L] + nums[R] = -nums[i]$, a valid triplet $[nums[i], nums[L], nums[R]]$ has been found. This triplet is added to the result list.

### Duplicate Elimination Logic

The problem requires finding *unique* triplets, which necessitates careful handling of duplicates in both the outer loop (for $a$) and the inner two-pointer movement (for $b$ and $c$).

1.  **Outer Loop Duplicates (for $a$):** We must ensure that we don't process the same value for $a$ multiple times consecutively. Before starting the inner two-pointer search, we check: if $i > 0$ and $nums[i] == nums[i-1]$, we skip the current iteration using a `continue` statement. This prevents identical triplets from being generated due to using the same value for $a$.

2.  **Inner Loop Duplicates (for $b$ and $c$):** After finding a valid triplet (Case 3), we immediately move $L$ and $R$ inward, but we must also skip duplicates that follow $L$ and precede $R$. We advance $L$ forward while $L < R$ and $nums[L] == nums[L+1]$, and we retreat $R$ backward while $L < R$ and $nums[R] == nums[R-1]$. Only after skipping all duplicates do we perform the final move: $\text{increment } L$ and $\text{decrement } R$.

By incorporating the initial $O(n \log n)$ sort with the subsequent $O(n^2)$ search (the outer loop is $O(n)$ and the inner two-pointer loop is $O(n)$), the total time complexity is dominated by the search, resulting in an optimal $O(n^2)$ time complexity for the entire solution.