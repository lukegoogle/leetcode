## Run

```pyodide
{% 
    include "../python_run/_16.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_16.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/3sum-closest/"><input class="verify-button" type="button" value="Verify"/></a>


## 16. 3Sum Closest

### Problem Statement and Target Definition

LeetCode problem 16, "3Sum Closest," is a variation of the classic 3Sum problem (LeetCode 15). Given an array of $n$ integers, $nums$, and a specific integer **target**, the objective is to find three integers in $nums$ such that their sum is the closest possible value to the target. It is generally guaranteed that there will be exactly one solution, simplifying the task of choosing between sums that are equally close.

The core challenge is not to find a sum *equal* to the target, but to **minimize the absolute difference** between the triplet sum and the target: $\min(|(\text{nums}[i] + \text{nums}[j] + \text{nums}[k]) - \text{target}|)$. Similar to the 3Sum problem, a brute force approach of checking all $O(n^3)$ combinations is prohibitively slow, demanding an optimized $O(n^2)$ solution.

### Optimal Approach: Sorting and Two Pointers

The most efficient solution strategy mirrors that of the 3Sum problem, relying on **Sorting** followed by the **Two-Pointer** technique.

1.  **Sorting:** The input array $nums$ is sorted first in $O(n \log n)$ time. Sorting is crucial because it allows us to efficiently control the magnitude of the three-number sum. By knowing the array is sorted, we can predict whether moving our pointers will increase or decrease the sum relative to the target.

2.  **Fixing the First Number:** We iterate through the array with a primary pointer $i$, fixing the first number $a = \text{nums}[i]$. The search for the remaining two numbers, $b$ and $c$, then focuses on the subarray starting from $i+1$.

### The Inner Two-Pointer Search and Tracking

For each fixed $\text{nums}[i]$, we initialize a left pointer $L$ at $i+1$ and a right pointer $R$ at the end of the array. The inner loop moves $L$ and $R$ towards each other, trying to find a sum $\text{current\_sum} = \text{nums}[i] + \text{nums}[L] + \text{nums}[R]$ that is closest to the `target`.

We maintain two variables: one to store the best sum found so far, $\text{closest\_sum}$, and one to track the minimum difference, $\text{min\_diff}$. In each iteration:

1.  **Calculate the Current Sum and Difference:** Compute $\text{current\_sum}$ and the current difference $\text{current\_diff} = \text{current\_sum} - \text{target}$.

2.  **Update the Closest Sum:** We check if the absolute value of $\text{current\_diff}$ is smaller than the absolute value of the difference associated with $\text{closest\_sum}$ found so far. If it is, $\text{closest\_sum}$ is updated to $\text{current\_sum}$.

3.  **Perfect Match Check:** If $\text{current\_sum}$ equals the $\text{target}$, we have found the exact solution, and we can immediately return $\text{target}$, as no other sum can be closer.

### Governing Movement Logic

The decision of which pointer to move ($L$ or $R$) is the key to minimizing the search space and ensuring $O(n)$ time for the inner loop. The movement is dictated by the sign of the $\text{current\_diff}$:

1.  **Sum is Too Small ($\text{current\_diff} < 0$):** If the $\text{current\_sum}$ is less than the $\text{target}$, we need a larger sum. Since the array is sorted, moving the left pointer $L$ one step to the right will incorporate a larger number $\text{nums}[L]$, thus increasing the total sum. Therefore, we increment $L$.

2.  **Sum is Too Large ($\text{current\_diff} > 0$):** If the $\text{current\_sum}$ is greater than the $\text{target}$, we need a smaller sum. Moving the right pointer $R$ one step to the left will incorporate a smaller number $\text{nums}[R]$, thus decreasing the total sum. Therefore, we decrement $R$.

This two-pointer loop continues until $L$ and $R$ cross ($L < R$). The total time complexity is $O(n \log n)$ for sorting plus $O(n^2)$ for the nested search ($O(n)$ outer loop $\times$ $O(n)$ inner loop), resulting in an optimal overall time complexity of $O(n^2)$.  Unlike the 3Sum problem, we do not need complex duplicate checking because we are looking for *a* closest sum, not a set of *unique* triplets.