## Run

```pyodide
{% 
    include "../python_run/_17.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_17.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/"><input class="verify-button" type="button" value="Verify"/></a>

## 17. Letter Combinations of a Phone Number

### Problem Statement and The Mapping

LeetCode problem 17, "Letter Combinations of a Phone Number," requires generating all possible letter combinations that a given digit string can represent, based on the standard telephone keypad mapping. The input is a string of digits, and the output is a list of all possible letter sequences. For example, if the input is "23", the digit '2' maps to "abc" and '3' maps to "def". The resulting combinations are "ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf".

The core challenge is the combinatorial nature of the problem: if the input has $N$ digits, and each digit maps to 3 or 4 letters, the total number of combinations grows exponentially. This type of problem, where we need to explore all possible paths to build a final result, is a classic application for **Depth-First Search (DFS)**, typically implemented using **Recursion** or **Backtracking**.

### The Recursive/Backtracking Approach

The optimal solution uses a recursive helper function that implements the **Backtracking** algorithm. Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time (the "backtracking" part).

For this problem, the state of the recursion is defined by two variables:
1.  **Current Combination:** The string of letters built so far.
2.  **Next Digit Index:** The index of the digit in the input string we are currently processing.

The main function initializes the mapping (e.g., '2' to "abc", '3' to "def", etc.) and starts the recursive process. 

### The Recursive/DFS Function Logic

The recursive function takes the current combination string and the index of the digit being considered.

1.  **Base Case:** If the `next digit index` is equal to the length of the input digit string, it means we have successfully built a complete combination. We add the `current combination` to the final result list and return. This is the exit condition for the recursion.

2.  **Recursive Step (The Choice):**
    * We retrieve the current digit from the input string using the `next digit index`.
    * We look up the corresponding letters for this digit from the mapping (e.g., "def" for '3').
    * We iterate through each letter in the retrieved string (e.g., 'd', 'e', 'f'). For each letter, this represents a **choice** we can make at the current step.

3.  **Exploration and Backtracking:**
    * For each chosen letter, we recursively call the function, passing the `current combination` appended with the chosen letter, and advancing the `next digit index` by one. This represents exploring a new path in the decision tree.
    * Once the recursive call returns (meaning all combinations starting with that choice have been explored), the mechanism of **Backtracking** is implicitly handled by the return from the function call. Since the combination is usually passed by value or built in a separate string builder/list that is not modified after the call, no explicit state cleanup is needed, allowing the loop to proceed to the next letter for the current digit.

### Complexity Analysis

The time complexity of this solution is directly proportional to the total number of combinations generated. If $N$ is the length of the input digits and $M$ is the maximum number of letters a digit maps to (usually 3 or 4), the complexity is $O(M^N)$. For instance, with 4 digits and 3 letters per digit, the complexity is $O(3^N)$. The space complexity is also $O(M^N)$ to store the output combinations, plus $O(N)$ for the recursion depth (call stack). This efficiency is optimal because the algorithm must, by definition, generate and store every single possible combination.