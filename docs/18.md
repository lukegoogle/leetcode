## Pyodide

```pyodide
{% 
    include "../python_run/_18.py" 
    preserve-includer-indent=false 
%}
```

## Solution

<a target="__blank" href="https://leetcode.com/problems/4sum/"><input class="verify-button" type="button" value="Verify on LeetCode"/></a>

```python
{% 
    include "../python_mod/_18.py" 
    preserve-includer-indent=false 
%}
```

## 18. 4Sum

### Problem Statement and Generalization

LeetCode problem 18, "4Sum," is the natural generalization of the 3Sum (LeetCode 15) and 2Sum problems. Given an array of $n$ integers, $nums$, and a specific integer **target**, the objective is to find all unique quadruplets $[a, b, c, d]$ within $nums$ such that their sum equals the target: $a + b + c + d = \text{target}$. The crucial constraint, identical to 3Sum, is that the resulting list must contain only **unique** quadruplets.

A naive brute force approach using four nested loops would result in an unacceptable time complexity of $O(n^4)$. To solve this problem efficiently and pass typical time limits, we must reduce the complexity to $O(n^3)$ by applying a structure similar to the 3Sum solution: fixing two numbers and then using a linear-time technique (the Two-Pointer method) to find the remaining pair.

### The Optimal Approach: Sorting and Two Nested Loops

The optimal $O(n^3)$ solution combines **Sorting** and a nested search structure.

1.  **Sorting:** First, sort the input array $nums$ in $O(n \log n)$ time. Sorting is mandatory as it enables the crucial efficiency gains: easy detection and skipping of duplicates, and the linear-time search via the two-pointer technique.

2.  **Fixing the First Two Numbers:** We use two nested loops to fix the first two numbers, $a$ and $b$.
    * The outer loop iterates with index $i$ for the first number $a = \text{nums}[i]$.
    * The inner loop iterates with index $j$ for the second number $b = \text{nums}[j]$, starting from $i+1$. [Image illustrating the 4Sum Two-Pointer structure]

3.  **Target Reduction:** With $a$ and $b$ fixed, the problem is reduced to finding two remaining numbers, $c$ and $d$, in the rest of the array such that $c + d = \text{target} - \text{nums}[i] - \text{nums}[j]$. We calculate this remaining value as $\text{new\_target} = \text{target} - \text{nums}[i] - \text{nums}[j]$.

### The Inner Two-Pointer Search

For each pair $(\text{nums}[i], \text{nums}[j])$, the remaining task is a classic **Two Sum** problem on the subarray starting from index $j+1$ up to the end of the array. We initialize a left pointer $L$ at $j+1$ and a right pointer $R$ at the end of the array.

The inner search proceeds as follows:
* Calculate the $\text{current\_sum} = \text{nums}[L] + \text{nums}[R]$.
* **If $\text{current\_sum} < \text{new\_target}$:** The sum needs to be larger. Since the array is sorted, we move $L$ one step to the right ($\text{increment } L$).
* **If $\text{current\_sum} > \text{new\_target}$:** The sum needs to be smaller. We move $R$ one step to the left ($\text{decrement } R$).
* **If $\text{current\_sum} = \text{new\_target}$:** A valid quadruplet is found. $[ \text{nums}[i], \text{nums}[j], \text{nums}[L], \text{nums}[R] ]$ is added to the result list.

### Comprehensive Duplicate Elimination

The most challenging part of 4Sum is correctly and efficiently eliminating all duplicate quadruplets. This requires checks at three distinct points in the iteration:

1.  **Skipping Duplicates for $a$ (Outer Loop):** Before the inner loop starts, if $i > 0$ and $\text{nums}[i] == \text{nums}[i-1]$, we skip the current iteration. This prevents using the same value for $a$ consecutively.

2.  **Skipping Duplicates for $b$ (Inner Loop):** Before the two-pointer search starts, if $j > i+1$ and $\text{nums}[j] == \text{nums}[j-1]$, we skip the current iteration. This prevents using the same value for $b$ consecutively with a fixed $a$.

3.  **Skipping Duplicates for $c$ and $d$ (Two-Pointer Movement):** After finding a valid quadruplet, we must advance $L$ and retreat $R$ while skipping any duplicates for the newly found $c$ and $d$:
    * Advance $L$ while $L < R$ and $\text{nums}[L] == \text{nums}[L+1]$.
    * Retreat $R$ while $L < R$ and $\text{nums}[R] == \text{nums}[R-1]$.
    * Finally, perform the actual moves: $\text{increment } L$ and $\text{decrement } R$.

By correctly implementing these three checks, the solution ensures that every returned quadruplet is unique. The overall complexity is dominated by the nested loops and the two-pointer search, resulting in the desired $O(n^3)$ time complexity.