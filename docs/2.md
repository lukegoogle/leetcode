```python
{% 
    include "../python/2.py" 
    preserve-includer-indent=false 
%}
```

## 2. Add Two Numbers

### Problem Statement and Representation

LeetCode problem 2, "Add Two Numbers," requires the simulation of adding two non-negative integers that are represented in a rather unusual format: as **linked lists**. Specifically, each digit of the number is stored in a separate node of the linked list, and the digits are stored in **reverse order**. For example, the number 342 would be represented by a linked list $2 \rightarrow 4 \rightarrow 3$. The task is to take two such linked lists, $l1$ and $l2$, add the numbers they represent, and return the sum as a new linked list in the same reverse-digit format.

The reversed storage order is a crucial design choice that greatly simplifies the addition process. It allows us to start adding from the least significant digit (the ones place, which is the head of the list) without needing to traverse the lists to find the end first, as would be necessary if the digits were stored in forward order. This structure inherently facilitates the standard, elementary-school method of addition, working from right to left.

### The Iterative Addition Process

The most efficient and common solution to this problem is an **iterative simulation** of manual column addition, which naturally involves a concept known as the *carry*. We initialize a dummy head node for the resulting sum list, which simplifies the process of appending new nodes, and we maintain a current pointer to build the list. A crucial variable, `carry`, is initialized to 0.

We traverse both input linked lists, $l1$ and $l2$, simultaneously. The iteration continues as long as there are remaining nodes in $l1$ or $l2$, or if the `carry` variable is still greater than zero. This third condition is vital, as it ensures that any final carry digit generated by the last sum is correctly included as the final node of the result list.

### Calculating the Sum and Carry

In each step of the iteration, we calculate the total sum for the current "column" of digits. This sum includes the value of the current node from $l1$ (if it exists), the value of the current node from $l2$ (if it exists), and the value of the `carry` from the previous step. If a list pointer has already reached the end, its value for that step is considered 0.

Once the total sum ($\text{sum}$) is computed, we determine the two components required for the next step: the digit for the current node and the new carry. The digit that should be placed in the new node of the result list is the $\text{sum}$ modulo 10, or $\text{digit} = \text{sum} \pmod{10}$. This calculation correctly isolates the single digit for the current place value. The new `carry` value that must be transferred to the next (more significant) place value is calculated by integer division: $\text{carry} = \text{sum} / 10$. 

### Building the Result List and Complexity

A new node containing the calculated $\text{digit}$ is created and appended to the result linked list using the current pointer. We then advance the pointers for $l1$ and $l2$ to their next respective nodes (if they exist) and move the result list's current pointer to the newly created node, preparing it for the next iteration.

This iterative process guarantees that the resulting sum list is built correctly, digit by digit, from the least significant to the most significant. The time complexity of this solution is $O(\max(m, n))$, where $m$ and $n$ are the lengths of the two input linked lists. This is an optimal linear time complexity, as we must process every node at least once. The space complexity is also $O(\max(m, n))$ because a new linked list of up to that length must be created to store the result.