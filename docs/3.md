## Pyodide

```pyodide
{% 
    include "../python_run/_3.py" 
    preserve-includer-indent=false 
%}
```

## Solution

<a target="__blank" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/"><input class="verify-button" type="button" value="Verify on LeetCode"/></a>

```python
{% 
    include "../python_mod/_3.py" 
    preserve-includer-indent=false 
%}
```

## Function Description

::: _3.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## 3. Longest Substring Without Repeating Characters

### Problem Statement and Definition

LeetCode problem 3, "Longest Substring Without Repeating Characters," is a classic string manipulation challenge. The objective is to determine the length of the longest substring within a given string $s$ that does not contain any repeating characters. A **substring** must be a contiguous sequence of characters, meaning the characters must appear consecutively in the original string. The challenge is to find the maximum possible length of such a unique sequence.

For instance, if the input string is "abcabcbb", the substrings without repeating characters are "abc", "bca", "cab", and "cbb". The longest among these is "abc", with a length of 3. If the input is "pwwkew", the longest substring is "wke" or "kew" (not "pwke" as 'w' repeats, and not "pwwkew" as 'w' repeats), which has a length of 3. The distinction between a *substring* and a *subsequence* is crucial: "pwke" is a subsequence but not a substring because the 'w's are separated in the original string by 'k' and 'e', thus violating the contiguity rule.

### The Inefficient Brute Force Approach

A naive **Brute Force** solution would be to generate every possible substring of the input string $s$ and, for each substring, check if all of its characters are unique. Generating all substrings takes $O(n^2)$ time, where $n$ is the length of $s$, as there are $\frac{n(n+1)}{2}$ total substrings. For each generated substring, checking for uniqueness typically involves using a Set data structure or comparing every character against every other character within that substring, which can take up to $O(n)$ time.

Combining these steps leads to an overall time complexity of $O(n^3)$. While this approach is correct, its cubic time complexity makes it highly impractical for strings of significant length. The need for a faster solution drives us toward a more sophisticated, linear-time algorithm.

### The Optimized Sliding Window Technique

The problem is best solved using the **Sliding Window** pattern, which optimizes the search process to achieve $O(n)$ time complexity. This technique involves maintaining a "window," which is a contiguous range of elements (a substring) in the input string. The window dynamically expands or shrinks as we iterate through the input.

In this specific application, the window is defined by two pointers, a left pointer $i$ and a right pointer $j$, representing the current substring $[i, j)$. We use a Hash Set (or a Map) to efficiently store the characters currently present within the window. The set allows us to check for the existence of a character in $O(1)$ time on average. 

### Mechanism of the Sliding Window

The process begins by expanding the window using the right pointer $j$. We examine the character $s[j]$.
1.  **Expansion:** If the character $s[j]$ is **not** currently present in our Hash Set, it means the current window $[i, j]$ is still valid (contains only unique characters). We add $s[j]$ to the set, increment the right pointer $j$, and update our record of the maximum length found so far: $\text{max\_len} = \max(\text{max\_len}, j - i)$.
2.  **Contraction (Sliding):** If the character $s[j]$ **is** already present in the Hash Set, we have found a repeating character. The window $[i, j]$ is now invalid. We must shrink the window from the left by incrementing the left pointer $i$. As we move $i$ forward, we remove the character $s[i]$ from the Hash Set. We continue this shrinking process until the repeating character is no longer inside the window, at which point the character $s[j]$ can be safely added, and the expansion resumes.

This single-pass, two-pointer approach is extremely efficient. The key insight is that both the left pointer $i$ and the right pointer $j$ traverse the string $s$ at most once. Therefore, each character is visited, added to the set, and removed from the set at most once, leading to an overall **linear time complexity of $O(n)$**. The space complexity is $O(k)$, where $k$ is the size of the character set (e.g., $k=26$ for lowercase English letters, or $k=128$ for ASCII characters), which is often considered $O(1)$ since $k$ is constant.