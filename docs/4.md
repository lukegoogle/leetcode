```pyodide
{% 
    include "../python/4.py" 
    preserve-includer-indent=false 
%}
```

## 4. Median of Two Sorted Arrays

### Problem Statement and Efficiency Constraint

LeetCode problem 4, "Median of Two Sorted Arrays," presents a significant challenge: given two already sorted arrays, $nums1$ of size $m$ and $nums2$ of size $n$, find the median of the single sorted array that would result from merging both inputs. Crucially, the problem imposes a stringent constraint on the required time complexity, demanding an $O(\log(m+n))$ solution. This logarithmic complexity immediately rules out simple merging of the arrays ($O(m+n)$) or any $O(n^2)$ approaches, strongly suggesting the use of a **Binary Search** technique.

The median is defined as the middle element of a sorted list. If the total number of elements $(m+n)$ is odd, the median is the single middle element. If the total number of elements is even, the median is the average of the two middle elements. The core difficulty lies in finding this median without explicitly merging the entire arrays.

### The Partitioning Principle

The solution hinges on the concept of **partitioning** the two arrays. The goal is to find a "cut" in $nums1$ and a corresponding "cut" in $nums2$ such that two conditions are simultaneously met:

1.  **Equal-Sized Halves:** The total number of elements in the left partitions (combined) must equal the total number of elements in the right partitions (combined). If the total length $(m+n)$ is odd, the left side can have one more element than the right. We aim for $\text{length}(\text{Left}) = \lfloor(m+n+1)/2\rfloor$.
2.  **Order Preservation:** Every element in the combined left partition must be less than or equal to every element in the combined right partition. That is, $\text{max}(\text{Left}) \le \text{min}(\text{Right})$.

### Applying Binary Search

To efficiently find these ideal cuts, we apply binary search on the smaller of the two arrays (let's assume $nums1$ is the smaller one, ensuring the search space is minimized, $O(\log(\min(m, n)))$). We search for the optimal partition index, $i$, in $nums1$.

The partition index $i$ divides $nums1$ into a left part of size $i$ and a right part of size $m-i$. The corresponding partition index $j$ in $nums2$ is automatically determined by the total required size of the left half: $j = \lfloor(m+n+1)/2\rfloor - i$.  This fixed relationship ensures the first condition (equal sizes) is always satisfied.

### Verification and Adjustment

With the cuts defined by $i$ and $j$, we identify the four key boundary elements: $\text{L1} = nums1[i-1]$, $\text{R1} = nums1[i]$, $\text{L2} = nums2[j-1]$, and $\text{R2} = nums2[j]$. (Edge cases, where $i=0, i=m, j=0,$ or $j=n$, must be handled by assigning $L$ boundary values of $-\infty$ and $R$ boundary values of $+\infty$).

The second condition, order preservation, requires that the largest element on the left side is less than or equal to the smallest element on the right side: $\max(\text{L1}, \text{L2}) \le \min(\text{R1}, \text{R2})$. This breaks down into two separate checks:
1.  $\text{L1} \le \text{R2}$
2.  $\text{L2} \le \text{R1}$

### Determining the Median

The binary search loop continues by adjusting the search range for $i$:
* If $\text{L1} > \text{R2}$ (i.e., $nums1$'s cut is too far to the right), we move the binary search right boundary for $i$ to $i-1$.
* If $\text{L2} > \text{R1}$ (i.e., $nums1$'s cut is too far to the left), we move the binary search left boundary for $i$ to $i+1$.

Once the optimal partition is found (when both $\text{L1} \le \text{R2}$ and $\text{L2} \le \text{R1}$ hold), the median can be calculated:
* **If $(m+n)$ is odd:** The median is the largest element in the left half, $\text{Median} = \max(\text{L1}, \text{L2})$.
* **If $(m+n)$ is even:** The median is the average of the largest element in the left half and the smallest element in the right half, $\text{Median} = (\max(\text{L1}, \text{L2}) + \min(\text{R1}, \text{R2})) / 2$. This logarithmic approach successfully meets the strict $O(\log(m+n))$ time complexity requirement.