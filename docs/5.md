```pyodide
{% 
    include "../python/5.py" 
    preserve-includer-indent=false 
%}
```

## 5. Longest Palindromic Substring

### Problem Statement and Core Challenge

LeetCode problem 5, "Longest Palindromic Substring," requires finding the longest contiguous substring within a given string $s$ that reads the same forwards and backwards. A string that exhibits this property is called a **palindrome**. The challenge lies in efficiently identifying this longest palindromic segment among all possible substrings.

While the problem seems simple at first glance, the potentially large number of substrings makes a naive approach computationally prohibitive. For a string of length $N$, there are $O(N^2)$ possible substrings. Checking each substring for the palindromic property takes $O(N)$ time, leading to an overall **Brute Force** complexity of $O(N^3)$. We must seek an optimized solution that can handle input constraints effectively, ideally aiming for $O(N^2)$ time or better.

### Dynamic Programming Solution (The Formal Approach)

One structured way to solve this is using **Dynamic Programming (DP)**, which offers an $O(N^2)$ time complexity. We define a 2D boolean array, $\text{dp}[i][j]$, where $\text{dp}[i][j]$ is `true` if the substring $s[i \dots j]$ is a palindrome, and `false` otherwise.

The base cases are:
1.  Single-character substrings: $\text{dp}[i][i] = \text{true}$.
2.  Two-character substrings: $\text{dp}[i][i+1] = (s[i] == s[i+1])$.

The transition relation is recursive: a substring $s[i \dots j]$ is a palindrome if and only if two conditions are met: 1. The outer characters match: $s[i] == s[j]$. 2. The inner substring $s[i+1 \dots j-1]$ is also a palindrome (i.e., $\text{dp}[i+1][j-1]$ is true). By iterating through substrings of increasing lengths, we can fill the DP table and track the longest palindrome found. [Diagram showing DP transitions for Palindromic Substring] While effective and providing $O(N^2)$ time and $O(N^2)$ space complexity, the approach below is often simpler to implement.

### The Expand Around Center Approach (The Practical $O(N^2)$ Solution)

A more practical and generally preferred $O(N^2)$ solution is the **Expand Around Center** technique. This method exploits the symmetry inherent in palindromes: every palindrome is defined by its center. The center can be a single character (for odd-length palindromes like "racecar") or the space between two identical characters (for even-length palindromes like "abba").

This approach avoids the overhead of the DP table by immediately checking for palindromes outward from every potential center. The overall algorithm iterates through every index $i$ in the string $s$, and for each $i$, it performs two independent expansion checks:

### Center-Based Expansion Details

1.  **Odd-Length Palindromes:** We treat the single character at index $i$ as the center. We initialize two pointers, $L=i$ and $R=i$. We expand outward, decrementing $L$ and incrementing $R$, as long as $L \ge 0$, $R < N$, and $s[L] == s[R]$.
2.  **Even-Length Palindromes:** We treat the space between $s[i]$ and $s[i+1]$ as the center (if $i+1$ is a valid index). We initialize $L=i$ and $R=i+1$. We expand outward similarly, decrementing $L$ and incrementing $R$, as long as the boundary and character equality conditions hold. 

In both expansion processes, we calculate the length of the current palindrome found $(R - L - 1)$ and continuously update a global record tracking the start index and length of the longest palindrome encountered so far. Since we check $2N-1$ possible centers (N single-character centers and N-1 between-character centers), and each expansion takes at most $O(N)$ time, the total time complexity remains $O(N^2)$. However, this method uses only $O(1)$ auxiliary space, making it spatially superior to the standard DP approach.