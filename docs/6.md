## Run

```pyodide
{% 
    include "../python_run/_6.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_6.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/zigzag-conversion/"><input class="verify-button" type="button" value="Verify"/></a>

## 6. Zigzag Conversion

### Problem Statement and Visualization

LeetCode problem 6, "Zigzag Conversion," requires converting a given string $s$ into a zigzag pattern across a specified number of rows, $numRows$. After the conversion process, the string is read line by line, from left to right, and the resulting concatenated string must be returned. This is essentially a pattern recognition and string reconstruction problem.

Imagine writing the string characters down a series of vertical lines, then diagonally up and to the right, forming a distinctive "Z" or "N" shape, repeated across the width of the input string. For $s=$ "PAYPALISHIRING" and $numRows=3$, the visual pattern looks like this:

"P A H N A P L S I I G Y I R"

When read row by row, the converted string is "PAHNAPLSIIGYIR". The core challenge is to derive the mathematical relationship between a character's index in the original string and its row in the final pattern, without needing to physically build a 2D matrix.

### The Pattern Cycle Length

The key to an efficient solution is recognizing and utilizing the repetitive nature of the zigzag movement. In the pattern, the characters travel down to the bottom row ($0$ to $numRows-1$) and then diagonally back up to the top row ($numRows-1$ to $1$). This movement constitutes a full cycle.

The length of one complete cycle, which represents the distance between two characters that fall on the same row in adjacent "V" shapes, can be calculated. It includes the $numRows$ characters going down and $numRows - 2$ characters going back up (since the top and bottom rows are shared between cycles). Therefore, the **cycle length** is $\text{CycleLength} = 2 \times numRows - 2$. For example, if $numRows=4$, the cycle length is $2 \times 4 - 2 = 6$. A character at index $i$ and the next character in the same row will be separated by $\text{CycleLength}$ distance, or $i + \text{CycleLength}$. 

### Direct Access and Row-by-Row Construction

The most optimal solution uses **Direct Access** combined with the calculated cycle length. Instead of simulating the movement of pointers, we iterate through the rows, from row $0$ to $numRows-1$, and directly calculate which character indices belong to that specific row. This approach ensures $O(n)$ time complexity, where $n$ is the length of the string, as each character is appended to the result exactly once.

The algorithm builds the result string row by row:

1.  **First and Last Rows (Row 0 and Row $numRows-1$):** For the top (0) and bottom ($numRows-1$) rows, characters are spaced exactly by the $\text{CycleLength}$. The indices belonging to these rows are $k \times \text{CycleLength}$, where $k$ is $0, 1, 2, \dots$. We simply start at the row index and repeatedly add the $\text{CycleLength}$ until we exceed the string bounds.

2.  **Intermediate Rows (Row $r$, where $0 < r < numRows-1$):** For any intermediate row $r$, a character appears twice within each cycle:
    * **First Occurrence (Vertical):** The character is found at the index $i_1 = k \times \text{CycleLength} + r$.
    * **Second Occurrence (Diagonal):** The character is found at a diagonal position, $i_2$. The distance between $i_1$ and $i_2$ within the cycle is the shorter distance required to complete the diagonal move, which is $\text{CycleLength} - 2r$. Thus, $i_2 = i_1 + (\text{CycleLength} - 2r)$.

We iterate through $k = 0, 1, 2, \dots$ for each row $r$, calculating both $i_1$ and $i_2$. We append the character at $i_1$ if it is within bounds. Then, we calculate $i_2$ and append its character if $i_2$ is valid (within bounds and not the same index as $i_1$, which only occurs if $2r$ is zero or equal to the cycle length, but we filter this by the intermediate row condition). This systematic, row-based traversal correctly reconstructs the final string in $O(n)$ time.