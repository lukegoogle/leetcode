## Run

```pyodide
{% 
    include "../python_run/_7.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_7.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/reverse-integer/"><input class="verify-button" type="button" value="Verify"/></a>


## 7. Reverse Integer

### Problem Statement and The Integer Limit Constraint

LeetCode problem 7, "Reverse Integer," asks us to take a given signed 32-bit integer $x$ and return its digits in reverse order. The primary complication in this problem, beyond the mechanical reversal of digits, is handling the constraints imposed by the **32-bit signed integer range**.

A signed 32-bit integer can only hold values from a minimum of $-2^{31}$ ($-2,147,483,648$) to a maximum of $2^{31}-1$ ($2,147,483,647$). If the act of reversing the digits causes the resulting number to exceed this range (either overflowing the maximum or underflowing the minimum), the function is required to return 0. This necessity of preemptive overflow checking makes the problem non-trivial, as simple data type operations might lead to undefined behavior or incorrect values in many programming environments before the check can even be performed.

### Iterative Reversal Mechanism

The digit reversal is achieved through a standard **iterative process** using arithmetic operations, avoiding string conversion for efficiency. We maintain a variable, let's call it `reversed_result`, initialized to 0. We then enter a loop that continues as long as the input $x$ is not zero.

In each iteration, we perform two steps:
1.  **Extract the Last Digit:** The last digit of $x$ is isolated using the modulo operator: $\text{digit} = x \pmod{10}$.
2.  **Update the Reversed Result:** The `reversed_result` is updated by shifting its current digits one position to the left (multiplying by 10) and then appending the new $\text{digit}$: $\text{reversed\_result} = \text{reversed\_result} \times 10 + \text{digit}$.
3.  **Truncate $x$:** The last digit is removed from $x$ using integer division: $x = x / 10$.

This process effectively peels off the digits of $x$ from right to left and reconstructs them into `reversed_result` from left to right.

### The Critical Overflow Detection Logic

The most critical part of the solution is detecting potential overflow **before** it actually occurs in the calculation $\text{reversed\_result} \times 10 + \text{digit}$. We must check the state of $\text{reversed\_result}$ before the multiplication by 10. Let $\text{INT\_MAX} = 2,147,483,647$ and $\text{INT\_MIN} = -2,147,483,648$.

We can categorize the overflow checks into three distinct scenarios for the positive case:
1.  **Guaranteed Overflow (Positive):** If $\text{reversed\_result}$ is already greater than $\text{INT\_MAX} / 10$ (which is $214,748,364$), then multiplying by 10 will definitely exceed $\text{INT\_MAX}$.
2.  **Edge Case Check (Positive):** If $\text{reversed\_result}$ is *equal* to $\text{INT\_MAX} / 10$ ($214,748,364$), the overflow depends entirely on the next digit. Since $\text{INT\_MAX} \pmod{10} = 7$, an overflow occurs if the extracted $\text{digit}$ is greater than 7.

### Handling Negative and Returning Zero

A symmetrical set of checks must be performed for the negative integer range, using $\text{INT\_MIN}$:
1.  **Guaranteed Underflow (Negative):** If $\text{reversed\_result}$ is already less than $\text{INT\_MIN} / 10$ (which is $-214,748,364$), then multiplying by 10 will definitely be less than $\text{INT\_MIN}$.
2.  **Edge Case Check (Negative):** If $\text{reversed\_result}$ is *equal* to $\text{INT\_MIN} / 10$ ($-214,748,364$), the underflow depends on the next digit. Since $\text{INT\_MIN} \pmod{10}$ is $-8$ (or $-7$ depending on language specific signed division rules, but for $-2^{31}$ it is 8), an underflow occurs if the extracted $\text{digit}$ is less than $-8$ (or greater than 8 in magnitude). The safe check is simply if $\text{reversed\_result} < \text{INT\_MIN} / 10$ or $(\text{reversed\_result} == \text{INT\_MIN} / 10 \text{ and } \text{digit} < -8)$.

If any of these overflow/underflow conditions are met during the loop, the algorithm immediately terminates and returns 0, fulfilling the problem's requirement. If the loop completes without triggering any overflow, the final $\text{reversed\_result}$ is returned. This approach maintains an $O(\log_{10}|x|)$ time complexity, which is proportional to the number of digits in $x$.