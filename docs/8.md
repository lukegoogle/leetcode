```pyodide
{% 
    include "../python/8.py" 
    preserve-includer-indent=false 
%}
```

## 8. String to Integer (atoi)

### Problem Statement and Ambiguity of Parsing

LeetCode problem 8, "String to Integer (atoi)," asks for the implementation of the $myAtoi(string s)$ function, which converts a string into a 32-bit signed integer, mirroring the behavior of the C/C++ `atoi` function. This seemingly simple task is complicated by several strict parsing rules and edge cases that must be handled sequentially and correctly. The process is not a single conversion but a series of state transitions.

The core difficulty lies in managing the strict sequence of parsing steps: first, ignoring leading whitespace; second, identifying and processing the optional sign; third, accumulating valid digits; and finally, handling potential overflow or underflow against the 32-bit integer limits. Any character encountered that does not fit the current expected state (e.g., a letter after a digit) must immediately terminate the parsing process, regardless of how many digits were successfully processed beforehand.

### Step 1: Discarding Leading Whitespace

The conversion process must begin by reading and discarding any leading whitespace characters (' ') until the first non-whitespace character is found. This stage requires a simple loop that increments an index past all spaces. If the entire string consists only of spaces, the result is 0.

Once a non-whitespace character is hit, the algorithm must transition immediately to the next stage. It is crucial to remember that whitespace is only permissible at the very start of the string. Any space encountered after the sign or after the first digit is considered an invalid character and terminates parsing.

### Step 2: Handling the Optional Sign

After skipping initial whitespace, the next character must be evaluated to determine the sign of the number. The sign is optional. If the character is a plus sign ('+'), the number is positive. If it is a minus sign ('-'), the number is negative. If the character is neither a '+' nor a '-' (and is a digit), the number is implicitly positive.

A sign multiplier variable (e.g., `sign`, initialized to 1) is set to 1 or -1 accordingly. If a sign character is found, the index is advanced to the next character. A critical rule here is that if any character other than a '+' or '-' appears immediately after the whitespace, the parsing must jump straight to Step 3 (reading digits). If two signs, or a sign followed by a non-digit, or the end of the string is encountered, the conversion stops, and 0 is returned.

### Step 3: Reading and Accumulating Digits

This is the core numerical processing stage. We iterate through the string starting from the character following the sign (or the first non-whitespace character). The loop continues only as long as the current character is a valid digit ('0' through '9').

In each iteration, the character is converted into its numerical value, $\text{digit}$. The running result, $\text{result}$, is updated by multiplying the current result by 10 and adding the new digit: $\text{result} = \text{result} \times 10 + \text{digit}$. [Diagram illustrating State Transitions for atoi] The first non-digit character encountered will immediately stop this accumulation phase.

### Step 4: Overflow and Underflow Clamping

The most challenging aspect, similar to the Reverse Integer problem, is the requirement to prevent and handle numerical overflow or underflow. The result must fit within the 32-bit signed integer range, which is $\text{INT\_MIN} = -2^{31}$ and $\text{INT\_MAX} = 2^{31}-1$.

The **overflow check** must be performed *inside* the digit accumulation loop, *before* the multiplication and addition, to ensure that the intermediate calculation does not exceed the limits. If the current positive $\text{result}$ is already greater than $\text{INT\_MAX} / 10$, or if it is equal to $\text{INT\_MAX} / 10$ and the new $\text{digit}$ is greater than 7, then the final result would overflow. Symmetrical checks apply to the negative result against $\text{INT\_MIN}$. If an overflow or underflow condition is met at any point, the algorithm must immediately stop and clamp the final value to $\text{INT\_MAX}$ or $\text{INT\_MIN}$ before returning. This careful sequence of state-dependent parsing and boundary checks ensures compliance with all $myAtoi$ rules.