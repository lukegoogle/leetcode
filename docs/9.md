## Pyodide

```pyodide
{% 
    include "../python_run/_9.py" 
    preserve-includer-indent=false 
%}
```

## Solution

<a target="__blank" href="https://leetcode.com/problems/palindrome-number/"><input class="verify-button" type="button" value="Verify on LeetCode"/></a>

```python
{% 
    include "../python_mod/_9.py" 
    preserve-includer-indent=false 
%}
```
## 9. Palindrome Number

### Problem Statement and Constraints

LeetCode problem 9, "Palindrome Number," asks for a determination of whether a given integer $x$ is a palindrome. An integer is defined as a palindrome if it reads the same forwards and backwards. For instance, 121 is a palindrome, but 123 is not. The primary constraint on the solution is the requirement to solve the problem **without converting the integer to a string**. This mandates an approach using only mathematical operations, such as modulo and division.

Initial checks reveal immediate non-palindromes: all negative numbers are non-palindromes because the minus sign only appears at the beginning (e.g., $-121$ reads $121-$ backward). Additionally, any positive number that ends in 0 (other than 0 itself, which is a palindrome) cannot be a palindrome, as the leading digit of the reversed number would be 0, which is invalid for an integer representation (e.g., $120$ reverses to $021$). If $x$ is negative or ends in 0 (and is not 0), we can immediately return `false`.

### The Brute Force Reversal Pitfall

A straightforward approach would be to fully reverse the entire integer $x$ and then compare the reversed value with the original $x$. While this method works for most integers, it suffers from the same vulnerability as the "Reverse Integer" problem (LeetCode 7): **integer overflow**. If the original number $x$ is large, reversing it could cause the resulting number to exceed the maximum value allowed by the integer data type ($\text{INT\_MAX}$).

Since the problem requires a robust solution, we must devise a method that avoids the potential for overflow entirely. Reversing the number and then performing the comparison, while simple to code, is mathematically risky without dedicated overflow handling, which complicates the logic unnecessarily when a safer method exists.

### The Optimized Half-Reversal Approach

The most elegant and efficient solution involves reversing only the **second half** of the number. If a number is a palindrome, its second half, when reversed, must be identical to its first half. This technique avoids the risk of overflow because we are only building a reversed number that is at most half the length of the original.

We use a loop to iteratively build a `reversed_half` variable. The loop continues as long as the original number $x$ is greater than `reversed_half`. In each iteration:
1.  We extract the last digit of $x$ using $\text{digit} = x \pmod{10}$.
2.  We append this digit to `reversed_half`: $\text{reversed\_half} = \text{reversed\_half} \times 10 + \text{digit}$.
3.  We remove the last digit from $x$: $x = x / 10$.

This process effectively transfers the digits from the tail of $x$ to the head of `reversed\_half` until $x$ is no longer greater than `reversed\_half`, signifying that we have processed at least half the digits.

### Final Comparison and Edge Case Handling

When the loop terminates, we compare the remaining portion of $x$ with the constructed `reversed_half`. Two distinct scenarios are possible, depending on the length of the original number:

1.  **Even Number of Digits:** If the original number had an even number of digits (e.g., 1221), the loop stops when $x$ and `reversed_half` have the same value (i.e., $x = 12$ and $\text{reversed\_half} = 12$). The palindrome check is simply $x == \text{reversed\_half}$.
2.  **Odd Number of Digits:** If the original number had an odd number of digits (e.g., 121), the loop stops when the middle digit has been transferred to $\text{reversed\_half}$ (i.e., $x = 1$ and $\text{reversed\_half} = 12$). The middle digit of an odd-length palindrome is irrelevant to the comparison. To align the values, we remove the middle digit from `reversed_half` via integer division: $\text{reversed\_half} / 10$. The palindrome check is $x == \text{reversed\_half} / 10$.

By combining these two checks with a logical OR operation, we can cover all valid cases: $x == \text{reversed\_half}$ OR $x == \text{reversed\_half} / 10$. This half-reversal strategy ensures an optimal $O(\log_{10} x)$ time complexity, which is proportional to the number of digits, and maintains $O(1)$ space complexity without risking integer overflow.