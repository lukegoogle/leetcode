## Pyodide

```pyodide height="10"
# Type here


```
## Run

```pyodide
{% 
    include "../python_run/_12.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_12.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/integer-to-roman/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _12.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## 12. Integer to Roman

### Problem Statement and Roman Numeral System Basics

LeetCode problem 12, "Integer to Roman," requires converting a given integer into its Roman numeral representation. The input is guaranteed to be within the standard range of Roman numeral representation, specifically from 1 to 3999 (inclusive). This constraint ensures that we do not need to deal with very large numbers requiring bars over the letters or other advanced Roman numeral notation.

The Roman numeral system is based on seven symbols, each representing a specific value: $I=1, V=5, X=10, L=50, C=100, D=500, M=1000$. The system uses additive notation (e.g., $VI = 5+1 = 6$) but also incorporates a crucial **subtractive notation** rule for four and nine units of magnitude. These subtractive pairs are: $IV=4, IX=9$ (for tens), $XL=40, XC=90$ (for hundreds), and $CD=400, CM=900$ (for thousands). The solution must adhere to the standard convention of always choosing the largest possible symbol or subtractive combination at each place value.

### The Greedy Approach with Ordered Mappings

Since the Roman numeral system has fixed values and the largest symbol is always preferred, this problem is perfectly suited for a **Greedy Algorithm**. A greedy approach makes the locally optimal choice at each step, and because the Roman numeral system is well-behaved in this range (e.g., you would never use two 'V's instead of one 'X'), this local optimum leads directly to the global optimum.

The implementation involves defining two synchronized arrays (or a map of pairs) that store the values and their corresponding Roman symbols, **ordered from largest value to smallest**. This ordering is crucial because it includes the subtractive pairs ($900, 400, 90, 40, 9, 4$) which must be checked before their simpler, larger components ($1000, 500, 100, 50, 10, 5$). [Table showing Roman Numeral Mappings]

### Iteration and Conversion Logic

We iterate through the ordered list of value-symbol pairs. For each pair $(\text{value}, \text{symbol})$, we check if the remaining input number, $num$, is greater than or equal to $\text{value}$.

If $num \ge \text{value}$, it means the current symbol or combination is the largest possible representation that can be used at this stage. We apply the greedy choice: we append the $\text{symbol}$ to our result string and simultaneously subtract the $\text{value}$ from $num$. We repeat this process with the same pair until $num$ drops below $\text{value}$. This ensures that repeated symbols are correctly handled (e.g., $3000$ requires three 'M's).

### Example of Greedy Selection

Consider converting the number 1994. The algorithm proceeds as follows:
1.  Check 1000 ($M$): $1994 \ge 1000$. Result becomes "M", $num$ becomes 994.
2.  Check 900 ($CM$): $994 \ge 900$. Result becomes "MCM", $num$ becomes 94.
3.  Check 500 ($D$): $94 < 500$. Skip.
4.  ...
5.  Check 90 ($XC$): $94 \ge 90$. Result becomes "MCMXC", $num$ becomes 4.
6.  Check 50 ($L$): $4 < 50$. Skip.
7.  Check 4 ($IV$): $4 \ge 4$. Result becomes "MCMXCIV", $num$ becomes 0.

The process stops when $num$ reaches 0. Because the number of symbols in the mapping is a small constant (13 pairs), the number of iterations required is very small and does not depend on the magnitude of the input integer $num$ but rather on the number of fixed place values. Therefore, the time complexity is effectively **$O(1)$** (constant time) due to the fixed constraint of the input range (1 to 3999).