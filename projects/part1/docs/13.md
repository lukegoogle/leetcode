## Pyodide

```pyodide height="10"
# Type here


```
## Run

```pyodide
{% 
    include "../python_run/_13.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_13.py" 
    preserve-includer-indent=false 
%}
```
<a target="__blank" href="https://leetcode.com/problems/roman-to-integer/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _13.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true


## 13. Roman to Integer

### Problem Statement and The Subtraction Rule Challenge

LeetCode problem 13, "Roman to Integer," involves converting a given Roman numeral string, $s$, into its corresponding integer value. The input is guaranteed to be a valid Roman numeral within the standard range of 1 to 3999. Unlike converting from an integer to a Roman numeral (which relies on a greedy build-up), converting *to* an integer requires a careful sequential interpretation of the Roman characters.

The main complexity arises from the **subtractive notation**. Normally, symbols are additive (e.g., $VI = 5 + 1 = 6$). However, a smaller value symbol placed *before* a larger value symbol indicates subtraction (e.g., $IV = 5 - 1 = 4$, $CM = 1000 - 100 = 900$). The algorithm must correctly identify these subtractive pairs and adjust the running total accordingly, which cannot be done by simply summing the values of the individual characters from left to right.

### Mapping and Initialization

The solution begins by establishing a map or dictionary to store the integer value for each of the seven Roman symbols ($I, V, X, L, C, D, M$). [Table showing Roman Numeral Mappings] The conversion process must then handle the string $s$ by processing it sequentially. A variable, often called `total` or `result`, is initialized to 0 to accumulate the final integer value.

The most robust approach involves iterating through the Roman numeral string from **left to right**, comparing the value of the current symbol with the value of the next symbol. This lookahead comparison is the key mechanism for identifying the subtractive rule.

### The Lookahead Comparison Logic

We iterate through the string using an index $i$ from the beginning up to the second-to-last character. In each step, we retrieve the value of the current symbol, $\text{current\_val} = \text{map}[s[i]]$, and the value of the next symbol, $\text{next\_val} = \text{map}[s[i+1]]$.

1.  **Subtractive Case:** If $\text{current\_val} < \text{next\_val}$ (e.g., $I$ followed by $V$ in $IV$), this signals a subtractive pair. The correct way to handle this is to subtract the current value from the running `total`. This is because the $\text{current\_val}$ is not being added normally but is being used to subtract from the subsequent, larger value.
2.  **Additive Case:** If $\text{current\_val} \ge \text{next\_val}$ (e.g., $V$ followed by $I$ in $VI$, or two identical symbols like $X$ followed by $X$), the current value is purely additive. We add $\text{current\_val}$ to the running `total`.

### Finalizing the Conversion

After the loop completes, the last character of the Roman numeral string (at index $n-1$) will not have been processed, as the loop only goes up to $n-2$ to allow for the $i+1$ lookahead. The last symbol can never be part of a subtractive pair (as there is no symbol following it), so its value is always additive.

Therefore, the final step is to retrieve the value of the last character, $\text{map}[s[n-1]]$, and add it to the accumulated `total`. This approach correctly handles all symbols and the subtractive rule, resulting in the correct integer. Since the algorithm requires only a single pass through the string, the time complexity is linear, $O(n)$, where $n$ is the length of the Roman numeral string. Given the input constraint of 1 to 3999, $n$ is at most 15, so the time complexity is very fast in practice.