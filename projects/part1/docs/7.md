## Pyodide

```pyodide height="10"
# Type here


```
## Run

```pyodide
{% 
    include "../python_run/_7.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_7.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/reverse-integer/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _7.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Explanation

Given a signed 32-bit integer, $x$, the task is to return its digits reversed. For example, if $x = 123$, the output should be $321$. If $x = -123$, the output should be $-321$. The number's sign must be preserved in the reversed result. The input integer $x$ is within the range $[-(2^{31}), 2^{31} - 1]$, which defines the limits of a standard 32-bit signed integer.

The primary difficulty in this problem is handling **integer overflow**. The reversed integer might exceed the maximum value of a 32-bit signed integer ($2^{31} - 1$) or fall below its minimum value ($-(2^{31})$), even if the original number $x$ was within range. For example, reversing $1,534,236,469$ results in $9,646,324,351$, which is larger than $2,147,483,647$. Therefore, before appending the next digit, a check must be performed to ensure the current reversed number, multiplied by 10 and added to the new digit, does not cause an overflow.

The most robust approach involves iteratively extracting the last digit of $x$ using the modulo operator ($x \pmod{10}$) and building the reversed number. In each iteration, we check for potential overflow *before* the multiplication step. Specifically, if `reversed > INT_MAX / 10` (or `reversed < INT_MIN / 10`), we know the next multiplication will definitely overflow. If it's on the edge (e.g., `reversed == INT_MAX / 10`), we then check the last digit itself to see if it causes the final overflow. If an overflow is detected at any point, the function must immediately return $0$.

##
##