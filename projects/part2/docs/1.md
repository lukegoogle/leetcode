<!-- Leetcode 1 python. Then remove comments in the code you output. -->

<!-- Make docstring in 1 paragraph explanation before argument descriptions Google style for leetcode 1. -->

<!-- Give .md snippet -->
<!-- Give me plain text descripton in .md I can copy of leetcode 1 in 3 paragraphs -->

## Pyodide

```pyodide height="10"
# Type here


```

## Run

```pyodide
{% 
    include "../python_run/_1.py" 
    preserve-includer-indent=false 
%}
```

## Solution

```python
{% 
    include "../python_mod/_1.py" 
    preserve-includer-indent=false 
%}
```

<a target="__blank" href="https://leetcode.com/problems/two-sum/"><input class="verify-button" type="button" value="Verify"/></a>

## Function Description

::: _1.Solution
    handler: python
    options:
        # Display the docstring for the Solution class itself
        #show_root_heading: true
        # Display all public members (like the twoSum method)
        members: true

## Explanation

The "Two Sum" problem is universally recognized as the introductory problem in algorithmic interviews and a foundational concept for understanding time complexity trade-offs. The requirement is straightforward: given an array of integers, `nums`, and a specific target integer, identify and return the indices of the two numbers within the array that sum up exactly to the target. The problem is generally constrained by the guarantee that exactly one valid solution exists, and the same element cannot be used twice.

A simple, though professionally unacceptable, solution involves a **brute-force approach** using nested loops. The outer loop iterates over each element $nums[i]$, and the inner loop checks every subsequent element $nums[j]$ to see if $nums[i] + nums[j]$ equals the target. While correct, this method results in a quadratic time complexity of $O(n^2)$. This inefficiency means the execution time increases dramatically as the input array size grows, failing to meet the performance standards required in production systems.

The definitive, industry-standard solution achieves linear time complexity, $O(n)$, by utilizing a **hash map** (or dictionary). This method performs a single pass through the array. For each number $nums[i]$, the algorithm calculates the *complement* needed to reach the target ($complement = target - nums[i]$). Before inserting the current element into the hash map, the algorithm checks if the required $complement$ already exists as a key in the map.  If the complement is found, the current index $i$ and the index stored in the map (which belongs to the complement) are returned. If not found, the number $nums[i]$ and its index $i$ are added to the map. This leverages the $O(1)$ average-time complexity of hash map lookups to ensure maximum efficiency.

##
##