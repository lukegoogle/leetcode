## ðŸ”— LeetCode Problem 2: Add Two Numbers - A Deep Dive into Linked Lists

LeetCode Problem 2, "Add Two Numbers," is another foundational problem, but it shifts focus from arrays and hash maps to a different critical data structure: the **singly linked list**. This problem is classified as a "Medium" difficulty level and requires the candidate to understand linked list manipulation, carry-over arithmetic, and pointer management.

---

### The Problem Statement and Data Structure

The problem asks you to add two non-negative integers that are represented by **singly linked lists**. Crucially, the digits are stored in **reverse order**, and each node in the list contains only a single digit. For example, the number $342$ would be represented by the linked list $2 \rightarrow 4 \rightarrow 3$. The task is to add these two numbers and return the sum as a new linked list, also with the digits in reverse order. The input lists are guaranteed to be non-empty and do not contain any leading zeros, except for the number $0$ itself.

---

### Core Concept: Simulating Manual Addition

The beauty of the problem lies in the reverse-order storage, which perfectly mimics how humans perform addition on paper: starting from the least significant digit (the units place) and moving left, carrying over any excess to the next column. Since the head of the linked list represents the units digit, we can simply iterate through both lists simultaneously from their heads, adding corresponding digits and managing the "carry." 

The process involves iterating through both lists, $l_1$ and $l_2$, from their head nodes. At each step, we sum the current digits from $l_1$ and $l_2$ (if they exist) and the existing `carry` value from the previous step.

---

### The Iterative Algorithm and Carry Management

We initialize a `carry` variable to $0$ and create a **dummy head node** for the result list. This dummy node simplifies the code by providing a fixed starting point for the new list, allowing us to always append to the `next` of the current node without special handling for the very first node. We also maintain a `current` pointer to keep track of the last node in the new result list.

Inside a `while` loop, the iteration continues as long as **at least one** of the lists has remaining nodes **OR** the `carry` is still $1$. This condition is vital because we must account for a final carry-over, such as when adding $5$ and $5$, resulting in $0$ and a final carry of $1$.

---

### Step-by-Step Calculation within the Loop

1.  **Calculate the Sum:** Determine the value of the current nodes. If $l_1$ is not null, its value is added; otherwise, $0$ is added. The same logic applies to $l_2$. The `carry` from the previous step is also added to this sum. $sum = (l_1.\text{val} \text{ or } 0) + (l_2.\text{val} \text{ or } 0) + carry$.
2.  **Update the Carry:** The new `carry` is the tens digit of the sum, which is $carry = \lfloor sum / 10 \rfloor$ (integer division).
3.  **Calculate the Digit:** The digit for the new node is the units digit of the sum, which is $digit = sum \pmod{10}$.
4.  **Create New Node:** A new node with this $digit$ is created and appended to the result list: $current.\text{next} = new\_node(digit)$.
5.  **Advance Pointers:** The `current` pointer is moved to this newly created node: $current = current.\text{next}$. The pointers $l_1$ and $l_2$ are advanced to their respective next nodes (if they exist).

---

### Handling Unequal Lengths and the Final Carry

The algorithm gracefully handles lists of unequal lengths because of the use of the "if not null, use value, else use $0$" logic in the calculation. When one list runs out of nodes, its contribution to the sum for the remaining iterations effectively becomes $0$, and the remaining digits of the longer list are added along with the carry.

The loop terminates when both $l_1$ and $l_2$ become null, *and* the `carry` becomes $0$. If after the loop, the `carry` is still $1$ (meaning the sum resulted in an extra most significant digit), the initial loop condition *would* have handled this, creating the final node. The final result is the `next` node of the initial dummy head, effectively skipping the dummy node itself.

---

### Conclusion and Complexity Analysis

The solution is highly efficient. Since we iterate through both lists only once, and each step involves only $O(1)$ operations (addition, modulo, division, node creation), the time complexity is $O(\max(m, n))$, where $m$ and $n$ are the lengths of the two input linked lists. The space complexity is also $O(\max(m, n))$ because we create a new linked list to store the sum, which will have a maximum length of $\max(m, n) + 1$. This problem is an excellent test of a developer's ability to manage pointers and handle iterative arithmetic logic in a non-array data structure.

***

Would you like a side-by-side comparison of the steps for adding two specific linked lists, like $99$ ($9 \rightarrow 9$) and $1$ ($1 \rightarrow$ null)?