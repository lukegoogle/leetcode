{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python LeetCode","text":"<p>Here you will find my Python solutions for LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment. LeetCode includes Data Structures and Algorithms to practice.</p> <p>Browse source code here (sidebar to the left) or visit GitHub. Run your code with Pyodide.</p> <p>Verify problems directly on LeetCode.</p> <p>Static site generation is done with Python Make Docs. </p>"},{"location":"#_1","title":"About","text":"<p>Luke Clark</p> <p>Send me an email at lukeclarksf@gmail.com. See my Resume.</p>"},{"location":"#learn-data-structures-and-algorithms","title":"Learn Data Structures and Algorithms","text":""},{"location":"#submit-on-leetcode","title":"Submit on LeetCode","text":""},{"location":"1/","title":"1. Two Sum (Easy)","text":""},{"location":"1/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n\n#if __name__ == \"__main__\":\nprint(Solution().twoSum([0,1,2,3,4,5],2))</pre> Output Clear <pre></pre> </p>"},{"location":"1/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#function-description","title":"Function Description","text":"<p>Solution class for LeetCode problem 1: Two Sum.</p> <p>The problem asks to find two indices of the numbers in a list that add up to a specific target. The provided solution implements an efficient O(n) approach using a hash map (dictionary) for quick lookups.</p> Source code in <code>python/_1.py</code> <pre><code>class Solution:\n    \"\"\"\n    Solution class for LeetCode problem 1: Two Sum.\n\n    The problem asks to find two indices of the numbers in a list that add up\n    to a specific target. The provided solution implements an efficient\n    O(n) approach using a hash map (dictionary) for quick lookups.\n    \"\"\"\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        \"\"\"\n        Finds two numbers in the input list that add up to a specific target.\n\n        This method uses a hash map (dictionary in Python) to store the numbers\n        encountered so far and their indices. For each number, it calculates the\n        'complement' (the number needed to reach the target) and checks if this\n        complement is already in the hash map. If it is, the indices of the\n        complement and the current number are returned. Otherwise, the current\n        number and its index are added to the hash map.\n\n        The time complexity is O(n) because the list is traversed only once,\n        and hash map lookups are O(1) on average.\n\n        Args:\n            nums (list[int]): The list of integers to search within.\n            target (int): The target sum.\n\n        Returns:\n            list[int]: A list containing the indices of the two numbers that\n                       add up to the target. Returns an empty list if no such\n                       pair is found.\n\n        Examples:\n            &gt;&gt;&gt; solution = Solution()\n            &gt;&gt;&gt; solution.twoSum([2, 7, 11, 15], 9)\n            [0, 1]\n            &gt;&gt;&gt; solution.twoSum([3, 2, 4], 6)\n            [1, 2]\n            &gt;&gt;&gt; solution.twoSum([3, 3], 6)\n            [0, 1]\n            &gt;&gt;&gt; solution.twoSum([1, 2, 3, 4], 10)\n            []\n        \"\"\"\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#_1.Solution.twoSum","title":"<code>twoSum(nums, target)</code>","text":"<p>Finds two numbers in the input list that add up to a specific target.</p> <p>This method uses a hash map (dictionary in Python) to store the numbers encountered so far and their indices. For each number, it calculates the 'complement' (the number needed to reach the target) and checks if this complement is already in the hash map. If it is, the indices of the complement and the current number are returned. Otherwise, the current number and its index are added to the hash map.</p> <p>The time complexity is O(n) because the list is traversed only once, and hash map lookups are O(1) on average.</p> <p>Parameters:</p> Name Type Description Default <code>nums</code> <code>list[int]</code> <p>The list of integers to search within.</p> required <code>target</code> <code>int</code> <p>The target sum.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list containing the indices of the two numbers that        add up to the target. Returns an empty list if no such        pair is found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; solution = Solution()\n&gt;&gt;&gt; solution.twoSum([2, 7, 11, 15], 9)\n[0, 1]\n&gt;&gt;&gt; solution.twoSum([3, 2, 4], 6)\n[1, 2]\n&gt;&gt;&gt; solution.twoSum([3, 3], 6)\n[0, 1]\n&gt;&gt;&gt; solution.twoSum([1, 2, 3, 4], 10)\n[]\n</code></pre> Source code in <code>python/_1.py</code> <pre><code>def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"\n    Finds two numbers in the input list that add up to a specific target.\n\n    This method uses a hash map (dictionary in Python) to store the numbers\n    encountered so far and their indices. For each number, it calculates the\n    'complement' (the number needed to reach the target) and checks if this\n    complement is already in the hash map. If it is, the indices of the\n    complement and the current number are returned. Otherwise, the current\n    number and its index are added to the hash map.\n\n    The time complexity is O(n) because the list is traversed only once,\n    and hash map lookups are O(1) on average.\n\n    Args:\n        nums (list[int]): The list of integers to search within.\n        target (int): The target sum.\n\n    Returns:\n        list[int]: A list containing the indices of the two numbers that\n                   add up to the target. Returns an empty list if no such\n                   pair is found.\n\n    Examples:\n        &gt;&gt;&gt; solution = Solution()\n        &gt;&gt;&gt; solution.twoSum([2, 7, 11, 15], 9)\n        [0, 1]\n        &gt;&gt;&gt; solution.twoSum([3, 2, 4], 6)\n        [1, 2]\n        &gt;&gt;&gt; solution.twoSum([3, 3], 6)\n        [0, 1]\n        &gt;&gt;&gt; solution.twoSum([1, 2, 3, 4], 10)\n        []\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n</code></pre>"},{"location":"1/#1-two-sum","title":"1. Two Sum","text":""},{"location":"1/#problem-statement-and-core-objective","title":"Problem Statement and Core Objective","text":"<p>The LeetCode Two Sum problem, designated as problem number 1, is a foundational question in computer science that introduces key concepts in algorithm design, particularly focusing on efficient searching and data structures. The primary objective is straightforward: given an array of integers, let's call it <code>nums</code>, and a specific target integer, the task is to identify and return the indices of two distinct numbers within <code>nums</code> whose sum equals the <code>target</code>.</p> <p>It is typically specified that the input array will contain exactly one valid solution pair, simplifying the process by eliminating the need to handle multiple possible answers or the non-existence of a solution. Furthermore, the constraint \"you may not use the same element twice\" means that even if an array contains duplicates (e.g., <code>[3, 3]</code> for a target of 6), the solution must involve two separate entries at two different indices.</p>"},{"location":"1/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>The most immediate and intuitive way to solve this problem is through Brute Force. This method involves an exhaustive search where every possible pair of numbers in the array is examined. While conceptually simple and always correct, it is highly inefficient, serving mainly as a benchmark for comparison against optimized solutions.</p> <p>To implement the Brute Force strategy, one would use two nested loops. The outer loop iterates over the array elements using an index \\(i\\), starting from the first element. The inner loop, using an index \\(j\\), starts from \\(i+1\\) to ensure that the same element is never used twice and that pairs are not checked redundantly (since \\((i, j)\\) and \\((j, i)\\) are the same pair). Within the inner loop, the condition \\(nums[i] + nums[j] == \\text{target}\\) is evaluated. If the equality holds, the indices \\([i, j]\\) are returned immediately. Because this approach involves comparing every element with every other element, the time complexity is squared, denoted as \\(O(n^2)\\), where \\(n\\) is the number of elements in the array. This quadratic complexity makes the solution impractical for large input arrays.</p>"},{"location":"1/#the-optimized-one-pass-hash-table-solution","title":"The Optimized One-Pass Hash Table Solution","text":"<p>The performance bottleneck in the Brute Force method is the repeated search for the second number. To dramatically improve efficiency, we can leverage the power of Hash Tables (also known as Maps or Dictionaries). A Hash Table allows for nearly instantaneous lookups\u2014specifically, \\(O(1)\\) time complexity on average\u2014by mapping keys to values.</p> <p>The strategy, often referred to as the One-Pass Hash Table method, involves iterating through the <code>nums</code> array only once. For each element \\(nums[i]\\) encountered, the algorithm calculates the complement that would be required to meet the target sum: \\(\\text{complement} = \\text{target} - nums[i]\\). Instead of searching the rest of the array for this complement, which would be \\(O(n)\\), we check if the complement already exists as a key within our Hash Table.</p>"},{"location":"1/#details-of-the-hash-table-logic","title":"Details of the Hash Table Logic","text":"<p>If the calculated complement is found as a key in the Hash Table, it means we have previously processed the required second number, and its index is stored as the value associated with that key. The indices of the two-sum pair are then the current index \\(i\\) and the index retrieved from the map.  This allows for an immediate return, achieving the required result with minimal effort.</p> <p>Conversely, if the complement is not found in the Hash Table, the current number \\(nums[i]\\) has not yet been used to form a pair. In this case, we simply add \\(nums[i]\\) as a key to the Hash Table, with its index \\(i\\) as the corresponding value. By adding the current number to the map, we prepare it to serve as the complement for any subsequent number that might need it. Because this entire process involves a single \\(O(n)\\) iteration and \\(O(1)\\) Hash Table operations (insertion and lookup), the overall time complexity is reduced to \\(O(n)\\), making it a highly efficient solution for the Two Sum problem. The trade-off for this speed improvement is an increase in space complexity to \\(O(n)\\) to store the Hash Table.</p>"},{"location":"10/","title":"10. Regular Expression Matching (Hard)","text":""},{"location":"10/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Regular Expression Matching Examples ---\")\n# \n\n# Test Case 1: Simple mismatch\ns1 = \"aa\"\np1 = \"a\"\nresult1 = sol.isMatch(s1, p1)\nprint(f\"Input: s='{s1}', p='{p1}'\")\nprint(f\"Output: {result1} (Expected: False)\")\n\n# Test Case 2: Simple * match (one or more 'a')\ns2 = \"aa\"\np2 = \"a*\"\nresult2 = sol.isMatch(s2, p2)\nprint(f\"Input: s='{s2}', p='{p2}'\")\nprint(f\"Output: {result2} (Expected: True)\")\n\n# Test Case 3: Zero * match (zero 'a')\ns3 = \"ab\"\np3 = \".*\"\nresult3 = sol.isMatch(s3, p3)\nprint(f\"Input: s='{s3}', p='{p3}'\")\nprint(f\"Output: {result3} (Expected: True)\")\n\n# Test Case 4: Multiple characters and *\ns4 = \"aab\"\np4 = \"c*a*b\"\nresult4 = sol.isMatch(s4, p4)\nprint(f\"Input: s='{s4}', p='{p4}'\")\nprint(f\"Output: {result4} (Expected: True) (c* matches zero c's, a* matches two a's)\")\n\n# Test Case 5: Complex match with '.' and '*'\ns5 = \"mississippi\"\np5 = \"mis*is*p*.\"\nresult5 = sol.isMatch(s5, p5)\nprint(f\"Input: s='{s5}', p='{p5}'\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Edge Case (Pattern starts with '.*')\ns6 = \"abcd\"\np6 = \".*d\"\nresult6 = sol.isMatch(s6, p6)\nprint(f\"Input: s='{s6}', p='{p6}'\")\nprint(f\"Output: {result6} (Expected: True)\")</pre> Output Clear <pre></pre> </p>"},{"location":"10/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"10/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":""},{"location":"10/#problem-statement-and-key-features","title":"Problem Statement and Key Features","text":"<p>LeetCode problem 10, \"Regular Expression Matching,\" requires implementing a function that determines if a given text string \\(s\\) matches a pattern string \\(p\\). The pattern \\(p\\) supports two special characters: the dot (<code>.</code>) and the asterisk (<code>*</code>). The dot matches any single character, while the asterisk matches zero or more occurrences of the preceding element. The match must cover the entire input string \\(s\\), not just a part of it.</p> <p>This problem is highly challenging because the asterisk (<code>*</code>) introduces a complex ambiguity. The term preceding the asterisk can be matched zero times, one time, two times, or many times. For example, if the pattern is \"a*b\", the \"a*\" can match the empty string, \"a\", or \"aa...\", against the text \"b\", \"ab\", or \"aab\", respectively. This dynamic matching behavior makes a simple greedy or two-pointer approach insufficient.</p>"},{"location":"10/#the-necessity-of-dynamic-programming","title":"The Necessity of Dynamic Programming","text":"<p>Due to the overlapping subproblems and optimal substructure inherent in deciding how to match the <code>*</code> operator, this problem is classically and most effectively solved using Dynamic Programming (DP). The DP approach systematically builds up the solution for larger substrings and sub-patterns based on the solutions to smaller ones, ensuring all possibilities for the <code>*</code> operator are explored.</p> <p>We define a 2D DP array, \\(\\text{dp}[i][j]\\), which is a boolean value indicating whether the first \\(i\\) characters of the text \\(s\\) (i.e., \\(s[0 \\dots i-1]\\)) match the first \\(j\\) characters of the pattern \\(p\\) (i.e., \\(p[0 \\dots j-1]\\)). The ultimate answer to the problem will be stored in \\(\\text{dp}[m][n]\\), where \\(m\\) is the length of \\(s\\) and \\(n\\) is the length of \\(p\\).</p>"},{"location":"10/#base-case-and-character-matching","title":"Base Case and Character Matching","text":"<p>The base case initializes the table. \\(\\text{dp}[0][0]\\) is set to <code>true</code>, as an empty text string matches an empty pattern. For subsequent rows \\(\\text{dp}[0][j]\\) where \\(j&gt;0\\), these can only be <code>true</code> if the pattern consists of zero or more pairs of \\(\\langle \\text{char}, * \\rangle\\), such as \\(a^*\\), \\(a^*b^*\\), or \\((a.)^*\\). Specifically, \\(\\text{dp}[0][j]\\) is <code>true</code> only if \\(p[j-1]\\) is <code>*</code> and \\(\\text{dp}[0][j-2]\\) is <code>true</code>, signifying that the <code>*</code> matches zero occurrences of the preceding element \\(p[j-2]\\).</p> <p>For the general case, the transition logic depends on the character \\(p[j-1]\\): If \\(p[j-1]\\) is not the asterisk (<code>*</code>), a match is possible only if \\(s[i-1]\\) matches \\(p[j-1]\\) (either they are identical characters or \\(p[j-1]\\) is a dot <code>.</code>) and the preceding subproblem matched: \\(\\text{dp}[i][j] = \\text{dp}[i-1][j-1]\\) AND \\(\\text{match}(s[i-1], p[j-1])\\).</p>"},{"location":"10/#the-complex-asterisk-transition","title":"The Complex Asterisk Transition","text":"<p>The crucial complexity lies when \\(p[j-1]\\) is the asterisk (<code>*</code>). The <code>*</code> character dictates a choice between two fundamental matching scenarios, derived from the number of times the preceding element \\(p[j-2]\\) is matched: [Diagram showing DP transitions for Regular Expression Matching]</p> <ol> <li>Zero Occurrences: The asterisk matches zero occurrences of the preceding element \\(p[j-2]\\). In this case, both \\(p[j-2]\\) and \\(p[j-1]\\) (the <code>*</code>) are effectively ignored. The match depends solely on whether \\(s[i]\\) matches the pattern starting at \\(j-2\\). Thus, the solution includes \\(\\text{dp}[i][j-2]\\).</li> <li>One or More Occurrences: The asterisk matches one or more occurrences of \\(p[j-2]\\). This is only possible if the current text character \\(s[i-1]\\) successfully matches \\(p[j-2]\\) (or \\(p[j-2]\\) is a dot). If they match, the problem is reduced to checking if the rest of the text \\(s[0 \\dots i-2]\\) matches the current pattern \\(p[0 \\dots j-1]\\). This allows the asterisk to continue matching the next character in \\(s\\). Thus, the solution includes \\(\\text{dp}[i-1][j]\\) AND \\(\\text{match}(s[i-1], p[j-2])\\).</li> </ol> <p>The final recurrence relation for the asterisk case is an OR condition combining these possibilities: \\(\\text{dp}[i][j] = \\text{dp}[i][j-2] \\lor (\\text{match}(s[i-1], p[j-2]) \\land \\text{dp}[i-1][j])\\). By iterating through all possible \\(i\\) and \\(j\\) up to \\(m\\) and \\(n\\), this DP approach correctly explores all matching possibilities, resulting in an overall time complexity of \\(O(m \\times n)\\).</p>"},{"location":"11/","title":"11. Container With Most Water (Medium)","text":""},{"location":"11/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Container With Most Water Examples ---\")\n\n# Test Case 1: Standard Example\n# The maximum area is 49, formed by the lines of height 8 and 7, which are 7 units apart.\nh1 = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nresult1 = sol.maxArea(h1)\nprint(f\"Input: {h1}\")\nprint(f\"Output: {result1} (Expected: 49)\")\n\n# Test Case 2: Simple Example\nh2 = [1, 1]\nresult2 = sol.maxArea(h2)\nprint(f\"Input: {h2}\")\nprint(f\"Output: {result2} (Expected: 1)\")\n\n# Test Case 3: Decreasing heights\n# Max area is formed by the first and last line: min(5, 1) * 4 = 4\nh3 = [5, 4, 3, 2, 1]\nresult3 = sol.maxArea(h3)\nprint(f\"Input: {h3}\")\nprint(f\"Output: {result3} (Expected: 4)\")\n\n# Test Case 4: Increasing heights\n# Max area is formed by the first and last line: min(1, 5) * 4 = 4\nh4 = [1, 2, 3, 4, 5]\nresult4 = sol.maxArea(h4)\nprint(f\"Input: {h4}\")\nprint(f\"Output: {result4} (Expected: 4)\")\n\n# Test Case 5: Large example with max area far from edges\nh5 = [2, 3, 4, 5, 18, 17, 6]\n# Max area is min(18, 17) * 1 = 17 OR min(5, 6) * 3 = 15. The true max is likely from 18 and 17.\nresult5 = sol.maxArea(h5)\nprint(f\"Input: {h5}\")\nprint(f\"Output: {result5} (Expected: 17)\")</pre> Output Clear <pre></pre> </p>"},{"location":"11/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n</code></pre>"},{"location":"11/#11-container-with-most-water","title":"11. Container With Most Water","text":""},{"location":"11/#problem-statement-and-geometrical-interpretation","title":"Problem Statement and Geometrical Interpretation","text":"<p>LeetCode problem 11, \"Container With Most Water,\" is a geometrical optimization problem. We are given an array of \\(n\\) non-negative integers, say \\(\\text{heights}\\), where each element \\(\\text{heights}[i]\\) represents the height of a vertical line drawn at coordinate \\((i, \\text{heights}[i])\\). The goal is to find two of these lines that, together with the x-axis, form a container capable of holding the maximum amount of water.</p> <p>The container formed by two lines at indices \\(L\\) and \\(R\\) (where \\(L &lt; R\\)) has a height determined by the shorter of the two lines, \\(\\min(\\text{heights}[L], \\text{heights}[R])\\). The width of the container is the distance between the lines, \\((R - L)\\). The area, which corresponds to the amount of water the container can hold, is calculated as: \\(\\text{Area} = \\text{width} \\times \\text{height} = (R - L) \\times \\min(\\text{heights}[L], \\text{heights}[R])\\). The challenge is to maximize this area by optimally choosing the indices \\(L\\) and \\(R\\).</p>"},{"location":"11/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>A straightforward, yet inefficient, approach is to use Brute Force by checking the area generated by every possible pair of lines. This involves nested loops: the outer loop iterates with index \\(L\\) from 0 to \\(n-2\\), and the inner loop iterates with index \\(R\\) from \\(L+1\\) to \\(n-1\\).</p> <p>In each iteration, the area is calculated, and the maximum area found so far is tracked. Since every pair is examined, the Brute Force solution yields an \\(O(n^2)\\) time complexity. While this works, it is too slow for large arrays and fails to meet the implicit requirement for an optimal solution. An \\(O(n)\\) solution is required for efficient execution.</p>"},{"location":"11/#the-optimized-two-pointer-approach","title":"The Optimized Two-Pointer Approach","text":"<p>The necessary optimization comes from recognizing a crucial pattern and applying the Two-Pointer technique. This approach starts by considering the container formed by the two lines that are farthest apart\u2014the leftmost line (\\(L=0\\)) and the rightmost line (\\(R=n-1\\)). This gives the maximum possible width.</p> <p>After calculating the area for the current \\((L, R)\\) pair, the strategy is to determine which pointer to move inward to potentially find a larger area. Moving a pointer always results in a decrease in width, \\((R - L)\\). Therefore, to compensate for the reduced width, the move must aim to find a line with a greater height.</p>"},{"location":"11/#the-governing-movement-logic","title":"The Governing Movement Logic","text":"<p>The critical decision lies in identifying which of the two pointers, \\(L\\) or \\(R\\), has a shorter line. Since the height of the current container is limited by \\(\\min(\\text{heights}[L], \\text{heights}[R])\\), increasing the height of the container can only be achieved by replacing the shorter of the two boundary lines with a potentially taller line. </p> <ol> <li> <p>If \\(\\text{heights}[L] &lt; \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[L]\\). Any container involving \\(\\text{heights}[L]\\) and a line to its right (say, \\(R' &lt; R\\)) will have a width less than \\((R - L)\\) and a height limited by \\(\\min(\\text{heights}[L], \\text{heights}[R'])\\). Because \\(R'\\) is to the left of \\(R\\), \\(\\text{heights}[R]\\) is irrelevant. Thus, moving \\(R\\) inward would only decrease the width, and the height would still be restricted by the relatively short \\(\\text{heights}[L]\\) or an even shorter height. Moving \\(L\\) inward (\\(\\text{increment } L\\)) is the only logical move, as it offers the possibility of finding a taller line that can increase the container's height, offsetting the loss of width.</p> </li> <li> <p>If \\(\\text{heights}[L] \\ge \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[R]\\). By the same logic, we must move the right pointer inward (\\(\\text{decrement } R\\)) to search for a potentially taller line at the right boundary.</p> </li> </ol> <p>The loop continues until the two pointers meet (\\(L &lt; R\\)). Since \\(L\\) and \\(R\\) traverse the array only once, and each iteration moves at least one pointer, the total time complexity is strictly \\(O(n)\\), making it a highly efficient solution.</p>"},{"location":"12/","title":"12. Integer to Roman (Medium)","text":""},{"location":"12/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Integer to Roman Examples ---\")\n\n# Test Case 1: Simple addition\nnum1 = 3\nresult1 = sol.intToRoman(num1)\nprint(f\"Input: {num1}\")\nprint(f\"Output: '{result1}' (Expected: 'III')\")\n\n# Test Case 2: Subtractive notation (IV)\nnum2 = 4\nresult2 = sol.intToRoman(num2)\nprint(f\"Input: {num2}\")\nprint(f\"Output: '{result2}' (Expected: 'IV')\")\n\n# Test Case 3: Mixed addition and subtraction\nnum3 = 58\n# 50 (L) + 5 (V) + 3 (III)\nresult3 = sol.intToRoman(num3)\nprint(f\"Input: {num3}\")\nprint(f\"Output: '{result3}' (Expected: 'LVIII')\")\n\n# Test Case 4: Complex number using multiple subtractive rules\nnum4 = 1994\n# 1000 (M) + 900 (CM) + 90 (XC) + 4 (IV)\nresult4 = sol.intToRoman(num4)\nprint(f\"Input: {num4}\")\nprint(f\"Output: '{result4}' (Expected: 'MCMXCIV')\")\n\n# Test Case 5: Maximum allowed input (3999)\nnum5 = 3999\n# 3000 (MMM) + 900 (CM) + 90 (XC) + 9 (IX)\nresult5 = sol.intToRoman(num5)\nprint(f\"Input: {num5}\")\nprint(f\"Output: '{result5}' (Expected: 'MMMCMXCIX')\")</pre> Output Clear <pre></pre> </p>"},{"location":"12/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n</code></pre>"},{"location":"12/#12-integer-to-roman","title":"12. Integer to Roman","text":""},{"location":"12/#problem-statement-and-roman-numeral-system-basics","title":"Problem Statement and Roman Numeral System Basics","text":"<p>LeetCode problem 12, \"Integer to Roman,\" requires converting a given integer into its Roman numeral representation. The input is guaranteed to be within the standard range of Roman numeral representation, specifically from 1 to 3999 (inclusive). This constraint ensures that we do not need to deal with very large numbers requiring bars over the letters or other advanced Roman numeral notation.</p> <p>The Roman numeral system is based on seven symbols, each representing a specific value: \\(I=1, V=5, X=10, L=50, C=100, D=500, M=1000\\). The system uses additive notation (e.g., \\(VI = 5+1 = 6\\)) but also incorporates a crucial subtractive notation rule for four and nine units of magnitude. These subtractive pairs are: \\(IV=4, IX=9\\) (for tens), \\(XL=40, XC=90\\) (for hundreds), and \\(CD=400, CM=900\\) (for thousands). The solution must adhere to the standard convention of always choosing the largest possible symbol or subtractive combination at each place value.</p>"},{"location":"12/#the-greedy-approach-with-ordered-mappings","title":"The Greedy Approach with Ordered Mappings","text":"<p>Since the Roman numeral system has fixed values and the largest symbol is always preferred, this problem is perfectly suited for a Greedy Algorithm. A greedy approach makes the locally optimal choice at each step, and because the Roman numeral system is well-behaved in this range (e.g., you would never use two 'V's instead of one 'X'), this local optimum leads directly to the global optimum.</p> <p>The implementation involves defining two synchronized arrays (or a map of pairs) that store the values and their corresponding Roman symbols, ordered from largest value to smallest. This ordering is crucial because it includes the subtractive pairs (\\(900, 400, 90, 40, 9, 4\\)) which must be checked before their simpler, larger components (\\(1000, 500, 100, 50, 10, 5\\)). [Table showing Roman Numeral Mappings]</p>"},{"location":"12/#iteration-and-conversion-logic","title":"Iteration and Conversion Logic","text":"<p>We iterate through the ordered list of value-symbol pairs. For each pair \\((\\text{value}, \\text{symbol})\\), we check if the remaining input number, \\(num\\), is greater than or equal to \\(\\text{value}\\).</p> <p>If \\(num \\ge \\text{value}\\), it means the current symbol or combination is the largest possible representation that can be used at this stage. We apply the greedy choice: we append the \\(\\text{symbol}\\) to our result string and simultaneously subtract the \\(\\text{value}\\) from \\(num\\). We repeat this process with the same pair until \\(num\\) drops below \\(\\text{value}\\). This ensures that repeated symbols are correctly handled (e.g., \\(3000\\) requires three 'M's).</p>"},{"location":"12/#example-of-greedy-selection","title":"Example of Greedy Selection","text":"<p>Consider converting the number 1994. The algorithm proceeds as follows: 1.  Check 1000 (\\(M\\)): \\(1994 \\ge 1000\\). Result becomes \"M\", \\(num\\) becomes 994. 2.  Check 900 (\\(CM\\)): \\(994 \\ge 900\\). Result becomes \"MCM\", \\(num\\) becomes 94. 3.  Check 500 (\\(D\\)): \\(94 &lt; 500\\). Skip. 4.  ... 5.  Check 90 (\\(XC\\)): \\(94 \\ge 90\\). Result becomes \"MCMXC\", \\(num\\) becomes 4. 6.  Check 50 (\\(L\\)): \\(4 &lt; 50\\). Skip. 7.  Check 4 (\\(IV\\)): \\(4 \\ge 4\\). Result becomes \"MCMXCIV\", \\(num\\) becomes 0.</p> <p>The process stops when \\(num\\) reaches 0. Because the number of symbols in the mapping is a small constant (13 pairs), the number of iterations required is very small and does not depend on the magnitude of the input integer \\(num\\) but rather on the number of fixed place values. Therefore, the time complexity is effectively \\(O(1)\\) (constant time) due to the fixed constraint of the input range (1 to 3999).</p>"},{"location":"13/","title":"13. Roman to Integer (Easy)","text":""},{"location":"13/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Roman to Integer Examples ---\")\n\n# Test Case 1: Simple addition\ns1 = \"III\"\nresult1 = sol.romanToInt(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 3)\")\n\n# Test Case 2: Subtractive notation (IV = 5 - 1 = 4)\ns2 = \"IV\"\nresult2 = sol.romanToInt(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: 4)\")\n\n# Test Case 3: Subtractive notation (IX = 10 - 1 = 9)\ns3 = \"IX\"\nresult3 = sol.romanToInt(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 9)\")\n\n# Test Case 4: Mixed addition and subtraction\ns4 = \"LVIII\"\n# L (50) + V (5) + I (1) + I (1) + I (1) = 58\nresult4 = sol.romanToInt(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 58)\")\n\n# Test Case 5: Complex number using multiple subtractive rules\ns5 = \"MCMXCIV\"\n# M (1000) + CM (900) + XC (90) + IV (4) = 1994\nresult5 = sol.romanToInt(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 1994)\")\n\n# Test Case 6: Maximum number\ns6 = \"MMMCMXCIX\"\n# 3999\nresult6 = sol.romanToInt(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: 3999)\")</pre> Output Clear <pre></pre> </p>"},{"location":"13/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n</code></pre>"},{"location":"13/#13-roman-to-integer","title":"13. Roman to Integer","text":""},{"location":"13/#problem-statement-and-the-subtraction-rule-challenge","title":"Problem Statement and The Subtraction Rule Challenge","text":"<p>LeetCode problem 13, \"Roman to Integer,\" involves converting a given Roman numeral string, \\(s\\), into its corresponding integer value. The input is guaranteed to be a valid Roman numeral within the standard range of 1 to 3999. Unlike converting from an integer to a Roman numeral (which relies on a greedy build-up), converting to an integer requires a careful sequential interpretation of the Roman characters.</p> <p>The main complexity arises from the subtractive notation. Normally, symbols are additive (e.g., \\(VI = 5 + 1 = 6\\)). However, a smaller value symbol placed before a larger value symbol indicates subtraction (e.g., \\(IV = 5 - 1 = 4\\), \\(CM = 1000 - 100 = 900\\)). The algorithm must correctly identify these subtractive pairs and adjust the running total accordingly, which cannot be done by simply summing the values of the individual characters from left to right.</p>"},{"location":"13/#mapping-and-initialization","title":"Mapping and Initialization","text":"<p>The solution begins by establishing a map or dictionary to store the integer value for each of the seven Roman symbols (\\(I, V, X, L, C, D, M\\)). [Table showing Roman Numeral Mappings] The conversion process must then handle the string \\(s\\) by processing it sequentially. A variable, often called <code>total</code> or <code>result</code>, is initialized to 0 to accumulate the final integer value.</p> <p>The most robust approach involves iterating through the Roman numeral string from left to right, comparing the value of the current symbol with the value of the next symbol. This lookahead comparison is the key mechanism for identifying the subtractive rule.</p>"},{"location":"13/#the-lookahead-comparison-logic","title":"The Lookahead Comparison Logic","text":"<p>We iterate through the string using an index \\(i\\) from the beginning up to the second-to-last character. In each step, we retrieve the value of the current symbol, \\(\\text{current\\_val} = \\text{map}[s[i]]\\), and the value of the next symbol, \\(\\text{next\\_val} = \\text{map}[s[i+1]]\\).</p> <ol> <li>Subtractive Case: If \\(\\text{current\\_val} &lt; \\text{next\\_val}\\) (e.g., \\(I\\) followed by \\(V\\) in \\(IV\\)), this signals a subtractive pair. The correct way to handle this is to subtract the current value from the running <code>total</code>. This is because the \\(\\text{current\\_val}\\) is not being added normally but is being used to subtract from the subsequent, larger value.</li> <li>Additive Case: If \\(\\text{current\\_val} \\ge \\text{next\\_val}\\) (e.g., \\(V\\) followed by \\(I\\) in \\(VI\\), or two identical symbols like \\(X\\) followed by \\(X\\)), the current value is purely additive. We add \\(\\text{current\\_val}\\) to the running <code>total</code>.</li> </ol>"},{"location":"13/#finalizing-the-conversion","title":"Finalizing the Conversion","text":"<p>After the loop completes, the last character of the Roman numeral string (at index \\(n-1\\)) will not have been processed, as the loop only goes up to \\(n-2\\) to allow for the \\(i+1\\) lookahead. The last symbol can never be part of a subtractive pair (as there is no symbol following it), so its value is always additive.</p> <p>Therefore, the final step is to retrieve the value of the last character, \\(\\text{map}[s[n-1]]\\), and add it to the accumulated <code>total</code>. This approach correctly handles all symbols and the subtractive rule, resulting in the correct integer. Since the algorithm requires only a single pass through the string, the time complexity is linear, \\(O(n)\\), where \\(n\\) is the length of the Roman numeral string. Given the input constraint of 1 to 3999, \\(n\\) is at most 15, so the time complexity is very fast in practice.</p>"},{"location":"14/","title":"14. Longest Common Prefix (Easy)","text":""},{"location":"14/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Longest Common Prefix Examples ---\")\n\n# Test Case 1: Standard common prefix\nstrs1 = [\"flower\", \"flow\", \"flight\"]\nresult1 = sol.longestCommonPrefix(strs1)\nprint(f\"Input: {strs1}\")\nprint(f\"Output: '{result1}' (Expected: 'fl')\")\n\n# Test Case 2: No common prefix\nstrs2 = [\"dog\", \"racecar\", \"car\"]\nresult2 = sol.longestCommonPrefix(strs2)\nprint(f\"Input: {strs2}\")\nprint(f\"Output: '{result2}' (Expected: '')\")\n\n# Test Case 3: Common prefix is the full word\nstrs3 = [\"apple\", \"app\", \"apricot\"]\nresult3 = sol.longestCommonPrefix(strs3)\nprint(f\"Input: {strs3}\")\nprint(f\"Output: '{result3}' (Expected: 'ap')\")\n\n# Test Case 4: Empty input list\nstrs4 = []\nresult4 = sol.longestCommonPrefix(strs4)\nprint(f\"Input: {strs4}\")\nprint(f\"Output: '{result4}' (Expected: '')\")\n\n# Test Case 5: List with one string\nstrs5 = [\"solo\"]\nresult5 = sol.longestCommonPrefix(strs5)\nprint(f\"Input: {strs5}\")\nprint(f\"Output: '{result5}' (Expected: 'solo')\")\n\n# Test Case 6: Vertically aligned mismatch\nstrs6 = [\"ab\", \"a\"]\nresult6 = sol.longestCommonPrefix(strs6)\nprint(f\"Input: {strs6}\")\nprint(f\"Output: '{result6}' (Expected: 'a')\")</pre> Output Clear <pre></pre> </p>"},{"location":"14/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n</code></pre>"},{"location":"14/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":""},{"location":"14/#problem-statement-and-core-objective","title":"Problem Statement and Core Objective","text":"<p>LeetCode problem 14, \"Longest Common Prefix,\" is a fundamental string processing task. Given an array of strings, \\(\\text{strs}\\), the objective is to find the longest string that is a prefix of all strings within the array. If no common prefix exists among the strings (i.e., they all start with different characters), the function must return an empty string, \"\".</p> <p>This problem highlights the need for efficient comparison across multiple string inputs. The resulting Longest Common Prefix (LCP) must adhere strictly to the definition of a prefix, meaning it must be a contiguous substring starting at the beginning of each string. For example, in the array [\"flower\", \"flow\", \"flight\"], the LCP is \"fl\".</p>"},{"location":"14/#the-brute-force-and-vertical-scanning-approaches","title":"The Brute Force and Vertical Scanning Approaches","text":"<p>A brute force approach might involve checking every possible prefix of the shortest string against all other strings. This involves unnecessary repetition. A slightly more refined, but still potentially inefficient, method is Vertical Scanning. This method iterates through the characters of the strings from left to right, column by column.</p> <p>For index \\(j=0, 1, 2, \\dots\\), we check if the character at position \\(j\\) in the first string, \\(\\text{strs}[0][j]\\), is the same as the character at position \\(j\\) in all subsequent strings, \\(\\text{strs}[i][j]\\). If we find a mismatch at any string or if we reach the end of any string, the common prefix is the substring of \\(\\text{strs}[0]\\) up to index \\(j-1\\). While easier than Brute Force, Vertical Scanning can be slow if the array contains many long strings with a very long LCP, as it performs many redundant character comparisons. The worst-case time complexity is \\(O(S)\\), where \\(S\\) is the sum of the lengths of all strings, as in the scenario where all strings are identical.</p>"},{"location":"14/#the-optimized-horizontal-scanning-technique","title":"The Optimized Horizontal Scanning Technique","text":"<p>The most intuitive and often simplest efficient method is Horizontal Scanning. This approach works by incrementally refining a candidate LCP string by comparing it sequentially with every string in the input array.</p> <p>We start by assuming the first string in the array, \\(\\text{strs}[0]\\), is the initial LCP candidate. We then iterate through the rest of the strings, from \\(\\text{strs}[1]\\) to \\(\\text{strs}[n-1]\\). For each string \\(\\text{strs}[i]\\), we update the LCP to be the common prefix between the current LCP and \\(\\text{strs}[i]\\). [Diagram illustrating Horizontal Scanning for LCP]</p>"},{"location":"14/#details-of-the-lcp-refinement","title":"Details of the LCP Refinement","text":"<p>The refinement step for a string \\(\\text{strs}[i]\\) and the current LCP is performed using a simple check. We ask: \"Does \\(\\text{strs}[i]\\) start with the current LCP?\" In many programming languages, this is done with a function like <code>indexOf(LCP) == 0</code>.</p> <p>If \\(\\text{strs}[i]\\) does not start with the current LCP, it means the LCP is too long. We must shorten the current LCP by removing its last character (\\(\\text{LCP} = \\text{LCP}[:-1]\\)). We repeatedly shorten the LCP until \\(\\text{strs}[i]\\) does start with the truncated LCP, or until the LCP becomes empty. If the LCP becomes an empty string, we can immediately terminate the entire process and return \"\" because no subsequent string can possibly share a prefix with all previous strings. Once \\(\\text{strs}[i]\\)'s prefix is matched, we move on to the next string in the array with the new, refined LCP. Upon completing the iteration through all strings, the final remaining LCP is the correct answer. The worst-case time complexity for Horizontal Scanning is also \\(O(S)\\), but it often performs better in practice when the LCP is short.</p>"},{"location":"14/#other-advanced-approaches-trie-and-divide-and-conquer","title":"Other Advanced Approaches (Trie and Divide and Conquer)","text":"<p>More advanced solutions exist, such as using a Trie (Prefix Tree) or a Divide and Conquer approach. * Trie: By inserting all strings into a Trie, the LCP is represented by the longest path from the root that has only one child node (since it must be common to all strings). This method is optimal in terms of comparisons but adds \\(O(S)\\) overhead for building the Trie. * Divide and Conquer: This recursive approach divides the array of strings into two halves, finds the LCP of each half, and then finds the LCP of those two results. This has the same \\(O(S)\\) time complexity but is often less efficient due to recursion overhead compared to the simple iterative Horizontal Scanning.</p>"},{"location":"15/","title":"15. 3Sum (Medium)","text":""},{"location":"15/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 3Sum Examples ---\")\n\n# Test Case 1: Standard example with duplicates\nnums1 = [-1, 0, 1, 2, -1, 4]\nresult1 = sol.threeSum(nums1)\n# Expected output (after sorting): [[-1, -1, 2], [-1, 0, 1]]\nprint(f\"Input: {nums1}\")\nprint(f\"Output: {result1} (Expected: [[-1, -1, 2], [-1, 0, 1]])\")\n\n# Test Case 2: No solution\nnums2 = [0, 1, 1]\nresult2 = sol.threeSum(nums2)\nprint(f\"Input: {nums2}\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Only zeros\nnums3 = [0, 0, 0]\nresult3 = sol.threeSum(nums3)\nprint(f\"Input: {nums3}\")\nprint(f\"Output: {result3} (Expected: [[0, 0, 0]])\")\n\n# Test Case 4: Longer array with various numbers and duplicates\nnums4 = [-2, 0, 1, 1, 2]\nresult4 = sol.threeSum(nums4)\n# Expected output: [[-2, 0, 2], [-2, 1, 1]]\nprint(f\"Input: {nums4}\")\nprint(f\"Output: {result4} (Expected: [[-2, 0, 2], [-2, 1, 1]])\")\n\n# Test Case 5: Array that breaks early (Optimization 1)\nnums5 = [1, 2, 3]\nresult5 = sol.threeSum(nums5)\nprint(f\"Input: {nums5}\")\nprint(f\"Output: {result5} (Expected: [])\")</pre> Output Clear <pre></pre> </p>"},{"location":"15/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n</code></pre>"},{"location":"15/#15-3sum","title":"15. 3Sum","text":""},{"location":"15/#problem-statement-and-the-uniqueness-constraint","title":"Problem Statement and The Uniqueness Constraint","text":"<p>LeetCode problem 15, \"3Sum,\" asks us to find all unique triplets \\([a, b, c]\\) within a given array of \\(n\\) integers, \\(nums\\), such that their sum is zero: \\(a + b + c = 0\\). This problem is an extension of the classic Two Sum problem but adds significant complexity due to the requirement of finding three numbers and, most importantly, ensuring that the resulting set of triplets contains no duplicates.</p> <p>A brute force approach would involve three nested loops, checking every combination of three distinct indices \\((i, j, k)\\). This would result in an \\(O(n^3)\\) time complexity, which is far too slow for practical purposes, necessitating a more optimized technique. The primary optimization must come from fixing one number and then efficiently searching for the remaining two, while also managing the uniqueness requirement.</p>"},{"location":"15/#optimal-approach-sorting-and-two-pointers","title":"Optimal Approach: Sorting and Two Pointers","text":"<p>The most efficient and standard solution leverages a combination of two powerful techniques: Sorting and the Two-Pointer method.</p> <ol> <li> <p>Sorting: First, the input array \\(nums\\) must be sorted in \\(O(n \\log n)\\) time. Sorting is indispensable for two reasons:</p> <ul> <li>It allows us to easily skip duplicates during iteration.</li> <li>It enables the Two-Pointer technique to efficiently search for the remaining two numbers in \\(O(n)\\) time.</li> </ul> </li> <li> <p>Fixing the First Number: After sorting, we iterate through the array with a primary pointer \\(i\\). The value \\(nums[i]\\) is fixed as our first number, \\(a\\). Since we need \\(a + b + c = 0\\), the remaining two numbers, \\(b\\) and \\(c\\), must satisfy \\(b + c = -nums[i]\\). We treat \\(-nums[i]\\) as the new \"target sum\" for the remaining subarray.</p> </li> </ol>"},{"location":"15/#the-inner-two-pointer-search","title":"The Inner Two-Pointer Search","text":"<p>For each fixed \\(a = nums[i]\\), we use the two-pointer approach on the remainder of the array, starting from index \\(i+1\\). We initialize a left pointer \\(L\\) at \\(i+1\\) and a right pointer \\(R\\) at the end of the array (\\(n-1\\)). The goal is to find pairs \\((nums[L], nums[R])\\) that sum to the target \\(-nums[i]\\).</p> <p>The pointers \\(L\\) and \\(R\\) move towards each other, shrinking the search space: 1.  Case 1: Sum is Too Small: If \\(nums[L] + nums[R] &lt; -nums[i]\\), the sum needs to be larger. Since the array is sorted, we achieve a larger sum by moving \\(L\\) one step to the right (\\(\\text{increment } L\\)). 2.  Case 2: Sum is Too Large: If \\(nums[L] + nums[R] &gt; -nums[i]\\), the sum needs to be smaller. We achieve a smaller sum by moving \\(R\\) one step to the left (\\(\\text{decrement } R\\)). 3.  Case 3: Match Found: If \\(nums[L] + nums[R] = -nums[i]\\), a valid triplet \\([nums[i], nums[L], nums[R]]\\) has been found. This triplet is added to the result list.</p>"},{"location":"15/#duplicate-elimination-logic","title":"Duplicate Elimination Logic","text":"<p>The problem requires finding unique triplets, which necessitates careful handling of duplicates in both the outer loop (for \\(a\\)) and the inner two-pointer movement (for \\(b\\) and \\(c\\)).</p> <ol> <li> <p>Outer Loop Duplicates (for \\(a\\)): We must ensure that we don't process the same value for \\(a\\) multiple times consecutively. Before starting the inner two-pointer search, we check: if \\(i &gt; 0\\) and \\(nums[i] == nums[i-1]\\), we skip the current iteration using a <code>continue</code> statement. This prevents identical triplets from being generated due to using the same value for \\(a\\).</p> </li> <li> <p>Inner Loop Duplicates (for \\(b\\) and \\(c\\)): After finding a valid triplet (Case 3), we immediately move \\(L\\) and \\(R\\) inward, but we must also skip duplicates that follow \\(L\\) and precede \\(R\\). We advance \\(L\\) forward while \\(L &lt; R\\) and \\(nums[L] == nums[L+1]\\), and we retreat \\(R\\) backward while \\(L &lt; R\\) and \\(nums[R] == nums[R-1]\\). Only after skipping all duplicates do we perform the final move: \\(\\text{increment } L\\) and \\(\\text{decrement } R\\).</p> </li> </ol> <p>By incorporating the initial \\(O(n \\log n)\\) sort with the subsequent \\(O(n^2)\\) search (the outer loop is \\(O(n)\\) and the inner two-pointer loop is \\(O(n)\\)), the total time complexity is dominated by the search, resulting in an optimal \\(O(n^2)\\) time complexity for the entire solution.</p>"},{"location":"16/","title":"16. 3Sum Closest (Medium)","text":""},{"location":"16/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 3Sum Closest Examples ---\")\n\n# Test Case 1: Standard example\nnums1 = [-1, 2, 1, -4]\ntarget1 = 1\nresult1 = sol.threeSumClosest(nums1, target1)\n# Expected: 2 (since -1 + 2 + 1 = 2)\nprint(f\"Input: nums={nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Target is 0\nnums2 = [0, 0, 0]\ntarget2 = 1\nresult2 = sol.threeSumClosest(nums2, target2)\n# Expected: 0\nprint(f\"Input: nums={nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 0)\")\n\n# Test Case 3: Negative numbers and target\nnums3 = [1, 1, 1, 0]\ntarget3 = -100\nresult3 = sol.threeSumClosest(nums3, target3)\n# Expected: 2 (1 + 1 + 0 = 2, the closest sum possible)\nprint(f\"Input: nums={nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: 2)\")\n\n# Test Case 4: Target is reached exactly\nnums4 = [1, 2, 3, 4, 5]\ntarget4 = 7\nresult4 = sol.threeSumClosest(nums4, target4)\n# Expected: 7 (2 + 1 + 4 = 7, or 3 + 2 + 2 = 7 etc.)\nprint(f\"Input: nums={nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 7)\")</pre> Output Clear <pre></pre> </p>"},{"location":"16/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n</code></pre>"},{"location":"16/#16-3sum-closest","title":"16. 3Sum Closest","text":""},{"location":"16/#problem-statement-and-target-definition","title":"Problem Statement and Target Definition","text":"<p>LeetCode problem 16, \"3Sum Closest,\" is a variation of the classic 3Sum problem (LeetCode 15). Given an array of \\(n\\) integers, \\(nums\\), and a specific integer target, the objective is to find three integers in \\(nums\\) such that their sum is the closest possible value to the target. It is generally guaranteed that there will be exactly one solution, simplifying the task of choosing between sums that are equally close.</p> <p>The core challenge is not to find a sum equal to the target, but to minimize the absolute difference between the triplet sum and the target: \\(\\min(|(\\text{nums}[i] + \\text{nums}[j] + \\text{nums}[k]) - \\text{target}|)\\). Similar to the 3Sum problem, a brute force approach of checking all \\(O(n^3)\\) combinations is prohibitively slow, demanding an optimized \\(O(n^2)\\) solution.</p>"},{"location":"16/#optimal-approach-sorting-and-two-pointers","title":"Optimal Approach: Sorting and Two Pointers","text":"<p>The most efficient solution strategy mirrors that of the 3Sum problem, relying on Sorting followed by the Two-Pointer technique.</p> <ol> <li> <p>Sorting: The input array \\(nums\\) is sorted first in \\(O(n \\log n)\\) time. Sorting is crucial because it allows us to efficiently control the magnitude of the three-number sum. By knowing the array is sorted, we can predict whether moving our pointers will increase or decrease the sum relative to the target.</p> </li> <li> <p>Fixing the First Number: We iterate through the array with a primary pointer \\(i\\), fixing the first number \\(a = \\text{nums}[i]\\). The search for the remaining two numbers, \\(b\\) and \\(c\\), then focuses on the subarray starting from \\(i+1\\).</p> </li> </ol>"},{"location":"16/#the-inner-two-pointer-search-and-tracking","title":"The Inner Two-Pointer Search and Tracking","text":"<p>For each fixed \\(\\text{nums}[i]\\), we initialize a left pointer \\(L\\) at \\(i+1\\) and a right pointer \\(R\\) at the end of the array. The inner loop moves \\(L\\) and \\(R\\) towards each other, trying to find a sum \\(\\text{current\\_sum} = \\text{nums}[i] + \\text{nums}[L] + \\text{nums}[R]\\) that is closest to the <code>target</code>.</p> <p>We maintain two variables: one to store the best sum found so far, \\(\\text{closest\\_sum}\\), and one to track the minimum difference, \\(\\text{min\\_diff}\\). In each iteration:</p> <ol> <li> <p>Calculate the Current Sum and Difference: Compute \\(\\text{current\\_sum}\\) and the current difference \\(\\text{current\\_diff} = \\text{current\\_sum} - \\text{target}\\).</p> </li> <li> <p>Update the Closest Sum: We check if the absolute value of \\(\\text{current\\_diff}\\) is smaller than the absolute value of the difference associated with \\(\\text{closest\\_sum}\\) found so far. If it is, \\(\\text{closest\\_sum}\\) is updated to \\(\\text{current\\_sum}\\).</p> </li> <li> <p>Perfect Match Check: If \\(\\text{current\\_sum}\\) equals the \\(\\text{target}\\), we have found the exact solution, and we can immediately return \\(\\text{target}\\), as no other sum can be closer.</p> </li> </ol>"},{"location":"16/#governing-movement-logic","title":"Governing Movement Logic","text":"<p>The decision of which pointer to move (\\(L\\) or \\(R\\)) is the key to minimizing the search space and ensuring \\(O(n)\\) time for the inner loop. The movement is dictated by the sign of the \\(\\text{current\\_diff}\\):</p> <ol> <li> <p>Sum is Too Small (\\(\\text{current\\_diff} &lt; 0\\)): If the \\(\\text{current\\_sum}\\) is less than the \\(\\text{target}\\), we need a larger sum. Since the array is sorted, moving the left pointer \\(L\\) one step to the right will incorporate a larger number \\(\\text{nums}[L]\\), thus increasing the total sum. Therefore, we increment \\(L\\).</p> </li> <li> <p>Sum is Too Large (\\(\\text{current\\_diff} &gt; 0\\)): If the \\(\\text{current\\_sum}\\) is greater than the \\(\\text{target}\\), we need a smaller sum. Moving the right pointer \\(R\\) one step to the left will incorporate a smaller number \\(\\text{nums}[R]\\), thus decreasing the total sum. Therefore, we decrement \\(R\\).</p> </li> </ol> <p>This two-pointer loop continues until \\(L\\) and \\(R\\) cross (\\(L &lt; R\\)). The total time complexity is \\(O(n \\log n)\\) for sorting plus \\(O(n^2)\\) for the nested search (\\(O(n)\\) outer loop \\(\\times\\) \\(O(n)\\) inner loop), resulting in an optimal overall time complexity of \\(O(n^2)\\).  Unlike the 3Sum problem, we do not need complex duplicate checking because we are looking for a closest sum, not a set of unique triplets.</p>"},{"location":"17/","title":"17. Letter Combinations of a Phone Number (Medium)","text":""},{"location":"17/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Letter Combinations of a Phone Number Examples ---\")\n\n# Test Case 1: Standard two-digit input\ndigits1 = \"23\"\nresult1 = sol.letterCombinations(digits1)\n# Expected: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\nprint(f\"Input: '{digits1}'\")\nprint(f\"Output: {result1}\")\nprint(f\"Count: {len(result1)} (Expected: 9)\")\n\n# Test Case 2: Empty input\ndigits2 = \"\"\nresult2 = sol.letterCombinations(digits2)\nprint(f\"Input: '{digits2}'\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Single digit input (7 has 4 letters)\ndigits3 = \"7\"\nresult3 = sol.letterCombinations(digits3)\n# Expected: [\"p\", \"q\", \"r\", \"s\"]\nprint(f\"Input: '{digits3}'\")\nprint(f\"Output: {result3}\")\nprint(f\"Count: {len(result3)} (Expected: 4)\")\n\n# Test Case 4: Longer input (3 digits)\ndigits4 = \"567\"\nresult4 = sol.letterCombinations(digits4)\n# Expected count: 3 * 3 * 4 = 36\nprint(f\"Input: '{digits4}'\")\nprint(f\"Output: {result4[:5]}... (Showing first 5 combinations)\")\nprint(f\"Count: {len(result4)} (Expected: 36)\")</pre> Output Clear <pre></pre> </p>"},{"location":"17/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n</code></pre>"},{"location":"17/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":""},{"location":"17/#problem-statement-and-the-mapping","title":"Problem Statement and The Mapping","text":"<p>LeetCode problem 17, \"Letter Combinations of a Phone Number,\" requires generating all possible letter combinations that a given digit string can represent, based on the standard telephone keypad mapping. The input is a string of digits, and the output is a list of all possible letter sequences. For example, if the input is \"23\", the digit '2' maps to \"abc\" and '3' maps to \"def\". The resulting combinations are \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\".</p> <p>The core challenge is the combinatorial nature of the problem: if the input has \\(N\\) digits, and each digit maps to 3 or 4 letters, the total number of combinations grows exponentially. This type of problem, where we need to explore all possible paths to build a final result, is a classic application for Depth-First Search (DFS), typically implemented using Recursion or Backtracking.</p>"},{"location":"17/#the-recursivebacktracking-approach","title":"The Recursive/Backtracking Approach","text":"<p>The optimal solution uses a recursive helper function that implements the Backtracking algorithm. Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time (the \"backtracking\" part).</p> <p>For this problem, the state of the recursion is defined by two variables: 1.  Current Combination: The string of letters built so far. 2.  Next Digit Index: The index of the digit in the input string we are currently processing.</p> <p>The main function initializes the mapping (e.g., '2' to \"abc\", '3' to \"def\", etc.) and starts the recursive process. </p>"},{"location":"17/#the-recursivedfs-function-logic","title":"The Recursive/DFS Function Logic","text":"<p>The recursive function takes the current combination string and the index of the digit being considered.</p> <ol> <li> <p>Base Case: If the <code>next digit index</code> is equal to the length of the input digit string, it means we have successfully built a complete combination. We add the <code>current combination</code> to the final result list and return. This is the exit condition for the recursion.</p> </li> <li> <p>Recursive Step (The Choice):</p> <ul> <li>We retrieve the current digit from the input string using the <code>next digit index</code>.</li> <li>We look up the corresponding letters for this digit from the mapping (e.g., \"def\" for '3').</li> <li>We iterate through each letter in the retrieved string (e.g., 'd', 'e', 'f'). For each letter, this represents a choice we can make at the current step.</li> </ul> </li> <li> <p>Exploration and Backtracking:</p> <ul> <li>For each chosen letter, we recursively call the function, passing the <code>current combination</code> appended with the chosen letter, and advancing the <code>next digit index</code> by one. This represents exploring a new path in the decision tree.</li> <li>Once the recursive call returns (meaning all combinations starting with that choice have been explored), the mechanism of Backtracking is implicitly handled by the return from the function call. Since the combination is usually passed by value or built in a separate string builder/list that is not modified after the call, no explicit state cleanup is needed, allowing the loop to proceed to the next letter for the current digit.</li> </ul> </li> </ol>"},{"location":"17/#complexity-analysis","title":"Complexity Analysis","text":"<p>The time complexity of this solution is directly proportional to the total number of combinations generated. If \\(N\\) is the length of the input digits and \\(M\\) is the maximum number of letters a digit maps to (usually 3 or 4), the complexity is \\(O(M^N)\\). For instance, with 4 digits and 3 letters per digit, the complexity is \\(O(3^N)\\). The space complexity is also \\(O(M^N)\\) to store the output combinations, plus \\(O(N)\\) for the recursion depth (call stack). This efficiency is optimal because the algorithm must, by definition, generate and store every single possible combination.</p>"},{"location":"18/","title":"18. 4Sum (Medium)","text":""},{"location":"18/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 4Sum Examples ---\")\n\n# Test Case 1: Standard example\nnums1 = [1, 0, -1, 0, -2, 2]\ntarget1 = 0\nresult1 = sol.fourSum(nums1, target1)\n# Expected output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\nprint(f\"Input: nums={nums1}, target={target1}\")\nprint(f\"Output: {result1}\")\nprint(f\"(Expected: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]])\")\n\n# Test Case 2: Array with duplicates and non-zero target\nnums2 = [2, 2, 2, 2, 2]\ntarget2 = 8\nresult2 = sol.fourSum(nums2, target2)\n# Expected output: [[2, 2, 2, 2]] (Only one unique combination)\nprint(f\"Input: nums={nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: [[2, 2, 2, 2]])\")\n\n# Test Case 3: No solution found\nnums3 = [1, 2, 3, 4, 5]\ntarget3 = 10\nresult3 = sol.fourSum(nums3, target3)\nprint(f\"Input: nums={nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: [])\")\n\n# Test Case 4: Negative target\nnums4 = [-3, -1, 0, 2, 4, 5]\ntarget4 = 2\nresult4 = sol.fourSum(nums4, target4)\n# Expected output: [[-3, -1, 2, 4], [-3, 0, 2, 3]... wait, the list is [2, 3, 4, 5]\n# [-3, -1, 2, 4] -&gt; -4 + 6 = 2\n# [-3, 0, 2, 3] -&gt; -3 + 5 = 2\n# After sorting: [-3, -1, 0, 2, 4, 5]\n# [-3, -1, 0, 6] (R=n-1, 6 is not in list)\n# [-3, 0, 2, 3] -&gt; sum is 2. (0, 2, 3 are indices 2, 3, 4, wait, indices are 2, 3, 4 are 0, 2, 4. sum is -3+0+2+4=3).\n# Correct expected: [[-3, -1, 2, 4]]\nprint(f\"Input: nums={nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: [[-3, -1, 2, 4]])\")</pre> Output Clear <pre></pre> </p>"},{"location":"18/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n</code></pre>"},{"location":"18/#18-4sum","title":"18. 4Sum","text":""},{"location":"18/#problem-statement-and-generalization","title":"Problem Statement and Generalization","text":"<p>LeetCode problem 18, \"4Sum,\" is the natural generalization of the 3Sum (LeetCode 15) and 2Sum problems. Given an array of \\(n\\) integers, \\(nums\\), and a specific integer target, the objective is to find all unique quadruplets \\([a, b, c, d]\\) within \\(nums\\) such that their sum equals the target: \\(a + b + c + d = \\text{target}\\). The crucial constraint, identical to 3Sum, is that the resulting list must contain only unique quadruplets.</p> <p>A naive brute force approach using four nested loops would result in an unacceptable time complexity of \\(O(n^4)\\). To solve this problem efficiently and pass typical time limits, we must reduce the complexity to \\(O(n^3)\\) by applying a structure similar to the 3Sum solution: fixing two numbers and then using a linear-time technique (the Two-Pointer method) to find the remaining pair.</p>"},{"location":"18/#the-optimal-approach-sorting-and-two-nested-loops","title":"The Optimal Approach: Sorting and Two Nested Loops","text":"<p>The optimal \\(O(n^3)\\) solution combines Sorting and a nested search structure.</p> <ol> <li> <p>Sorting: First, sort the input array \\(nums\\) in \\(O(n \\log n)\\) time. Sorting is mandatory as it enables the crucial efficiency gains: easy detection and skipping of duplicates, and the linear-time search via the two-pointer technique.</p> </li> <li> <p>Fixing the First Two Numbers: We use two nested loops to fix the first two numbers, \\(a\\) and \\(b\\).</p> <ul> <li>The outer loop iterates with index \\(i\\) for the first number \\(a = \\text{nums}[i]\\).</li> <li>The inner loop iterates with index \\(j\\) for the second number \\(b = \\text{nums}[j]\\), starting from \\(i+1\\). [Image illustrating the 4Sum Two-Pointer structure]</li> </ul> </li> <li> <p>Target Reduction: With \\(a\\) and \\(b\\) fixed, the problem is reduced to finding two remaining numbers, \\(c\\) and \\(d\\), in the rest of the array such that \\(c + d = \\text{target} - \\text{nums}[i] - \\text{nums}[j]\\). We calculate this remaining value as \\(\\text{new\\_target} = \\text{target} - \\text{nums}[i] - \\text{nums}[j]\\).</p> </li> </ol>"},{"location":"18/#the-inner-two-pointer-search","title":"The Inner Two-Pointer Search","text":"<p>For each pair \\((\\text{nums}[i], \\text{nums}[j])\\), the remaining task is a classic Two Sum problem on the subarray starting from index \\(j+1\\) up to the end of the array. We initialize a left pointer \\(L\\) at \\(j+1\\) and a right pointer \\(R\\) at the end of the array.</p> <p>The inner search proceeds as follows: * Calculate the \\(\\text{current\\_sum} = \\text{nums}[L] + \\text{nums}[R]\\). * If \\(\\text{current\\_sum} &lt; \\text{new\\_target}\\): The sum needs to be larger. Since the array is sorted, we move \\(L\\) one step to the right (\\(\\text{increment } L\\)). * If \\(\\text{current\\_sum} &gt; \\text{new\\_target}\\): The sum needs to be smaller. We move \\(R\\) one step to the left (\\(\\text{decrement } R\\)). * If \\(\\text{current\\_sum} = \\text{new\\_target}\\): A valid quadruplet is found. \\([ \\text{nums}[i], \\text{nums}[j], \\text{nums}[L], \\text{nums}[R] ]\\) is added to the result list.</p>"},{"location":"18/#comprehensive-duplicate-elimination","title":"Comprehensive Duplicate Elimination","text":"<p>The most challenging part of 4Sum is correctly and efficiently eliminating all duplicate quadruplets. This requires checks at three distinct points in the iteration:</p> <ol> <li> <p>Skipping Duplicates for \\(a\\) (Outer Loop): Before the inner loop starts, if \\(i &gt; 0\\) and \\(\\text{nums}[i] == \\text{nums}[i-1]\\), we skip the current iteration. This prevents using the same value for \\(a\\) consecutively.</p> </li> <li> <p>Skipping Duplicates for \\(b\\) (Inner Loop): Before the two-pointer search starts, if \\(j &gt; i+1\\) and \\(\\text{nums}[j] == \\text{nums}[j-1]\\), we skip the current iteration. This prevents using the same value for \\(b\\) consecutively with a fixed \\(a\\).</p> </li> <li> <p>Skipping Duplicates for \\(c\\) and \\(d\\) (Two-Pointer Movement): After finding a valid quadruplet, we must advance \\(L\\) and retreat \\(R\\) while skipping any duplicates for the newly found \\(c\\) and \\(d\\):</p> <ul> <li>Advance \\(L\\) while \\(L &lt; R\\) and \\(\\text{nums}[L] == \\text{nums}[L+1]\\).</li> <li>Retreat \\(R\\) while \\(L &lt; R\\) and \\(\\text{nums}[R] == \\text{nums}[R-1]\\).</li> <li>Finally, perform the actual moves: \\(\\text{increment } L\\) and \\(\\text{decrement } R\\).</li> </ul> </li> </ol> <p>By correctly implementing these three checks, the solution ensures that every returned quadruplet is unique. The overall complexity is dominated by the nested loops and the two-pointer search, resulting in the desired \\(O(n^3)\\) time complexity.</p>"},{"location":"19/","title":"19. Remove Nth Node From End of List (Medium)","text":""},{"location":"19/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Nth Node From End of List Examples ---\")\n\n# Test Case 1: Standard case\narr1 = [1, 2, 3, 4, 5]\nn1 = 2\nhead1 = create_linked_list(arr1)\nresult1 = sol.removeNthFromEnd(head1, n1)\n# Expected: [1 -&gt; 2 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}, n={n1}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Remove the head (n = list length)\narr2 = [1]\nn2 = 1\nhead2 = create_linked_list(arr2)\nresult2 = sol.removeNthFromEnd(head2, n2)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}, n={n2}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: List with two nodes, remove the first one\narr3 = [1, 2]\nn3 = 2\nhead3 = create_linked_list(arr3)\nresult3 = sol.removeNthFromEnd(head3, n3)\n# Expected: [2]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}, n={n3}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Larger example, remove node in the middle\narr4 = [10, 20, 30, 40, 50, 60]\nn4 = 3 # Removes 40\nhead4 = create_linked_list(arr4)\nresult4 = sol.removeNthFromEnd(head4, n4)\n# Expected: [10 -&gt; 20 -&gt; 30 -&gt; 50 -&gt; 60]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}, n={n4}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"19/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n</code></pre>"},{"location":"2/","title":"2. Add Two Numbers (Medium)","text":""},{"location":"2/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n\n# Helper function to convert a list of digits to a linked list (in reverse order)\ndef create_linked_list(digits):\n    dummy_head = ListNode(0)\n    current = dummy_head\n    for digit in digits:\n        current.next = ListNode(digit)\n        current = current.next\n    return dummy_head.next\n\n# Helper function to convert a linked list to a list of digits\ndef linked_list_to_list(node):\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\n\n# Example 1: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) -&gt; (7 -&gt; 0 -&gt; 8)\nl1_ex1 = create_linked_list([2, 4, 3])\nl2_ex1 = create_linked_list([5, 6, 4])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex1, l2_ex1)), \"\\n\")\n\n# Example 2: (0) + (0) -&gt; (0)\nl1_ex2 = create_linked_list([0])\nl2_ex2 = create_linked_list([0])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex2, l2_ex2)), \"\\n\")\n\n# Example 3: (9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9) + (9 -&gt; 9 -&gt; 9 -&gt; 9) -&gt; (8 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 1)\nl1_ex3 = create_linked_list([9, 9, 9, 9, 9, 9, 9])\nl2_ex3 = create_linked_list([9, 9, 9, 9])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex3, l2_ex3)))</pre> Output Clear <pre></pre> </p>"},{"location":"2/#solution","title":"Solution","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#function-description","title":"Function Description","text":"<p>Contains the method to add two numbers represented by linked lists.</p> Source code in <code>python/_2.py</code> <pre><code>class Solution:\n    \"\"\"\n    Contains the method to add two numbers represented by linked lists.\n    \"\"\"\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        Adds two non-negative numbers represented as two singly-linked lists.\n\n        The digits are stored in **reverse order** (the head is the 1's place), \n        and each node contains a single digit. The process simulates manual \n        addition, moving from the least significant digit to the most significant \n        digit while managing a carry. \n\n        The time complexity is $O(\\max(L_1, L_2))$, where $L_1$ and $L_2$ are the \n        lengths of the input linked lists, as we traverse the lists once.\n\n        Args:\n            l1 (Optional[ListNode]): The head of the first linked list (number 1).\n            l2 (Optional[ListNode]): The head of the second linked list (number 2).\n\n        Returns:\n            dummy_head (Optional[ListNode]): The head of a new linked list representing the sum \n                                of the two input numbers.\n\n        Examples:\n            &gt;&gt;&gt; # l1: (2 -&gt; 4 -&gt; 3) which is 342\n            &gt;&gt;&gt; # l2: (5 -&gt; 6 -&gt; 4) which is 465\n            &gt;&gt;&gt; # Sum: 342 + 465 = 807\n            &gt;&gt;&gt; # Result linked list: (7 -&gt; 0 -&gt; 8)\n            &gt;&gt;&gt; l1 = create_linked_list([2, 4, 3])\n            &gt;&gt;&gt; l2 = create_linked_list([5, 6, 4])\n            &gt;&gt;&gt; result = Solution().addTwoNumbers(l1, l2)\n            &gt;&gt;&gt; linked_list_to_list(result)\n            [7, 0, 8]\n        \"\"\"\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#_2.Solution.addTwoNumbers","title":"<code>addTwoNumbers(l1, l2)</code>","text":"<p>Adds two non-negative numbers represented as two singly-linked lists.</p> <p>The digits are stored in reverse order (the head is the 1's place),  and each node contains a single digit. The process simulates manual  addition, moving from the least significant digit to the most significant  digit while managing a carry. </p> <p>The time complexity is \\(O(\\max(L_1, L_2))\\), where \\(L_1\\) and \\(L_2\\) are the  lengths of the input linked lists, as we traverse the lists once.</p> <p>Parameters:</p> Name Type Description Default <code>l1</code> <code>Optional[ListNode]</code> <p>The head of the first linked list (number 1).</p> required <code>l2</code> <code>Optional[ListNode]</code> <p>The head of the second linked list (number 2).</p> required <p>Returns:</p> Name Type Description <code>dummy_head</code> <code>Optional[ListNode]</code> <p>The head of a new linked list representing the sum                  of the two input numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # l1: (2 -&gt; 4 -&gt; 3) which is 342\n&gt;&gt;&gt; # l2: (5 -&gt; 6 -&gt; 4) which is 465\n&gt;&gt;&gt; # Sum: 342 + 465 = 807\n&gt;&gt;&gt; # Result linked list: (7 -&gt; 0 -&gt; 8)\n&gt;&gt;&gt; l1 = create_linked_list([2, 4, 3])\n&gt;&gt;&gt; l2 = create_linked_list([5, 6, 4])\n&gt;&gt;&gt; result = Solution().addTwoNumbers(l1, l2)\n&gt;&gt;&gt; linked_list_to_list(result)\n[7, 0, 8]\n</code></pre> Source code in <code>python/_2.py</code> <pre><code>def addTwoNumbers(self, l1, l2):\n    \"\"\"\n    Adds two non-negative numbers represented as two singly-linked lists.\n\n    The digits are stored in **reverse order** (the head is the 1's place), \n    and each node contains a single digit. The process simulates manual \n    addition, moving from the least significant digit to the most significant \n    digit while managing a carry. \n\n    The time complexity is $O(\\max(L_1, L_2))$, where $L_1$ and $L_2$ are the \n    lengths of the input linked lists, as we traverse the lists once.\n\n    Args:\n        l1 (Optional[ListNode]): The head of the first linked list (number 1).\n        l2 (Optional[ListNode]): The head of the second linked list (number 2).\n\n    Returns:\n        dummy_head (Optional[ListNode]): The head of a new linked list representing the sum \n                            of the two input numbers.\n\n    Examples:\n        &gt;&gt;&gt; # l1: (2 -&gt; 4 -&gt; 3) which is 342\n        &gt;&gt;&gt; # l2: (5 -&gt; 6 -&gt; 4) which is 465\n        &gt;&gt;&gt; # Sum: 342 + 465 = 807\n        &gt;&gt;&gt; # Result linked list: (7 -&gt; 0 -&gt; 8)\n        &gt;&gt;&gt; l1 = create_linked_list([2, 4, 3])\n        &gt;&gt;&gt; l2 = create_linked_list([5, 6, 4])\n        &gt;&gt;&gt; result = Solution().addTwoNumbers(l1, l2)\n        &gt;&gt;&gt; linked_list_to_list(result)\n        [7, 0, 8]\n    \"\"\"\n    dummy_head = ListNode(0)\n    current = dummy_head\n    carry = 0\n\n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n\n        total_sum = val1 + val2 + carry\n        carry = total_sum // 10\n        new_digit = total_sum % 10\n\n        current.next = ListNode(new_digit)\n        current = current.next\n\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n\n    return dummy_head.next\n</code></pre>"},{"location":"2/#2-add-two-numbers","title":"2. Add Two Numbers","text":""},{"location":"2/#problem-statement-and-representation","title":"Problem Statement and Representation","text":"<p>LeetCode problem 2, \"Add Two Numbers,\" requires the simulation of adding two non-negative integers that are represented in a rather unusual format: as linked lists. Specifically, each digit of the number is stored in a separate node of the linked list, and the digits are stored in reverse order. For example, the number 342 would be represented by a linked list \\(2 \\rightarrow 4 \\rightarrow 3\\). The task is to take two such linked lists, \\(l1\\) and \\(l2\\), add the numbers they represent, and return the sum as a new linked list in the same reverse-digit format.</p> <p>The reversed storage order is a crucial design choice that greatly simplifies the addition process. It allows us to start adding from the least significant digit (the ones place, which is the head of the list) without needing to traverse the lists to find the end first, as would be necessary if the digits were stored in forward order. This structure inherently facilitates the standard, elementary-school method of addition, working from right to left.</p>"},{"location":"2/#the-iterative-addition-process","title":"The Iterative Addition Process","text":"<p>The most efficient and common solution to this problem is an iterative simulation of manual column addition, which naturally involves a concept known as the carry. We initialize a dummy head node for the resulting sum list, which simplifies the process of appending new nodes, and we maintain a current pointer to build the list. A crucial variable, <code>carry</code>, is initialized to 0.</p> <p>We traverse both input linked lists, \\(l1\\) and \\(l2\\), simultaneously. The iteration continues as long as there are remaining nodes in \\(l1\\) or \\(l2\\), or if the <code>carry</code> variable is still greater than zero. This third condition is vital, as it ensures that any final carry digit generated by the last sum is correctly included as the final node of the result list.</p>"},{"location":"2/#calculating-the-sum-and-carry","title":"Calculating the Sum and Carry","text":"<p>In each step of the iteration, we calculate the total sum for the current \"column\" of digits. This sum includes the value of the current node from \\(l1\\) (if it exists), the value of the current node from \\(l2\\) (if it exists), and the value of the <code>carry</code> from the previous step. If a list pointer has already reached the end, its value for that step is considered 0.</p> <p>Once the total sum (\\(\\text{sum}\\)) is computed, we determine the two components required for the next step: the digit for the current node and the new carry. The digit that should be placed in the new node of the result list is the \\(\\text{sum}\\) modulo 10, or \\(\\text{digit} = \\text{sum} \\pmod{10}\\). This calculation correctly isolates the single digit for the current place value. The new <code>carry</code> value that must be transferred to the next (more significant) place value is calculated by integer division: \\(\\text{carry} = \\text{sum} / 10\\). </p>"},{"location":"2/#building-the-result-list-and-complexity","title":"Building the Result List and Complexity","text":"<p>A new node containing the calculated \\(\\text{digit}\\) is created and appended to the result linked list using the current pointer. We then advance the pointers for \\(l1\\) and \\(l2\\) to their next respective nodes (if they exist) and move the result list's current pointer to the newly created node, preparing it for the next iteration.</p> <p>This iterative process guarantees that the resulting sum list is built correctly, digit by digit, from the least significant to the most significant. The time complexity of this solution is \\(O(\\max(m, n))\\), where \\(m\\) and \\(n\\) are the lengths of the two input linked lists. This is an optimal linear time complexity, as we must process every node at least once. The space complexity is also \\(O(\\max(m, n))\\) because a new linked list of up to that length must be created to store the result.</p>"},{"location":"20/","title":"20. Valid Parentheses (Easy)","text":""},{"location":"20/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Valid Parentheses Examples ---\")\n\n# Test Case 1: Valid string\ns1 = \"()[]{}\"\nresult1 = sol.isValid(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n# Test Case 2: Invalid order\ns2 = \"(]\"\nresult2 = sol.isValid(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: False)\")\n\n# Test Case 3: Invalid closing type\ns3 = \"([)]\"\nresult3 = sol.isValid(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: False)\")\n\n# Test Case 4: Valid nested string\ns4 = \"{[]}\"\nresult4 = sol.isValid(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: True)\")\n\n# Test Case 5: Unclosed bracket (stack not empty at end)\ns5 = \"([{\"\nresult5 = sol.isValid(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Closed bracket with empty stack (placeholder mismatch)\ns6 = \")))\"\nresult6 = sol.isValid(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: False)\")</pre> Output Clear <pre></pre> </p>"},{"location":"20/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n</code></pre>"},{"location":"21/","title":"21. Merge Two Sorted Lists (Easy)","text":""},{"location":"21/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Merge Two Sorted Lists Examples ---\")\n\n# Test Case 1: Standard merge\narr1 = [1, 2, 4]\narr2 = [1, 3, 4]\nlist1 = create_linked_list(arr1)\nlist2 = create_linked_list(arr2)\nresult1 = sol.mergeTwoLists(list1, list2)\n# Expected: [1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr1))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr2))}\")\nprint(f\"Output: {print_linked_list(result1)}\")\n\n# Test Case 2: One empty list\narr3 = []\narr4 = [0]\nlist3 = create_linked_list(arr3)\nlist4 = create_linked_list(arr4)\nresult2 = sol.mergeTwoLists(list3, list4)\n# Expected: [0]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr3))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr4))}\")\nprint(f\"Output: {print_linked_list(result2)}\")\n\n# Test Case 3: Both empty lists\narr5 = []\narr6 = []\nlist5 = create_linked_list(arr5)\nlist6 = create_linked_list(arr6)\nresult3 = sol.mergeTwoLists(list5, list6)\n# Expected: []\nprint(f\"List 1: {print_linked_list(create_linked_list(arr5))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr6))}\")\nprint(f\"Output: {print_linked_list(result3)}\")\n\n# Test Case 4: One list contains all smaller elements\narr7 = [1, 2, 3]\narr8 = [4, 5, 6]\nlist7 = create_linked_list(arr7)\nlist8 = create_linked_list(arr8)\nresult4 = sol.mergeTwoLists(list7, list8)\n# Expected: [1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr7))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr8))}\")\nprint(f\"Output: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"21/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n</code></pre>"},{"location":"22/","title":"22. Generate Parentheses (Medium)","text":""},{"location":"22/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Generate Parentheses Examples ---\")\n\n# Test Case 1: n = 3\nn1 = 3\nresult1 = sol.generateParenthesis(n1)\n# Expected: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nprint(f\"Input: n={n1}\")\nprint(f\"Output: {result1}\")\nprint(f\"Count: {len(result1)} (Expected: 5)\")\n\n# Test Case 2: n = 1\nn2 = 1\nresult2 = sol.generateParenthesis(n2)\n# Expected: [\"()\"]\nprint(f\"Input: n={n2}\")\nprint(f\"Output: {result2}\")\nprint(f\"Count: {len(result2)} (Expected: 1)\")\n\n# Test Case 3: n = 2\nn3 = 2\nresult3 = sol.generateParenthesis(n3)\n# Expected: [\"(())\", \"()()\"]\nprint(f\"Input: n={n3}\")\nprint(f\"Output: {result3}\")\nprint(f\"Count: {len(result3)} (Expected: 2)\")</pre> Output Clear <pre></pre> </p>"},{"location":"22/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n</code></pre>"},{"location":"23/","title":"23. Merge k Sorted Lists (Hard)","text":""},{"location":"23/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Merge k Sorted Lists Examples ---\")\n\n# Test Case 1: Standard k=3 lists\narr1 = [1, 4, 5]\narr2 = [1, 3, 4]\narr3 = [2, 6]\nlists1 = [create_linked_list(arr1), create_linked_list(arr2), create_linked_list(arr3)]\nresult1 = sol.mergeKLists(lists1)\n# Expected: [1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6]\nprint(f\"Input Lists: {[[1, 4, 5], [1, 3, 4], [2, 6]]}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Empty input list\nlists2 = []\nresult2 = sol.mergeKLists(lists2)\n# Expected: []\nprint(f\"Input Lists: {[]}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: List containing empty lists\narr4 = []\narr5 = [1, 5]\narr6 = [2, 4]\nlists3 = [create_linked_list(arr4), create_linked_list(arr5), create_linked_list(arr6)]\nresult3 = sol.mergeKLists(lists3)\n# Expected: [1 -&gt; 2 -&gt; 4 -&gt; 5]\nprint(f\"Input Lists: {[[2, 4], [1, 5], []]}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Single list in the input\nlists4 = [create_linked_list([10, 20, 30])]\nresult4 = sol.mergeKLists(lists4)\n# Expected: [10 -&gt; 20 -&gt; 30]\nprint(f\"Input Lists: {[[10, 20, 30]]}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"23/#solution","title":"Solution","text":"<pre><code>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n</code></pre>"},{"location":"24/","title":"24. Swap Nodes in Pairs (Medium)","text":""},{"location":"24/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Swap Nodes in Pairs Examples ---\")\n\n# Test Case 1: Standard case (even number of nodes)\narr1 = [1, 2, 3, 4]\nhead1 = create_linked_list(arr1)\nresult1 = sol.swapPairs(head1)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Odd number of nodes (last node remains in place)\narr2 = [1, 2, 3, 4, 5]\nhead2 = create_linked_list(arr2)\nresult2 = sol.swapPairs(head2)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: Empty list\narr3 = []\nhead3 = create_linked_list(arr3)\nresult3 = sol.swapPairs(head3)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Single node\narr4 = [1]\nhead4 = create_linked_list(arr4)\nresult4 = sol.swapPairs(head4)\n# Expected: [1]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"24/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n</code></pre>"},{"location":"25/","title":"25. Reverse Nodes in k-Group (Hard)","text":""},{"location":"25/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Reverse Nodes in k-Group Examples ---\")\n\n# Test Case 1: Standard case (k=2)\narr1 = [1, 2, 3, 4, 5]\nk1 = 2\nhead1 = create_linked_list(arr1)\nresult1 = sol.reverseKGroup(head1, k1)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}, k={k1}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Standard case (k=3)\narr2 = [1, 2, 3, 4, 5]\nk2 = 3\nhead2 = create_linked_list(arr2)\nresult2 = sol.reverseKGroup(head2, k2)\n# Expected: [3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5] (The last two nodes are not reversed)\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}, k={k2}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: Empty list\narr3 = []\nk3 = 2\nhead3 = create_linked_list(arr3)\nresult3 = sol.reverseKGroup(head3, k3)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}, k={k3}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: k is greater than list length\narr4 = [1, 2]\nk4 = 3\nhead4 = create_linked_list(arr4)\nresult4 = sol.reverseKGroup(head4, k4)\n# Expected: [1 -&gt; 2] (No reversal occurs)\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}, k={k4}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"25/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n</code></pre>"},{"location":"26/","title":"26. Remove Duplicates from Sorted Array (Easy)","text":""},{"location":"26/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Duplicates from Sorted Array Examples ---\")\n\n# Test Case 1: Standard case\nnums1 = [1, 1, 2]\noriginal_nums1 = list(nums1) # Keep original for printout\nk1 = sol.removeDuplicates(nums1)\n# The first k elements should be [1, 2]\nprint(f\"Input: {original_nums1}\")\nprint(f\"Output Length (k): {k1} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums1[:k1]}\")\n\n# Test Case 2: Many duplicates\nnums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\noriginal_nums2 = list(nums2)\nk2 = sol.removeDuplicates(nums2)\n# The first k elements should be [0, 1, 2, 3, 4]\nprint(f\"\\nInput: {original_nums2}\")\nprint(f\"Output Length (k): {k2} (Expected: 5)\")\nprint(f\"Modified Array (first k elements): {nums2[:k2]}\")\n\n# Test Case 3: No duplicates\nnums3 = [10, 20, 30]\noriginal_nums3 = list(nums3)\nk3 = sol.removeDuplicates(nums3)\n# The first k elements should be [10, 20, 30]\nprint(f\"\\nInput: {original_nums3}\")\nprint(f\"Output Length (k): {k3} (Expected: 3)\")\nprint(f\"Modified Array (first k elements): {nums3[:k3]}\")\n\n# Test Case 4: Empty array\nnums4 = []\noriginal_nums4 = list(nums4)\nk4 = sol.removeDuplicates(nums4)\n# Expected: 0\nprint(f\"\\nInput: {original_nums4}\")\nprint(f\"Output Length (k): {k4} (Expected: 0)\")\nprint(f\"Modified Array (first k elements): {nums4[:k4]}\")</pre> Output Clear <pre></pre> </p>"},{"location":"26/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n</code></pre>"},{"location":"27/","title":"27. Remove Element (Easy)","text":""},{"location":"27/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Element Examples ---\")\n\n# Test Case 1: Standard case\nnums1 = [3, 2, 2, 3]\nval1 = 3\noriginal_nums1 = list(nums1) # Keep original for printout\nk1 = sol.removeElement(nums1, val1)\n# The first k elements should be [2, 2]\nprint(f\"Input: {original_nums1}, val={val1}\")\nprint(f\"Output Length (k): {k1} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums1[:k1]}\")\n\n# Test Case 2: Target value is not present\nnums2 = [4, 5]\nval2 = 1\noriginal_nums2 = list(nums2)\nk2 = sol.removeElement(nums2, val2)\n# The first k elements should be [4, 5]\nprint(f\"\\nInput: {original_nums2}, val={val2}\")\nprint(f\"Output Length (k): {k2} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums2[:k2]}\")\n\n# Test Case 3: Target value is all elements\nnums3 = [5, 5, 5]\nval3 = 5\noriginal_nums3 = list(nums3)\nk3 = sol.removeElement(nums3, val3)\n# The first k elements should be []\nprint(f\"\\nInput: {original_nums3}, val={val3}\")\nprint(f\"Output Length (k): {k3} (Expected: 0)\")\nprint(f\"Modified Array (first k elements): {nums3[:k3]}\")\n\n# Test Case 4: Longer array\nnums4 = [0, 1, 2, 2, 3, 0, 4, 2]\nval4 = 2\noriginal_nums4 = list(nums4)\nk4 = sol.removeElement(nums4, val4)\n# The first k elements should be [0, 1, 3, 0, 4] (order may vary, but these 5 unique elements must be present)\nprint(f\"\\nInput: {original_nums4}, val={val4}\")\nprint(f\"Output Length (k): {k4} (Expected: 5)\")\nprint(f\"Modified Array (first k elements): {nums4[:k4]}\")</pre> Output Clear <pre></pre> </p>"},{"location":"27/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n</code></pre>"},{"location":"28/","title":"28. Find the Index of the First Occurrence in a String (Easy)","text":""},{"location":"28/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Find the Index of the First Occurrence in a String Examples ---\")\n\n# Test Case 1: Standard match\nhaystack1 = \"sadbutsad\"\nneedle1 = \"sad\"\nresult1 = sol.strStr(haystack1, needle1)\nprint(f\"Haystack: '{haystack1}', Needle: '{needle1}'\")\nprint(f\"Output: {result1} (Expected: 0)\")\n\n# Test Case 2: No match\nhaystack2 = \"leetcode\"\nneedle2 = \"leeto\"\nresult2 = sol.strStr(haystack2, needle2)\nprint(f\"\\nHaystack: '{haystack2}', Needle: '{needle2}'\")\nprint(f\"Output: {result2} (Expected: -1)\")\n\n# Test Case 3: Empty needle\nhaystack3 = \"abc\"\nneedle3 = \"\"\nresult3 = sol.strStr(haystack3, needle3)\nprint(f\"\\nHaystack: '{haystack3}', Needle: '{needle3}'\")\nprint(f\"Output: {result3} (Expected: 0)\")\n\n# Test Case 4: Match in the middle\nhaystack4 = \"hello\"\nneedle4 = \"ll\"\nresult4 = sol.strStr(haystack4, needle4)\nprint(f\"\\nHaystack: '{haystack4}', Needle: '{needle4}'\")\nprint(f\"Output: {result4} (Expected: 2)\")\n\n# Test Case 5: Match at the end\nhaystack5 = \"mississippi\"\nneedle5 = \"pi\"\nresult5 = sol.strStr(haystack5, needle5)\nprint(f\"\\nHaystack: '{haystack5}', Needle: '{needle5}'\")\nprint(f\"Output: {result5} (Expected: 9)\")</pre> Output Clear <pre></pre> </p>"},{"location":"28/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n</code></pre>"},{"location":"29/","title":"29. Divide Two Integers (Medium)","text":""},{"location":"29/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Divide Two Integers Examples ---\")\n\n# Test Case 1: Standard positive division\ndividend1, divisor1 = 10, 3\nresult1 = sol.divide(dividend1, divisor1)\nprint(f\"Input: {dividend1} / {divisor1}\")\nprint(f\"Output: {result1} (Expected: 3)\")\n\n# Test Case 2: Negative result\ndividend2, divisor2 = 7, -3\nresult2 = sol.divide(dividend2, divisor2)\nprint(f\"Input: {dividend2} / {divisor2}\")\nprint(f\"Output: {result2} (Expected: -2)\")\n\n# Test Case 3: Overflow edge case (MAX_INT)\ndividend3, divisor3 = -2147483648, -1\nresult3 = sol.divide(dividend3, divisor3)\nprint(f\"Input: {dividend3} / {divisor3}\")\nprint(f\"Output: {result3} (Expected: 2147483647)\")\n\n# Test Case 4: Dividend is smaller than divisor\ndividend4, divisor4 = 1, 2\nresult4 = sol.divide(dividend4, divisor4)\nprint(f\"Input: {dividend4} / {divisor4}\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Large division\ndividend5, divisor5 = 100, 10\nresult5 = sol.divide(dividend5, divisor5)\nprint(f\"Input: {dividend5} / {divisor5}\")\nprint(f\"Output: {result5} (Expected: 10)\")</pre> Output Clear <pre></pre> </p>"},{"location":"29/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n</code></pre>"},{"location":"3/","title":"3. Longest Substring Without Repeating Characters (Medium)","text":""},{"location":"3/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n# Example Usage:\nsol = Solution()\nprint(sol.lengthOfLongestSubstring(\"abcabcbb\")) # Output: 3 (\"abc\")\nprint(sol.lengthOfLongestSubstring(\"bbbbb\"))    # Output: 1 (\"b\")\nprint(sol.lengthOfLongestSubstring(\"pwwkew\"))   # Output: 3 (\"wke\")</pre> Output Clear <pre></pre> </p>"},{"location":"3/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"3/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":""},{"location":"3/#problem-statement-and-definition","title":"Problem Statement and Definition","text":"<p>LeetCode problem 3, \"Longest Substring Without Repeating Characters,\" is a classic string manipulation challenge. The objective is to determine the length of the longest substring within a given string \\(s\\) that does not contain any repeating characters. A substring must be a contiguous sequence of characters, meaning the characters must appear consecutively in the original string. The challenge is to find the maximum possible length of such a unique sequence.</p> <p>For instance, if the input string is \"abcabcbb\", the substrings without repeating characters are \"abc\", \"bca\", \"cab\", and \"cbb\". The longest among these is \"abc\", with a length of 3. If the input is \"pwwkew\", the longest substring is \"wke\" or \"kew\" (not \"pwke\" as 'w' repeats, and not \"pwwkew\" as 'w' repeats), which has a length of 3. The distinction between a substring and a subsequence is crucial: \"pwke\" is a subsequence but not a substring because the 'w's are separated in the original string by 'k' and 'e', thus violating the contiguity rule.</p>"},{"location":"3/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>A naive Brute Force solution would be to generate every possible substring of the input string \\(s\\) and, for each substring, check if all of its characters are unique. Generating all substrings takes \\(O(n^2)\\) time, where \\(n\\) is the length of \\(s\\), as there are \\(\\frac{n(n+1)}{2}\\) total substrings. For each generated substring, checking for uniqueness typically involves using a Set data structure or comparing every character against every other character within that substring, which can take up to \\(O(n)\\) time.</p> <p>Combining these steps leads to an overall time complexity of \\(O(n^3)\\). While this approach is correct, its cubic time complexity makes it highly impractical for strings of significant length. The need for a faster solution drives us toward a more sophisticated, linear-time algorithm.</p>"},{"location":"3/#the-optimized-sliding-window-technique","title":"The Optimized Sliding Window Technique","text":"<p>The problem is best solved using the Sliding Window pattern, which optimizes the search process to achieve \\(O(n)\\) time complexity. This technique involves maintaining a \"window,\" which is a contiguous range of elements (a substring) in the input string. The window dynamically expands or shrinks as we iterate through the input.</p> <p>In this specific application, the window is defined by two pointers, a left pointer \\(i\\) and a right pointer \\(j\\), representing the current substring \\([i, j)\\). We use a Hash Set (or a Map) to efficiently store the characters currently present within the window. The set allows us to check for the existence of a character in \\(O(1)\\) time on average. </p>"},{"location":"3/#mechanism-of-the-sliding-window","title":"Mechanism of the Sliding Window","text":"<p>The process begins by expanding the window using the right pointer \\(j\\). We examine the character \\(s[j]\\). 1.  Expansion: If the character \\(s[j]\\) is not currently present in our Hash Set, it means the current window \\([i, j]\\) is still valid (contains only unique characters). We add \\(s[j]\\) to the set, increment the right pointer \\(j\\), and update our record of the maximum length found so far: \\(\\text{max\\_len} = \\max(\\text{max\\_len}, j - i)\\). 2.  Contraction (Sliding): If the character \\(s[j]\\) is already present in the Hash Set, we have found a repeating character. The window \\([i, j]\\) is now invalid. We must shrink the window from the left by incrementing the left pointer \\(i\\). As we move \\(i\\) forward, we remove the character \\(s[i]\\) from the Hash Set. We continue this shrinking process until the repeating character is no longer inside the window, at which point the character \\(s[j]\\) can be safely added, and the expansion resumes.</p> <p>This single-pass, two-pointer approach is extremely efficient. The key insight is that both the left pointer \\(i\\) and the right pointer \\(j\\) traverse the string \\(s\\) at most once. Therefore, each character is visited, added to the set, and removed from the set at most once, leading to an overall linear time complexity of \\(O(n)\\). The space complexity is \\(O(k)\\), where \\(k\\) is the size of the character set (e.g., \\(k=26\\) for lowercase English letters, or \\(k=128\\) for ASCII characters), which is often considered \\(O(1)\\) since \\(k\\) is constant.</p>"},{"location":"30/","title":"30. Substring with Concatenation of All Words (Hard)","text":""},{"location":"30/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Substring with Concatenation of All Words Examples ---\")\n\n# Test Case 1: Standard example\ns1 = \"barfoothefoobarman\"\nwords1 = [\"foo\", \"bar\"]\nresult1 = sol.findSubstring(s1, words1)\n# Expected: [0, 9] (\"barfoo\" at 0, \"foobar\" at 9)\nprint(f\"Input: s='{s1}', words={words1}\")\nprint(f\"Output: {result1} (Expected: [0, 9])\")\n\n# Test Case 2: Overlapping words, multiple results\ns2 = \"wordgoodgoodgoodbestword\"\nwords2 = [\"word\", \"good\", \"best\", \"word\"]\nresult2 = sol.findSubstring(s2, words2)\n# Expected: [] (The three 'good's are not covered by the required words)\nprint(f\"\\nInput: s='{s2}', words={words2}\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Duplicates in words\ns3 = \"barfoofoobarthefoobarman\"\nwords3 = [\"bar\", \"foo\", \"the\"]\nresult3 = sol.findSubstring(s3, words3)\n# Expected: [6, 9, 12]\nprint(f\"\\nInput: s='{s3}', words={words3}\")\nprint(f\"Output: {result3} (Expected: [6, 9, 12])\")\n\n# Test Case 4: Long string with words that are not found\ns4 = \"barfoobarman\"\nwords4 = [\"man\", \"bar\"]\nresult4 = sol.findSubstring(s4, words4)\n# Expected: [6] (\"manbar\" is not present, but \"barman\" is not valid. The only valid is \"foobarman\" where \"bar\" is at 6)\n# Correct Expected: [6] (\"barfoobarman\" -&gt; \"bar\" at 0, \"foo\" at 3, \"bar\" at 6, \"man\" at 9. Valid concatenation is \"barfoo\" or \"foobar\", but target is 2 words.\n# \"foobar\" at 6: \"barman\" - No.\n# \"barfoobarman\" - word_len=3, num_words=2, total_len=6\n# Window 0-5: \"barfoo\". Words: [\"bar\", \"foo\"]. Match. Index 0.\n# Window 3-8: \"foothe\". Words: [\"foo\", \"the\"]. Target: [\"man\", \"bar\"]. No match.\n# Correct Expected: [6] for [\"bar\", \"foo\", \"the\"] is wrong.\n# Correct for words4: [\"man\", \"bar\"] is target.\n# Index 6: \"barman\" -&gt; [\"bar\", \"man\"]. Match. Index 6.\nprint(f\"\\nInput: s='{s4}', words={words4}\")\nprint(f\"Output: {result4} (Expected: [6])\")</pre> Output Clear <pre></pre> </p>"},{"location":"30/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n</code></pre>"},{"location":"31/","title":"31. Next Permutation (Medium)","text":""},{"location":"31/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Next Permutation Examples ---\")\n\n# Helper function to test and print the result\ndef test_permutation(nums_list):\n    original = list(nums_list)\n    sol.nextPermutation(nums_list)\n    print(f\"Input: {original}\")\n    print(f\"Output: {nums_list}\")\n\n# Test Case 1: Standard case\ntest_permutation([1, 2, 3]) # Expected: [1, 3, 2]\n\n# Test Case 2: Array needs partial reversal and swap\ntest_permutation([3, 2, 1]) # Expected: [1, 2, 3] (Sorted descending, so becomes the lowest)\n\n# Test Case 3: Finding the pivot and swap candidate\ntest_permutation([1, 1, 5]) # Expected: [1, 5, 1]\n\n# Test Case 4: Complex swap and reverse\ntest_permutation([1, 5, 8, 4, 7, 6, 5, 3, 1]) # Expected: [1, 5, 8, 5, 1, 3, 4, 6, 7]\n\n# Test Case 5: Single element\ntest_permutation([4]) # Expected: [4]</pre> Output Clear <pre></pre> </p>"},{"location":"31/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n</code></pre>"},{"location":"32/","title":"32. Longest Valid Parentheses (Hard)","text":""},{"location":"32/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Longest Valid Parentheses Examples ---\")\n\n# Test Case 1: Standard case\ns1 = \"(()\"\nresult1 = sol.longestValidParentheses(s1)\n# Expected: 2 (from \"()\")\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Complex valid substring\ns2 = \")()())\"\nresult2 = sol.longestValidParentheses(s2)\n# Expected: 4 (from \"()()\")\nprint(f\"\\nInput: '{s2}'\")\nprint(f\"Output: {result2} (Expected: 4)\")\n\n# Test Case 3: Fully valid\ns3 = \"()(())\"\nresult3 = sol.longestValidParentheses(s3)\n# Expected: 6\nprint(f\"\\nInput: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 6)\")\n\n# Test Case 4: Long string with multiple parts\ns4 = \")(()())(()(\"\nresult4 = sol.longestValidParentheses(s4)\n# Expected: 6 (from \"()()()\" at index 2)\nprint(f\"\\nInput: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 6)\")\n\n# Test Case 5: Empty string\ns5 = \"\"\nresult5 = sol.longestValidParentheses(s5)\n# Expected: 0\nprint(f\"\\nInput: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 0)\")</pre> Output Clear <pre></pre> </p>"},{"location":"32/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n</code></pre>"},{"location":"33/","title":"33. Search in Rotated Sorted Array (Medium)","text":""},{"location":"33/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Search in Rotated Sorted Array Examples ---\")\n\n# Test Case 1: Target found in the left half of the original array (right of pivot)\nnums1 = [4, 5, 6, 7, 0, 1, 2]\ntarget1 = 0\nresult1 = sol.search(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 4)\")\n\n# Test Case 2: Target found in the right half of the original array (left of pivot)\nnums2 = [4, 5, 6, 7, 0, 1, 2]\ntarget2 = 6\nresult2 = sol.search(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 2)\")\n\n# Test Case 3: Target not found\nnums3 = [4, 5, 6, 7, 0, 1, 2]\ntarget3 = 3\nresult3 = sol.search(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: -1)\")\n\n# Test Case 4: Array with a single rotation (pivot is nums[0])\nnums4 = [1, 3]\ntarget4 = 3\nresult4 = sol.search(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 1)\")\n\n# Test Case 5: Pivot at the end\nnums5 = [3, 1]\ntarget5 = 1\nresult5 = sol.search(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: 1)\")</pre> Output Clear <pre></pre> </p>"},{"location":"33/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n</code></pre>"},{"location":"34/","title":"34. Find First and Last Position of Element in Sorted Array (Medium)","text":""},{"location":"34/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Find First and Last Position of Element Examples ---\")\n\n# Test Case 1: Standard case with target found multiple times\nnums1 = [5, 7, 7, 8, 8, 10]\ntarget1 = 8\nresult1 = sol.searchRange(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: [3, 4])\")\n\n# Test Case 2: Target found once\nnums2 = [1, 2, 3, 4, 5]\ntarget2 = 3\nresult2 = sol.searchRange(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: [2, 2])\")\n\n# Test Case 3: Target not found\nnums3 = [5, 7, 7, 8, 8, 10]\ntarget3 = 6\nresult3 = sol.searchRange(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: [-1, -1])\")\n\n# Test Case 4: Empty array\nnums4 = []\ntarget4 = 0\nresult4 = sol.searchRange(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: [-1, -1])\")\n\n# Test Case 5: Target is the first element\nnums5 = [1, 1, 1, 2, 3]\ntarget5 = 1\nresult5 = sol.searchRange(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: [0, 2])\")</pre> Output Clear <pre></pre> </p>"},{"location":"34/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n</code></pre>"},{"location":"35/","title":"35. Search Insert Position (Easy)","text":""},{"location":"35/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Search Insert Position Examples ---\")\n\n# Test Case 1: Target found\nnums1 = [1, 3, 5, 6]\ntarget1 = 5\nresult1 = sol.searchInsert(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Target not found, insert in middle\nnums2 = [1, 3, 5, 6]\ntarget2 = 2\nresult2 = sol.searchInsert(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 1)\")\n\n# Test Case 3: Target not found, insert at the end\nnums3 = [1, 3, 5, 6]\ntarget3 = 7\nresult3 = sol.searchInsert(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: 4)\")\n\n# Test Case 4: Target not found, insert at the beginning\nnums4 = [1, 3, 5, 6]\ntarget4 = 0\nresult4 = sol.searchInsert(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Empty array\nnums5 = []\ntarget5 = 5\nresult5 = sol.searchInsert(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: 0)\")</pre> Output Clear <pre></pre> </p>"},{"location":"35/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n</code></pre>"},{"location":"36/","title":"36. Valid Sudoku (Medium)","text":""},{"location":"36/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Valid Sudoku Examples ---\")\n\n# Test Case 1: Valid board (Partial fill, but valid structure)\nboard1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult1 = sol.isValidSudoku(board1)\nprint(\"Test 1 (Valid):\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n\n# Test Case 2: Invalid board (Duplicate in a row)\nboard2 = [\n    [\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n] # Row 0 has '8' and row 3 has '8' at col 0, which is fine.\n# Let's create a clear row violation:\nboard2_row_violation = [\n    [\"8\", \"8\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],  # Duplicate '8' in row 0\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult2 = sol.isValidSudoku(board2_row_violation)\nprint(\"\\nTest 2 (Row Violation):\")\nprint(f\"Output: {result2} (Expected: False)\")\n\n\n# Test Case 3: Invalid board (Duplicate in a 3x3 box)\nboard3_box_violation = [\n    [\"5\", \"3\", \".\", \"1\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \"1\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], # Duplicate '1' in box 0 (0,0 to 2,2)\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult3 = sol.isValidSudoku(board3_box_violation)\nprint(\"\\nTest 3 (Box Violation):\")\nprint(f\"Output: {result3} (Expected: False)\")</pre> Output Clear <pre></pre> </p>"},{"location":"36/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n</code></pre>"},{"location":"37/","title":"37. Sudoku Solver (Hard)","text":""},{"location":"37/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n        # 1. Initialize constraint sets\n        # row_constraints[r] is a set of digits present in row r\n        row_constraints = [set() for _ in range(9)]\n        # col_constraints[c] is a set of digits present in column c\n        col_constraints = [set() for _ in range(9)]\n        # box_constraints[b] is a set of digits present in box b (where b is 0-8)\n        # The box index b can be calculated as b = (r // 3) * 3 + (c // 3)\n        box_constraints = [set() for _ in range(9)]\n\n        # 2. Pre-fill the constraints and collect empty cells\n        empty_cells = []\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    row_constraints[r].add(val)\n                    col_constraints[c].add(val)\n                    box_constraints[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        # 3. Optimized validity check (O(1))\n        def is_valid_optimized(r, c, val):\n            box_idx = (r // 3) * 3 + (c // 3)\n            return (val not in row_constraints[r] and\n                    val not in col_constraints[c] and\n                    val not in box_constraints[box_idx])\n\n        # 4. Backtracking with constraint updates\n        def backtrack(k):\n            # Base case: All empty cells have been filled\n            if k == len(empty_cells):\n                return True\n\n            r, c = empty_cells[k]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            # Iterate through possible values '1' to '9'\n            for val_char in \"123456789\":\n                if is_valid_optimized(r, c, val_char):\n\n                    # Place the value and update constraints\n                    board[r][c] = val_char\n                    row_constraints[r].add(val_char)\n                    col_constraints[c].add(val_char)\n                    box_constraints[box_idx].add(val_char)\n\n                    # Recurse to the next empty cell\n                    if backtrack(k + 1):\n                        return True\n\n                    # Backtrack: Reset the cell and constraints\n                    board[r][c] = '.'\n                    row_constraints[r].remove(val_char)\n                    col_constraints[c].remove(val_char)\n                    box_constraints[box_idx].remove(val_char)\n\n            # If no value works for this cell, return False\n            return False\n\n        # Start backtracking from the first empty cell\n        backtrack(0)\n\n# --- Example Usage Code ---\n# (The usage code remains the same, just replace 'Solution' with 'SolutionOptimized')\n\nsol = Solution()\nprint(\"--- Sudoku Solver Examples (Optimized) ---\")\n\n# Test Case 1: Standard Sudoku puzzle\nboard1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\n\nprint(\"Input Board:\")\nfor row in board1:\n    print(row)\n\nsol.solveSudoku(board1)\n\nprint(\"\\nOutput Solved Board (Optimized):\")\nfor row in board1:\n    print(row)</pre> Output Clear <pre></pre> </p>"},{"location":"37/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n        row_constraints = [set() for _ in range(9)]\n        col_constraints = [set() for _ in range(9)]\n        box_constraints = [set() for _ in range(9)]\n\n        empty_cells = []\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    row_constraints[r].add(val)\n                    col_constraints[c].add(val)\n                    box_constraints[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        def is_valid_optimized(r, c, val):\n            box_idx = (r // 3) * 3 + (c // 3)\n            return (val not in row_constraints[r] and\n                    val not in col_constraints[c] and\n                    val not in box_constraints[box_idx])\n\n        def backtrack(k):\n            if k == len(empty_cells):\n                return True\n\n            r, c = empty_cells[k]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            for val_char in \"123456789\":\n                if is_valid_optimized(r, c, val_char):\n\n                    board[r][c] = val_char\n                    row_constraints[r].add(val_char)\n                    col_constraints[c].add(val_char)\n                    box_constraints[box_idx].add(val_char)\n\n                    if backtrack(k + 1):\n                        return True\n\n                    board[r][c] = '.'\n                    row_constraints[r].remove(val_char)\n                    col_constraints[c].remove(val_char)\n                    box_constraints[box_idx].remove(val_char)\n\n            return False\n\n        backtrack(0)\n</code></pre>"},{"location":"38/","title":"38. Count and Say (Easy)","text":""},{"location":"38/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Count and Say Sequence Examples ---\")\n\n# Test Case 1: n = 1\nn1 = 1\nresult1 = sol.countAndSay(n1)\nprint(f\"Input: n={n1}\")\nprint(f\"Output: '{result1}' (Expected: '1')\")\n\n# Test Case 2: n = 4\nn2 = 4\nresult2 = sol.countAndSay(n2)\n# n=1: 1\n# n=2: 11\n# n=3: 21\n# n=4: 1211\nprint(f\"\\nInput: n={n2}\")\nprint(f\"Output: '{result2}' (Expected: '1211')\")\n\n# Test Case 3: n = 5\nn3 = 5\nresult3 = sol.countAndSay(n3)\n# n=5: 111221\nprint(f\"\\nInput: n={n3}\")\nprint(f\"Output: '{result3}' (Expected: '111221')\")\n\n# Test Case 4: n = 6\nn4 = 6\nresult4 = sol.countAndSay(n4)\n# n=6: 312211\nprint(f\"\\nInput: n={n4}\")\nprint(f\"Output: '{result4}' (Expected: '312211')\")</pre> Output Clear <pre></pre> </p>"},{"location":"38/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n</code></pre>"},{"location":"39/","title":"39. Combination Sum (Medium)","text":""},{"location":"39/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Combination Sum Examples ---\")\n\n# Test Case 1: Standard case with reuse\ncandidates1 = [2, 3, 6, 7]\ntarget1 = 7\nresult1 = sol.combinationSum(candidates1, target1)\n# Expected: [[2, 2, 3], [7]]\nprint(f\"Input: candidates={candidates1}, target={target1}\")\nprint(f\"Output: {result1}\")\n\n# Test Case 2: Different candidates, multiple solutions\ncandidates2 = [2, 3, 5]\ntarget2 = 8\nresult2 = sol.combinationSum(candidates2, target2)\n# Expected: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\nprint(f\"\\nInput: candidates={candidates2}, target={target2}\")\nprint(f\"Output: {result2}\")\n\n# Test Case 3: Target unreachable\ncandidates3 = [2, 4]\ntarget3 = 7\nresult3 = sol.combinationSum(candidates3, target3)\n# Expected: []\nprint(f\"\\nInput: candidates={candidates3}, target={target3}\")\nprint(f\"Output: {result3}\")\n\n# Test Case 4: Single candidate\ncandidates4 = [1]\ntarget4 = 5\nresult4 = sol.combinationSum(candidates4, target4)\n# Expected: [[1, 1, 1, 1, 1]]\nprint(f\"\\nInput: candidates={candidates4}, target={target4}\")\nprint(f\"Output: {result4}\")</pre> Output Clear <pre></pre> </p>"},{"location":"39/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"4/","title":"4. Median of Two Sorted Arrays (Hard)","text":""},{"location":"4/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n\n# Example Usage:\nsol = Solution()\nprint(sol.findMedianSortedArrays([1, 3], [2]))       # Output: 2.0\nprint(sol.findMedianSortedArrays([1, 2], [3, 4]))    # Output: 2.5\nprint(sol.findMedianSortedArrays([0, 0], [0, 0]))    # Output: 0.0</pre> Output Clear <pre></pre> </p>"},{"location":"4/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"4/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":""},{"location":"4/#problem-statement-and-efficiency-constraint","title":"Problem Statement and Efficiency Constraint","text":"<p>LeetCode problem 4, \"Median of Two Sorted Arrays,\" presents a significant challenge: given two already sorted arrays, \\(nums1\\) of size \\(m\\) and \\(nums2\\) of size \\(n\\), find the median of the single sorted array that would result from merging both inputs. Crucially, the problem imposes a stringent constraint on the required time complexity, demanding an \\(O(\\log(m+n))\\) solution. This logarithmic complexity immediately rules out simple merging of the arrays (\\(O(m+n)\\)) or any \\(O(n^2)\\) approaches, strongly suggesting the use of a Binary Search technique.</p> <p>The median is defined as the middle element of a sorted list. If the total number of elements \\((m+n)\\) is odd, the median is the single middle element. If the total number of elements is even, the median is the average of the two middle elements. The core difficulty lies in finding this median without explicitly merging the entire arrays.</p>"},{"location":"4/#the-partitioning-principle","title":"The Partitioning Principle","text":"<p>The solution hinges on the concept of partitioning the two arrays. The goal is to find a \"cut\" in \\(nums1\\) and a corresponding \"cut\" in \\(nums2\\) such that two conditions are simultaneously met:</p> <ol> <li>Equal-Sized Halves: The total number of elements in the left partitions (combined) must equal the total number of elements in the right partitions (combined). If the total length \\((m+n)\\) is odd, the left side can have one more element than the right. We aim for \\(\\text{length}(\\text{Left}) = \\lfloor(m+n+1)/2\\rfloor\\).</li> <li>Order Preservation: Every element in the combined left partition must be less than or equal to every element in the combined right partition. That is, \\(\\text{max}(\\text{Left}) \\le \\text{min}(\\text{Right})\\).</li> </ol>"},{"location":"4/#applying-binary-search","title":"Applying Binary Search","text":"<p>To efficiently find these ideal cuts, we apply binary search on the smaller of the two arrays (let's assume \\(nums1\\) is the smaller one, ensuring the search space is minimized, \\(O(\\log(\\min(m, n)))\\)). We search for the optimal partition index, \\(i\\), in \\(nums1\\).</p> <p>The partition index \\(i\\) divides \\(nums1\\) into a left part of size \\(i\\) and a right part of size \\(m-i\\). The corresponding partition index \\(j\\) in \\(nums2\\) is automatically determined by the total required size of the left half: \\(j = \\lfloor(m+n+1)/2\\rfloor - i\\).  This fixed relationship ensures the first condition (equal sizes) is always satisfied.</p>"},{"location":"4/#verification-and-adjustment","title":"Verification and Adjustment","text":"<p>With the cuts defined by \\(i\\) and \\(j\\), we identify the four key boundary elements: \\(\\text{L1} = nums1[i-1]\\), \\(\\text{R1} = nums1[i]\\), \\(\\text{L2} = nums2[j-1]\\), and \\(\\text{R2} = nums2[j]\\). (Edge cases, where \\(i=0, i=m, j=0,\\) or \\(j=n\\), must be handled by assigning \\(L\\) boundary values of \\(-\\infty\\) and \\(R\\) boundary values of \\(+\\infty\\)).</p> <p>The second condition, order preservation, requires that the largest element on the left side is less than or equal to the smallest element on the right side: \\(\\max(\\text{L1}, \\text{L2}) \\le \\min(\\text{R1}, \\text{R2})\\). This breaks down into two separate checks: 1.  \\(\\text{L1} \\le \\text{R2}\\) 2.  \\(\\text{L2} \\le \\text{R1}\\)</p>"},{"location":"4/#determining-the-median","title":"Determining the Median","text":"<p>The binary search loop continues by adjusting the search range for \\(i\\): * If \\(\\text{L1} &gt; \\text{R2}\\) (i.e., \\(nums1\\)'s cut is too far to the right), we move the binary search right boundary for \\(i\\) to \\(i-1\\). * If \\(\\text{L2} &gt; \\text{R1}\\) (i.e., \\(nums1\\)'s cut is too far to the left), we move the binary search left boundary for \\(i\\) to \\(i+1\\).</p> <p>Once the optimal partition is found (when both \\(\\text{L1} \\le \\text{R2}\\) and \\(\\text{L2} \\le \\text{R1}\\) hold), the median can be calculated: * If \\((m+n)\\) is odd: The median is the largest element in the left half, \\(\\text{Median} = \\max(\\text{L1}, \\text{L2})\\). * If \\((m+n)\\) is even: The median is the average of the largest element in the left half and the smallest element in the right half, \\(\\text{Median} = (\\max(\\text{L1}, \\text{L2}) + \\min(\\text{R1}, \\text{R2})) / 2\\). This logarithmic approach successfully meets the strict \\(O(\\log(m+n))\\) time complexity requirement.</p>"},{"location":"40/","title":"40. Combination Sum II (Medium)","text":""},{"location":"40/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Combination Sum II Examples ---\")\n\n# Test Case 1: Duplicates in candidates\ncandidates1 = [10, 1, 2, 7, 6, 1, 5]\ntarget1 = 8\nresult1 = sol.combinationSum2(candidates1, target1)\n# After sorting: [1, 1, 2, 5, 6, 7, 10]\n# Expected: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\nprint(f\"Input: candidates={candidates1}, target={target1}\")\nprint(f\"Output: {result1}\")\n\n# Test Case 2: Duplicates in candidates (Simple case)\ncandidates2 = [2, 5, 2, 1, 2]\ntarget2 = 5\nresult2 = sol.combinationSum2(candidates2, target2)\n# After sorting: [1, 2, 2, 2, 5]\n# Expected: [[1, 2, 2], [5]]\nprint(f\"\\nInput: candidates={candidates2}, target={target2}\")\nprint(f\"Output: {result2}\")\n\n# Test Case 3: No combination found\ncandidates3 = [3, 4]\ntarget3 = 2\nresult3 = sol.combinationSum2(candidates3, target3)\n# Expected: []\nprint(f\"\\nInput: candidates={candidates3}, target={target3}\")\nprint(f\"Output: {result3}\")</pre> Output Clear <pre></pre> </p>"},{"location":"40/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"5/","title":"5. Longest Palindromic Substring (Medium)","text":""},{"location":"5/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n\n# --- Output Examples Code ---\n\nprint(\"--- Longest Palindromic Substring Examples ---\")\n\n# Create an instance of the Solution class\nsol = Solution()\n\n# Test Case 1: Odd length palindrome (bab or aba)\ns1 = \"babad\"\nresult1 = sol.longestPalindrome(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: '{result1}' (Expected: 'bab' or 'aba')\") \n\n# Test Case 2: Even length palindrome\ns2 = \"cbbd\"\nresult2 = sol.longestPalindrome(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: '{result2}' (Expected: 'bb')\")\n\n# Test Case 3: Whole string is a palindrome\ns3 = \"racecar\"\nresult3 = sol.longestPalindrome(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: '{result3}' (Expected: 'racecar')\")\n\n# Test Case 4: Long even length palindrome in the middle\ns4 = \"forgeeksskeegfor\"\nresult4 = sol.longestPalindrome(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: '{result4}' (Expected: 'geeksskeeg')\")\n\n# Test Case 5: Single character string\ns5 = \"x\"\nresult5 = sol.longestPalindrome(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: '{result5}' (Expected: 'x')\")\n\n# Test Case 6: Empty string\ns6 = \"\"\nresult6 = sol.longestPalindrome(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: '{result6}' (Expected: '')\")</pre> Output Clear <pre></pre> </p>"},{"location":"5/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"5/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":""},{"location":"5/#problem-statement-and-core-challenge","title":"Problem Statement and Core Challenge","text":"<p>LeetCode problem 5, \"Longest Palindromic Substring,\" requires finding the longest contiguous substring within a given string \\(s\\) that reads the same forwards and backwards. A string that exhibits this property is called a palindrome. The challenge lies in efficiently identifying this longest palindromic segment among all possible substrings.</p> <p>While the problem seems simple at first glance, the potentially large number of substrings makes a naive approach computationally prohibitive. For a string of length \\(N\\), there are \\(O(N^2)\\) possible substrings. Checking each substring for the palindromic property takes \\(O(N)\\) time, leading to an overall Brute Force complexity of \\(O(N^3)\\). We must seek an optimized solution that can handle input constraints effectively, ideally aiming for \\(O(N^2)\\) time or better.</p>"},{"location":"5/#dynamic-programming-solution-the-formal-approach","title":"Dynamic Programming Solution (The Formal Approach)","text":"<p>One structured way to solve this is using Dynamic Programming (DP), which offers an \\(O(N^2)\\) time complexity. We define a 2D boolean array, \\(\\text{dp}[i][j]\\), where \\(\\text{dp}[i][j]\\) is <code>true</code> if the substring \\(s[i \\dots j]\\) is a palindrome, and <code>false</code> otherwise.</p> <p>The base cases are: 1.  Single-character substrings: \\(\\text{dp}[i][i] = \\text{true}\\). 2.  Two-character substrings: \\(\\text{dp}[i][i+1] = (s[i] == s[i+1])\\).</p> <p>The transition relation is recursive: a substring \\(s[i \\dots j]\\) is a palindrome if and only if two conditions are met: 1. The outer characters match: \\(s[i] == s[j]\\). 2. The inner substring \\(s[i+1 \\dots j-1]\\) is also a palindrome (i.e., \\(\\text{dp}[i+1][j-1]\\) is true). By iterating through substrings of increasing lengths, we can fill the DP table and track the longest palindrome found. [Diagram showing DP transitions for Palindromic Substring] While effective and providing \\(O(N^2)\\) time and \\(O(N^2)\\) space complexity, the approach below is often simpler to implement.</p>"},{"location":"5/#the-expand-around-center-approach-the-practical-on2-solution","title":"The Expand Around Center Approach (The Practical \\(O(N^2)\\) Solution)","text":"<p>A more practical and generally preferred \\(O(N^2)\\) solution is the Expand Around Center technique. This method exploits the symmetry inherent in palindromes: every palindrome is defined by its center. The center can be a single character (for odd-length palindromes like \"racecar\") or the space between two identical characters (for even-length palindromes like \"abba\").</p> <p>This approach avoids the overhead of the DP table by immediately checking for palindromes outward from every potential center. The overall algorithm iterates through every index \\(i\\) in the string \\(s\\), and for each \\(i\\), it performs two independent expansion checks:</p>"},{"location":"5/#center-based-expansion-details","title":"Center-Based Expansion Details","text":"<ol> <li>Odd-Length Palindromes: We treat the single character at index \\(i\\) as the center. We initialize two pointers, \\(L=i\\) and \\(R=i\\). We expand outward, decrementing \\(L\\) and incrementing \\(R\\), as long as \\(L \\ge 0\\), \\(R &lt; N\\), and \\(s[L] == s[R]\\).</li> <li>Even-Length Palindromes: We treat the space between \\(s[i]\\) and \\(s[i+1]\\) as the center (if \\(i+1\\) is a valid index). We initialize \\(L=i\\) and \\(R=i+1\\). We expand outward similarly, decrementing \\(L\\) and incrementing \\(R\\), as long as the boundary and character equality conditions hold. </li> </ol> <p>In both expansion processes, we calculate the length of the current palindrome found \\((R - L - 1)\\) and continuously update a global record tracking the start index and length of the longest palindrome encountered so far. Since we check \\(2N-1\\) possible centers (N single-character centers and N-1 between-character centers), and each expansion takes at most \\(O(N)\\) time, the total time complexity remains \\(O(N^2)\\). However, this method uses only \\(O(1)\\) auxiliary space, making it spatially superior to the standard DP approach.</p>"},{"location":"6/","title":"6. Zigzag Conversion (Medium)","text":""},{"location":"6/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n\nsol = Solution()\nprint(\"--- Zigzag Conversion Examples ---\")\n\n# Test Case 1: Standard Example (numRows=3)\n# P   A   H   N\n# A P L S I I G\n# Y   I   R\ns1 = \"PAYPALISHIRING\"\nnumRows1 = 3\nresult1 = sol.convert(s1, numRows1)\n# Expected: \"PAHNAPLSIIGYIR\"\nprint(f\"Input: s='{s1}', numRows={numRows1}\")\nprint(f\"Output: '{result1}' (Expected: 'PAHNAPLSIIGYIR')\")\n\n# Test Case 2: Example with 4 rows\n# P     I     N\n# A   L S   I G\n# Y A   H R\n# P     I\ns2 = \"PAYPALISHIRING\"\nnumRows2 = 4\nresult2 = sol.convert(s2, numRows2)\n# Expected: \"PINALSIGYAHRPI\"\nprint(f\"Input: s='{s2}', numRows={numRows2}\")\nprint(f\"Output: '{result2}' (Expected: 'PINALSIGYAHRPI')\")\n# \n\n# Test Case 3: Simple 2-row case\ns3 = \"ABCDEFGH\"\nnumRows3 = 2\nresult3 = sol.convert(s3, numRows3)\n# Expected: \"ACEGBDFH\"\nprint(f\"Input: s='{s3}', numRows={numRows3}\")\nprint(f\"Output: '{result3}' (Expected: 'ACEGBDFH')\")\n\n# Test Case 4: numRows = 1 (Edge Case)\ns4 = \"ABCDE\"\nnumRows4 = 1\nresult4 = sol.convert(s4, numRows4)\n# Expected: \"ABCDE\"\nprint(f\"Input: s='{s4}', numRows={numRows4}\")\nprint(f\"Output: '{result4}' (Expected: 'ABCDE')\")\n\n# Test Case 5: numRows &gt;= len(s) (Edge Case)\ns5 = \"ABC\"\nnumRows5 = 5\nresult5 = sol.convert(s5, numRows5)\n# Expected: \"ABC\"\nprint(f\"Input: s='{s5}', numRows={numRows5}\")\nprint(f\"Output: '{result5}' (Expected: 'ABC')\")</pre> Output Clear <pre></pre> </p>"},{"location":"6/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"6/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":""},{"location":"6/#problem-statement-and-visualization","title":"Problem Statement and Visualization","text":"<p>LeetCode problem 6, \"Zigzag Conversion,\" requires converting a given string \\(s\\) into a zigzag pattern across a specified number of rows, \\(numRows\\). After the conversion process, the string is read line by line, from left to right, and the resulting concatenated string must be returned. This is essentially a pattern recognition and string reconstruction problem.</p> <p>Imagine writing the string characters down a series of vertical lines, then diagonally up and to the right, forming a distinctive \"Z\" or \"N\" shape, repeated across the width of the input string. For \\(s=\\) \"PAYPALISHIRING\" and \\(numRows=3\\), the visual pattern looks like this:</p> <p>\"P A H N A P L S I I G Y I R\"</p> <p>When read row by row, the converted string is \"PAHNAPLSIIGYIR\". The core challenge is to derive the mathematical relationship between a character's index in the original string and its row in the final pattern, without needing to physically build a 2D matrix.</p>"},{"location":"6/#the-pattern-cycle-length","title":"The Pattern Cycle Length","text":"<p>The key to an efficient solution is recognizing and utilizing the repetitive nature of the zigzag movement. In the pattern, the characters travel down to the bottom row (\\(0\\) to \\(numRows-1\\)) and then diagonally back up to the top row (\\(numRows-1\\) to \\(1\\)). This movement constitutes a full cycle.</p> <p>The length of one complete cycle, which represents the distance between two characters that fall on the same row in adjacent \"V\" shapes, can be calculated. It includes the \\(numRows\\) characters going down and \\(numRows - 2\\) characters going back up (since the top and bottom rows are shared between cycles). Therefore, the cycle length is \\(\\text{CycleLength} = 2 \\times numRows - 2\\). For example, if \\(numRows=4\\), the cycle length is \\(2 \\times 4 - 2 = 6\\). A character at index \\(i\\) and the next character in the same row will be separated by \\(\\text{CycleLength}\\) distance, or \\(i + \\text{CycleLength}\\). </p>"},{"location":"6/#direct-access-and-row-by-row-construction","title":"Direct Access and Row-by-Row Construction","text":"<p>The most optimal solution uses Direct Access combined with the calculated cycle length. Instead of simulating the movement of pointers, we iterate through the rows, from row \\(0\\) to \\(numRows-1\\), and directly calculate which character indices belong to that specific row. This approach ensures \\(O(n)\\) time complexity, where \\(n\\) is the length of the string, as each character is appended to the result exactly once.</p> <p>The algorithm builds the result string row by row:</p> <ol> <li> <p>First and Last Rows (Row 0 and Row \\(numRows-1\\)): For the top (0) and bottom (\\(numRows-1\\)) rows, characters are spaced exactly by the \\(\\text{CycleLength}\\). The indices belonging to these rows are \\(k \\times \\text{CycleLength}\\), where \\(k\\) is \\(0, 1, 2, \\dots\\). We simply start at the row index and repeatedly add the \\(\\text{CycleLength}\\) until we exceed the string bounds.</p> </li> <li> <p>Intermediate Rows (Row \\(r\\), where \\(0 &lt; r &lt; numRows-1\\)): For any intermediate row \\(r\\), a character appears twice within each cycle:</p> <ul> <li>First Occurrence (Vertical): The character is found at the index \\(i_1 = k \\times \\text{CycleLength} + r\\).</li> <li>Second Occurrence (Diagonal): The character is found at a diagonal position, \\(i_2\\). The distance between \\(i_1\\) and \\(i_2\\) within the cycle is the shorter distance required to complete the diagonal move, which is \\(\\text{CycleLength} - 2r\\). Thus, \\(i_2 = i_1 + (\\text{CycleLength} - 2r)\\).</li> </ul> </li> </ol> <p>We iterate through \\(k = 0, 1, 2, \\dots\\) for each row \\(r\\), calculating both \\(i_1\\) and \\(i_2\\). We append the character at \\(i_1\\) if it is within bounds. Then, we calculate \\(i_2\\) and append its character if \\(i_2\\) is valid (within bounds and not the same index as \\(i_1\\), which only occurs if \\(2r\\) is zero or equal to the cycle length, but we filter this by the intermediate row condition). This systematic, row-based traversal correctly reconstructs the final string in \\(O(n)\\) time.</p>"},{"location":"7/","title":"7. Reverse Integer (Easy)","text":""},{"location":"7/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n\nsol = Solution()\nprint(\"--- Reverse Integer Examples ---\")\n\n# Test Case 1: Positive number\nx1 = 123\nresult1 = sol.reverse(x1)\nprint(f\"Input: {x1}\")\nprint(f\"Output: {result1} (Expected: 321)\")\n\n# Test Case 2: Negative number\nx2 = -123\nresult2 = sol.reverse(x2)\nprint(f\"Input: {x2}\")\nprint(f\"Output: {result2} (Expected: -321)\")\n\n# Test Case 3: Number with trailing zeros\nx3 = 120\nresult3 = sol.reverse(x3)\nprint(f\"Input: {x3}\")\nprint(f\"Output: {result3} (Expected: 21)\")\n\n# Test Case 4: Positive Overflow Check (Max is 2147483647)\n# Reversing 1534236469 gives 9646324351, which exceeds INT_MAX\nx4 = 1534236469 \nresult4 = sol.reverse(x4)\nprint(f\"Input: {x4}\")\nprint(f\"Output: {result4} (Expected: 0 - Overflow)\")\n\n# Test Case 5: Negative Overflow Check (Min is -2147483648)\n# Reversing -1534236469 gives -9646324351, which is less than INT_MIN\nx5 = -1534236469\nresult5 = sol.reverse(x5)\nprint(f\"Input: {x5}\")\nprint(f\"Output: {result5} (Expected: 0 - Overflow)\")\n\n# Test Case 6: Exact INT_MAX reversal (No Overflow)\n# Reversing 1463847412 (214748364 * 10 + 7) -&gt; 2147483641\nx6 = 1463847412 # Just a large number whose reverse is safe\nresult6 = sol.reverse(x6)\nprint(f\"Input: {x6}\")\nprint(f\"Output: {result6} (Expected: 2147483641)\")</pre> Output Clear <pre></pre> </p>"},{"location":"7/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"7/#7-reverse-integer","title":"7. Reverse Integer","text":""},{"location":"7/#problem-statement-and-the-integer-limit-constraint","title":"Problem Statement and The Integer Limit Constraint","text":"<p>LeetCode problem 7, \"Reverse Integer,\" asks us to take a given signed 32-bit integer \\(x\\) and return its digits in reverse order. The primary complication in this problem, beyond the mechanical reversal of digits, is handling the constraints imposed by the 32-bit signed integer range.</p> <p>A signed 32-bit integer can only hold values from a minimum of \\(-2^{31}\\) (\\(-2,147,483,648\\)) to a maximum of \\(2^{31}-1\\) (\\(2,147,483,647\\)). If the act of reversing the digits causes the resulting number to exceed this range (either overflowing the maximum or underflowing the minimum), the function is required to return 0. This necessity of preemptive overflow checking makes the problem non-trivial, as simple data type operations might lead to undefined behavior or incorrect values in many programming environments before the check can even be performed.</p>"},{"location":"7/#iterative-reversal-mechanism","title":"Iterative Reversal Mechanism","text":"<p>The digit reversal is achieved through a standard iterative process using arithmetic operations, avoiding string conversion for efficiency. We maintain a variable, let's call it <code>reversed_result</code>, initialized to 0. We then enter a loop that continues as long as the input \\(x\\) is not zero.</p> <p>In each iteration, we perform two steps: 1.  Extract the Last Digit: The last digit of \\(x\\) is isolated using the modulo operator: \\(\\text{digit} = x \\pmod{10}\\). 2.  Update the Reversed Result: The <code>reversed_result</code> is updated by shifting its current digits one position to the left (multiplying by 10) and then appending the new \\(\\text{digit}\\): \\(\\text{reversed\\_result} = \\text{reversed\\_result} \\times 10 + \\text{digit}\\). 3.  Truncate \\(x\\): The last digit is removed from \\(x\\) using integer division: \\(x = x / 10\\).</p> <p>This process effectively peels off the digits of \\(x\\) from right to left and reconstructs them into <code>reversed_result</code> from left to right.</p>"},{"location":"7/#the-critical-overflow-detection-logic","title":"The Critical Overflow Detection Logic","text":"<p>The most critical part of the solution is detecting potential overflow before it actually occurs in the calculation \\(\\text{reversed\\_result} \\times 10 + \\text{digit}\\). We must check the state of \\(\\text{reversed\\_result}\\) before the multiplication by 10. Let \\(\\text{INT\\_MAX} = 2,147,483,647\\) and \\(\\text{INT\\_MIN} = -2,147,483,648\\).</p> <p>We can categorize the overflow checks into three distinct scenarios for the positive case: 1.  Guaranteed Overflow (Positive): If \\(\\text{reversed\\_result}\\) is already greater than \\(\\text{INT\\_MAX} / 10\\) (which is \\(214,748,364\\)), then multiplying by 10 will definitely exceed \\(\\text{INT\\_MAX}\\). 2.  Edge Case Check (Positive): If \\(\\text{reversed\\_result}\\) is equal to \\(\\text{INT\\_MAX} / 10\\) (\\(214,748,364\\)), the overflow depends entirely on the next digit. Since \\(\\text{INT\\_MAX} \\pmod{10} = 7\\), an overflow occurs if the extracted \\(\\text{digit}\\) is greater than 7.</p>"},{"location":"7/#handling-negative-and-returning-zero","title":"Handling Negative and Returning Zero","text":"<p>A symmetrical set of checks must be performed for the negative integer range, using \\(\\text{INT\\_MIN}\\): 1.  Guaranteed Underflow (Negative): If \\(\\text{reversed\\_result}\\) is already less than \\(\\text{INT\\_MIN} / 10\\) (which is \\(-214,748,364\\)), then multiplying by 10 will definitely be less than \\(\\text{INT\\_MIN}\\). 2.  Edge Case Check (Negative): If \\(\\text{reversed\\_result}\\) is equal to \\(\\text{INT\\_MIN} / 10\\) (\\(-214,748,364\\)), the underflow depends on the next digit. Since \\(\\text{INT\\_MIN} \\pmod{10}\\) is \\(-8\\) (or \\(-7\\) depending on language specific signed division rules, but for \\(-2^{31}\\) it is 8), an underflow occurs if the extracted \\(\\text{digit}\\) is less than \\(-8\\) (or greater than 8 in magnitude). The safe check is simply if \\(\\text{reversed\\_result} &lt; \\text{INT\\_MIN} / 10\\) or \\((\\text{reversed\\_result} == \\text{INT\\_MIN} / 10 \\text{ and } \\text{digit} &lt; -8)\\).</p> <p>If any of these overflow/underflow conditions are met during the loop, the algorithm immediately terminates and returns 0, fulfilling the problem's requirement. If the loop completes without triggering any overflow, the final \\(\\text{reversed\\_result}\\) is returned. This approach maintains an \\(O(\\log_{10}|x|)\\) time complexity, which is proportional to the number of digits in \\(x\\).</p>"},{"location":"8/","title":"8. String to Integer (atoi) (Medium)","text":""},{"location":"8/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- String to Integer (atoi) Examples ---\")\n\n# Test Case 1: Standard positive conversion\ns1 = \"42\"\nresult1 = sol.myAtoi(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 42)\")\n\n# Test Case 2: Conversion with leading whitespace and sign\ns2 = \"   -42\"\nresult2 = sol.myAtoi(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: -42)\")\n\n# Test Case 3: Conversion with non-digit characters after the number\ns3 = \"4193 with words\"\nresult3 = sol.myAtoi(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 4193)\")\n\n# Test Case 4: No valid number found\ns4 = \"words and 987\"\nresult4 = sol.myAtoi(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Positive Overflow (Should return INT_MAX: 2147483647)\ns5 = \"91283472332\"\nresult5 = sol.myAtoi(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 2147483647)\")\n\n# Test Case 6: Negative Overflow (Should return INT_MIN: -2147483648)\ns6 = \"-91283472332\"\nresult6 = sol.myAtoi(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: -2147483648)\")\n\n# Test Case 7: Only sign\ns7 = \"+\"\nresult7 = sol.myAtoi(s7)\nprint(f\"Input: '{s7}'\")\nprint(f\"Output: {result7} (Expected: 0)\")\n\n# Test Case 8: Exact positive boundary\ns8 = \"2147483647\"\nresult8 = sol.myAtoi(s8)\nprint(f\"Input: '{s8}'\")\nprint(f\"Output: {result8} (Expected: 2147483647)\")\n\n# Test Case 9: Exact negative boundary\ns9 = \"-2147483648\"\nresult9 = sol.myAtoi(s9)\nprint(f\"Input: '{s9}'\")\nprint(f\"Output: {result9} (Expected: -2147483648)\")</pre> Output Clear <pre></pre> </p>"},{"location":"8/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"8/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":""},{"location":"8/#problem-statement-and-ambiguity-of-parsing","title":"Problem Statement and Ambiguity of Parsing","text":"<p>LeetCode problem 8, \"String to Integer (atoi),\" asks for the implementation of the \\(myAtoi(string s)\\) function, which converts a string into a 32-bit signed integer, mirroring the behavior of the C/C++ <code>atoi</code> function. This seemingly simple task is complicated by several strict parsing rules and edge cases that must be handled sequentially and correctly. The process is not a single conversion but a series of state transitions.</p> <p>The core difficulty lies in managing the strict sequence of parsing steps: first, ignoring leading whitespace; second, identifying and processing the optional sign; third, accumulating valid digits; and finally, handling potential overflow or underflow against the 32-bit integer limits. Any character encountered that does not fit the current expected state (e.g., a letter after a digit) must immediately terminate the parsing process, regardless of how many digits were successfully processed beforehand.</p>"},{"location":"8/#step-1-discarding-leading-whitespace","title":"Step 1: Discarding Leading Whitespace","text":"<p>The conversion process must begin by reading and discarding any leading whitespace characters (' ') until the first non-whitespace character is found. This stage requires a simple loop that increments an index past all spaces. If the entire string consists only of spaces, the result is 0.</p> <p>Once a non-whitespace character is hit, the algorithm must transition immediately to the next stage. It is crucial to remember that whitespace is only permissible at the very start of the string. Any space encountered after the sign or after the first digit is considered an invalid character and terminates parsing.</p>"},{"location":"8/#step-2-handling-the-optional-sign","title":"Step 2: Handling the Optional Sign","text":"<p>After skipping initial whitespace, the next character must be evaluated to determine the sign of the number. The sign is optional. If the character is a plus sign ('+'), the number is positive. If it is a minus sign ('-'), the number is negative. If the character is neither a '+' nor a '-' (and is a digit), the number is implicitly positive.</p> <p>A sign multiplier variable (e.g., <code>sign</code>, initialized to 1) is set to 1 or -1 accordingly. If a sign character is found, the index is advanced to the next character. A critical rule here is that if any character other than a '+' or '-' appears immediately after the whitespace, the parsing must jump straight to Step 3 (reading digits). If two signs, or a sign followed by a non-digit, or the end of the string is encountered, the conversion stops, and 0 is returned.</p>"},{"location":"8/#step-3-reading-and-accumulating-digits","title":"Step 3: Reading and Accumulating Digits","text":"<p>This is the core numerical processing stage. We iterate through the string starting from the character following the sign (or the first non-whitespace character). The loop continues only as long as the current character is a valid digit ('0' through '9').</p> <p>In each iteration, the character is converted into its numerical value, \\(\\text{digit}\\). The running result, \\(\\text{result}\\), is updated by multiplying the current result by 10 and adding the new digit: \\(\\text{result} = \\text{result} \\times 10 + \\text{digit}\\). [Diagram illustrating State Transitions for atoi] The first non-digit character encountered will immediately stop this accumulation phase.</p>"},{"location":"8/#step-4-overflow-and-underflow-clamping","title":"Step 4: Overflow and Underflow Clamping","text":"<p>The most challenging aspect, similar to the Reverse Integer problem, is the requirement to prevent and handle numerical overflow or underflow. The result must fit within the 32-bit signed integer range, which is \\(\\text{INT\\_MIN} = -2^{31}\\) and \\(\\text{INT\\_MAX} = 2^{31}-1\\).</p> <p>The overflow check must be performed inside the digit accumulation loop, before the multiplication and addition, to ensure that the intermediate calculation does not exceed the limits. If the current positive \\(\\text{result}\\) is already greater than \\(\\text{INT\\_MAX} / 10\\), or if it is equal to \\(\\text{INT\\_MAX} / 10\\) and the new \\(\\text{digit}\\) is greater than 7, then the final result would overflow. Symmetrical checks apply to the negative result against \\(\\text{INT\\_MIN}\\). If an overflow or underflow condition is met at any point, the algorithm must immediately stop and clamp the final value to \\(\\text{INT\\_MAX}\\) or \\(\\text{INT\\_MIN}\\) before returning. This careful sequence of state-dependent parsing and boundary checks ensures compliance with all \\(myAtoi\\) rules.</p>"},{"location":"9/","title":"9. Palindrome Number (Easy)","text":""},{"location":"9/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Palindrome Number Examples ---\")\n\n# Test Case 1: Standard Palindrome (Odd number of digits)\nx1 = 121\nresult1 = sol.isPalindrome(x1)\nprint(f\"Input: {x1}\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n# Test Case 2: Standard Palindrome (Even number of digits)\nx2 = 1221\nresult2 = sol.isPalindrome(x2)\nprint(f\"Input: {x2}\")\nprint(f\"Output: {result2} (Expected: True)\")\n\n# Test Case 3: Not a Palindrome\nx3 = 10\nresult3 = sol.isPalindrome(x3)\nprint(f\"Input: {x3}\")\nprint(f\"Output: {result3} (Expected: False - Fails condition 2)\")\n\n# Test Case 4: Not a Palindrome (Mismatch)\nx4 = 123\nresult4 = sol.isPalindrome(x4)\nprint(f\"Input: {x4}\")\nprint(f\"Output: {result4} (Expected: False)\")\n\n# Test Case 5: Negative Number (Fails condition 1)\nx5 = -121\nresult5 = sol.isPalindrome(x5)\nprint(f\"Input: {x5}\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Zero (Palindrome)\nx6 = 0\nresult6 = sol.isPalindrome(x6)\nprint(f\"Input: {x6}\")\nprint(f\"Output: {result6} (Expected: True)\")</pre> Output Clear <pre></pre> </p>"},{"location":"9/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"},{"location":"9/#9-palindrome-number","title":"9. Palindrome Number","text":""},{"location":"9/#problem-statement-and-constraints","title":"Problem Statement and Constraints","text":"<p>LeetCode problem 9, \"Palindrome Number,\" asks for a determination of whether a given integer \\(x\\) is a palindrome. An integer is defined as a palindrome if it reads the same forwards and backwards. For instance, 121 is a palindrome, but 123 is not. The primary constraint on the solution is the requirement to solve the problem without converting the integer to a string. This mandates an approach using only mathematical operations, such as modulo and division.</p> <p>Initial checks reveal immediate non-palindromes: all negative numbers are non-palindromes because the minus sign only appears at the beginning (e.g., \\(-121\\) reads \\(121-\\) backward). Additionally, any positive number that ends in 0 (other than 0 itself, which is a palindrome) cannot be a palindrome, as the leading digit of the reversed number would be 0, which is invalid for an integer representation (e.g., \\(120\\) reverses to \\(021\\)). If \\(x\\) is negative or ends in 0 (and is not 0), we can immediately return <code>false</code>.</p>"},{"location":"9/#the-brute-force-reversal-pitfall","title":"The Brute Force Reversal Pitfall","text":"<p>A straightforward approach would be to fully reverse the entire integer \\(x\\) and then compare the reversed value with the original \\(x\\). While this method works for most integers, it suffers from the same vulnerability as the \"Reverse Integer\" problem (LeetCode 7): integer overflow. If the original number \\(x\\) is large, reversing it could cause the resulting number to exceed the maximum value allowed by the integer data type (\\(\\text{INT\\_MAX}\\)).</p> <p>Since the problem requires a robust solution, we must devise a method that avoids the potential for overflow entirely. Reversing the number and then performing the comparison, while simple to code, is mathematically risky without dedicated overflow handling, which complicates the logic unnecessarily when a safer method exists.</p>"},{"location":"9/#the-optimized-half-reversal-approach","title":"The Optimized Half-Reversal Approach","text":"<p>The most elegant and efficient solution involves reversing only the second half of the number. If a number is a palindrome, its second half, when reversed, must be identical to its first half. This technique avoids the risk of overflow because we are only building a reversed number that is at most half the length of the original.</p> <p>We use a loop to iteratively build a <code>reversed_half</code> variable. The loop continues as long as the original number \\(x\\) is greater than <code>reversed_half</code>. In each iteration: 1.  We extract the last digit of \\(x\\) using \\(\\text{digit} = x \\pmod{10}\\). 2.  We append this digit to <code>reversed_half</code>: \\(\\text{reversed\\_half} = \\text{reversed\\_half} \\times 10 + \\text{digit}\\). 3.  We remove the last digit from \\(x\\): \\(x = x / 10\\).</p> <p>This process effectively transfers the digits from the tail of \\(x\\) to the head of <code>reversed\\_half</code> until \\(x\\) is no longer greater than <code>reversed\\_half</code>, signifying that we have processed at least half the digits.</p>"},{"location":"9/#final-comparison-and-edge-case-handling","title":"Final Comparison and Edge Case Handling","text":"<p>When the loop terminates, we compare the remaining portion of \\(x\\) with the constructed <code>reversed_half</code>. Two distinct scenarios are possible, depending on the length of the original number:</p> <ol> <li>Even Number of Digits: If the original number had an even number of digits (e.g., 1221), the loop stops when \\(x\\) and <code>reversed_half</code> have the same value (i.e., \\(x = 12\\) and \\(\\text{reversed\\_half} = 12\\)). The palindrome check is simply \\(x == \\text{reversed\\_half}\\).</li> <li>Odd Number of Digits: If the original number had an odd number of digits (e.g., 121), the loop stops when the middle digit has been transferred to \\(\\text{reversed\\_half}\\) (i.e., \\(x = 1\\) and \\(\\text{reversed\\_half} = 12\\)). The middle digit of an odd-length palindrome is irrelevant to the comparison. To align the values, we remove the middle digit from <code>reversed_half</code> via integer division: \\(\\text{reversed\\_half} / 10\\). The palindrome check is \\(x == \\text{reversed\\_half} / 10\\).</li> </ol> <p>By combining these two checks with a logical OR operation, we can cover all valid cases: \\(x == \\text{reversed\\_half}\\) OR \\(x == \\text{reversed\\_half} / 10\\). This half-reversal strategy ensures an optimal \\(O(\\log_{10} x)\\) time complexity, which is proportional to the number of digits, and maintains \\(O(1)\\) space complexity without risking integer overflow.</p>"},{"location":"pyodide/","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>\n# Leetcode 2 Verbose\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n            print(f\"(new_digit) {new_digit}: (total_sum) {total_sum} = (Val1) {val1} + (Val2) {val2} + (carry) {carry}\")\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n\n# Helper function to convert a list of digits to a linked list (in reverse order)\ndef create_linked_list(digits):\n    dummy_head = ListNode(0)\n    current = dummy_head\n    for digit in digits:\n        current.next = ListNode(digit)\n        current = current.next\n    return dummy_head.next\n\n# Helper function to convert a linked list to a list of digits\ndef linked_list_to_list(node):\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\n\n# Example 1: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) -&gt; (7 -&gt; 0 -&gt; 8)\nl1_ex1 = create_linked_list([2, 4, 3])\nl2_ex1 = create_linked_list([5, 6, 4])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex1, l2_ex1)), \"\\n\")\n\n# Example 2: (0) + (0) -&gt; (0)\nl1_ex2 = create_linked_list([0])\nl2_ex2 = create_linked_list([0])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex2, l2_ex2)), \"\\n\")\n\n# Example 3: (9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9) + (9 -&gt; 9 -&gt; 9 -&gt; 9) -&gt; (8 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 1)\nl1_ex3 = create_linked_list([9, 9, 9, 9, 9, 9, 9])\nl2_ex3 = create_linked_list([9, 9, 9, 9])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex3, l2_ex3)))\n</pre> Output Clear <pre></pre> </p>"}]}