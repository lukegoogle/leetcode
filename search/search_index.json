{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeetCode Python","text":"<p>This repository holds my Python solutions for various LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment.</p> <p>Luke Clark</p> <p>Contact at me lukeclarksf@gmail.com</p>"},{"location":"1/","title":"Problem 1","text":"<pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n\nif __name__ == '__main__':\n    s = Solution()\n    print(s.twoSum([2,7,11,15], 9)) # Expected: [0, 1]\n</code></pre> <p>Of course! Here is the Markdown for LeetCode problem 2, \"Add Two Numbers,\" including the problem description, examples, and a common solution approach.</p>"},{"location":"1/#2-add-two-numbers-medium-problem-descriptionyou-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-the-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contains-a-single-digit-add-the-two-numbers-and-return-the-sum-as-a-linked-list-also-in-reverse-order","title":"\ud83d\udd17 2. Add Two Numbers (Medium)###\u2753 Problem DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list (also in reverse order).","text":"<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>"},{"location":"1/#examples-example-input-output-explanation","title":"\ud83d\udcdd Examples| Example | Input | Output | Explanation |","text":"<p>| --- | --- | --- | --- | | 1 | <code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code> | <code>[7,0,8]</code> | 342 + 465 = 807 | | 2 | <code>l1 = [0]</code>, <code>l2 = [0]</code> | <code>[0]</code> | 0 + 0 = 0 | | 3 | <code>l1 = [9,9,9,9,9,9,9]</code>, <code>l2 = [9,9,9,9]</code> | <code>[8,9,9,9,0,0,0,1]</code> | 9,999,999 + 9,999 = 10,009,998 |</p>"},{"location":"1/#approach-simulation-of-grade-school-additionthe-problem-is-essentially-asking-you-to-perform-long-addition-but-since-the-digits-are-already-in-reverse-order-least-significant-digit-first-we-can-iterate-through-both-lists-simultaneously-from-head-to-tail","title":"\ud83d\udca1 Approach: Simulation of Grade-School AdditionThe problem is essentially asking you to perform long addition, but since the digits are already in reverse order (least significant digit first), we can iterate through both lists simultaneously from head to tail.","text":"<p>We use a carry variable to track the overflow when the sum of two digits and the previous carry is 10 or greater, just like in manual addition.</p>"},{"location":"1/#steps1-initialize","title":"Steps:1. Initialize:","text":"<ul> <li>Create a dummy node to serve as the starting point of the result list.</li> <li>Initialize a pointer <code>current</code> to the dummy node.</li> <li> <p>Initialize <code>carry</code> to 0.</p> </li> <li> <p>Iterate: Continue the loop as long as either of the input lists (<code>l1</code> or <code>l2</code>) has nodes, or if there is a remaining <code>carry</code>.</p> </li> <li>Get Values: In each iteration, get the value of the current nodes in <code>l1</code> and <code>l2</code> (or 0 if a list has been exhausted).</li> <li>x = l1.val if l1 is not null, else 0.</li> <li> <p>y = l2.val if l2 is not null, else 0.</p> </li> <li> <p>Calculate Sum: Compute the total sum for the current position:</p> </li> <li> <p>sum = x + y + carry.</p> </li> <li> <p>Update Carry and Digit:</p> </li> <li>The new <code>carry</code> is the quotient: carry = sum / 10 (integer division).</li> <li> <p>The new digit for the result list is the remainder: digit = sum \\% 10.</p> </li> <li> <p>Build Result List:</p> </li> <li>Create a new <code>ListNode</code> with the calculated digit.</li> <li>Append this new node to <code>current.next</code>.</li> <li> <p>Move the <code>current</code> pointer forward to the new node.</p> </li> <li> <p>Advance Pointers: Move l1 and l2 to their next nodes, if they exist.</p> </li> <li>Return: The result list starts at the node following the dummy node: <code>dummy.next</code>.</li> </ul>"},{"location":"1/#python-solution-iterativepython","title":"\ud83d\udcbb Python Solution (Iterative)```python","text":""},{"location":"1/#definition-for-singly-linked-list","title":"Definition for singly-linked list.","text":"<p>class ListNode:     def init(self, val=0, next=None):         self.val = val         self.next = next</p> <p>class Solution:     def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:         # Create a dummy node for the head of the result list         dummy = ListNode(0)         current = dummy         carry = 0</p> <pre><code>    # Loop until both lists are traversed AND there is no remaining carry\n    while l1 is not None or l2 is not None or carry != 0:\n        # Get the values of the current nodes (or 0 if the list is finished)\n        x = l1.val if l1 is not None else 0\n        y = l2.val if l2 is not None else 0\n\n        # Calculate the sum\n        sum_val = x + y + carry\n\n        # Update carry for the next iteration\n        carry = sum_val // 10\n\n        # Create a new node with the current digit (sum % 10)\n        current.next = ListNode(sum_val % 10)\n\n        # Advance the current pointer\n        current = current.next\n\n        # Move input list pointers forward\n        if l1 is not None:\n            l1 = l1.next\n        if l2 is not None:\n            l2 = l2.next\n\n    # The result is the next node after the dummy head\n    return dummy.next\n</code></pre> <p>```</p>"},{"location":"1/#complexity-analysis-time-complexity-omaxn-m","title":"\ud83d\udcca Complexity Analysis Time Complexity: O(max(N, M))*","text":"<ul> <li> <p>Where N and M are the lengths of the two linked lists. We iterate through both lists at most once.</p> </li> <li> <p>Space Complexity: O(max(N, M))</p> </li> <li>The new linked list created to store the sum will have a maximum length of \\max(N, M) + 1 (in case of a final carry).</li> </ul> <p>What else would you like to know about this problem, or would you like to see the solution in another language like Java or C++?</p>"},{"location":"2/","title":"Problem 2","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"3/","title":"Problem 3","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"4/","title":"Problem 4","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"}]}