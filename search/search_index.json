{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python","text":"<p>You will find my Python solutions for LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment. LeetCode includes Data Structures and Algorithms to practice. Solve LeetCode problems very efficiently.</p> <p>Browse source code in the left sidebar or visit GitHub. Run your code with Pyodide. Verify problems directly on LeetCode. Static site generation is done with Make Docs.</p> <p>Luke Clark</p> <p>Send me an email at lukeclarksf@gmail.com. See my Resume.</p> Learn Data Structures and Algorithms <p>Read function source code and documentation.<p> Submit to LeetCode <p>Submit problems easily directly to LeetCode.<p>"},{"location":"1/","title":"1. Two Sum (Easy)","text":""},{"location":"1/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"1/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n\n#if __name__ == \"__main__\":\nprint(Solution().twoSum([0,1,2,3,4,5],2))</pre> Output Clear <pre></pre> </p>"},{"location":"1/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#function-description","title":"Function Description","text":"Source code in <code>python/_1.py</code> <pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        \"\"\"\n        Finds two unique numbers in the input list that sum up to a specific target \n        value and returns the 0-based indices of those two numbers. The function \n        uses a hash map to achieve a time complexity of $O(n)$ by storing each \n        number and its index as it iterates through the list, then checking if \n        the required complement (target - current number) already exists in the map.\n\n        Args:\n            nums: A list of integers where exactly one valid solution exists.\n            target: The target integer sum.\n\n        Returns:\n            A list containing the indices of the two numbers that sum up to the target, \n            e.g., [index1, index2].\n        \"\"\"\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#_1.Solution.twoSum","title":"<code>twoSum(nums, target)</code>","text":"<p>Finds two unique numbers in the input list that sum up to a specific target  value and returns the 0-based indices of those two numbers. The function  uses a hash map to achieve a time complexity of \\(O(n)\\) by storing each  number and its index as it iterates through the list, then checking if  the required complement (target - current number) already exists in the map.</p> <p>Parameters:</p> Name Type Description Default <code>nums</code> <code>list[int]</code> <p>A list of integers where exactly one valid solution exists.</p> required <code>target</code> <code>int</code> <p>The target integer sum.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A list containing the indices of the two numbers that sum up to the target, </p> <code>list[int]</code> <p>e.g., [index1, index2].</p> Source code in <code>python/_1.py</code> <pre><code>def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"\n    Finds two unique numbers in the input list that sum up to a specific target \n    value and returns the 0-based indices of those two numbers. The function \n    uses a hash map to achieve a time complexity of $O(n)$ by storing each \n    number and its index as it iterates through the list, then checking if \n    the required complement (target - current number) already exists in the map.\n\n    Args:\n        nums: A list of integers where exactly one valid solution exists.\n        target: The target integer sum.\n\n    Returns:\n        A list containing the indices of the two numbers that sum up to the target, \n        e.g., [index1, index2].\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n</code></pre>"},{"location":"1/#explanation","title":"Explanation","text":"<p>The \"Two Sum\" problem is universally recognized as the introductory problem in algorithmic interviews and a foundational concept for understanding time complexity trade-offs. The requirement is straightforward: given an array of integers, <code>nums</code>, and a specific target integer, identify and return the indices of the two numbers within the array that sum up exactly to the target. The problem is generally constrained by the guarantee that exactly one valid solution exists, and the same element cannot be used twice.</p> <p>A simple, though professionally unacceptable, solution involves a brute-force approach using nested loops. The outer loop iterates over each element \\(nums[i]\\), and the inner loop checks every subsequent element \\(nums[j]\\) to see if \\(nums[i] + nums[j]\\) equals the target. While correct, this method results in a quadratic time complexity of \\(O(n^2)\\). This inefficiency means the execution time increases dramatically as the input array size grows, failing to meet the performance standards required in production systems.</p> <p>The definitive, industry-standard solution achieves linear time complexity, \\(O(n)\\), by utilizing a hash map (or dictionary). This method performs a single pass through the array. For each number \\(nums[i]\\), the algorithm calculates the complement needed to reach the target (\\(complement = target - nums[i]\\)). Before inserting the current element into the hash map, the algorithm checks if the required \\(complement\\) already exists as a key in the map.  If the complement is found, the current index \\(i\\) and the index stored in the map (which belongs to the complement) are returned. If not found, the number \\(nums[i]\\) and its index \\(i\\) are added to the map. This leverages the \\(O(1)\\) average-time complexity of hash map lookups to ensure maximum efficiency.</p>"},{"location":"1/#_1","title":"1. Two Sum (Easy)","text":""},{"location":"1/#_2","title":"1. Two Sum (Easy)","text":""},{"location":"10/","title":"10. Regular Expression Matching (Hard)","text":""},{"location":"10/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"10/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Regular Expression Matching Examples ---\")\n# \n\n# Test Case 1: Simple mismatch\ns1 = \"aa\"\np1 = \"a\"\nresult1 = sol.isMatch(s1, p1)\nprint(f\"Input: s='{s1}', p='{p1}'\")\nprint(f\"Output: {result1} (Expected: False)\")\n\n# Test Case 2: Simple * match (one or more 'a')\ns2 = \"aa\"\np2 = \"a*\"\nresult2 = sol.isMatch(s2, p2)\nprint(f\"Input: s='{s2}', p='{p2}'\")\nprint(f\"Output: {result2} (Expected: True)\")\n\n# Test Case 3: Zero * match (zero 'a')\ns3 = \"ab\"\np3 = \".*\"\nresult3 = sol.isMatch(s3, p3)\nprint(f\"Input: s='{s3}', p='{p3}'\")\nprint(f\"Output: {result3} (Expected: True)\")\n\n# Test Case 4: Multiple characters and *\ns4 = \"aab\"\np4 = \"c*a*b\"\nresult4 = sol.isMatch(s4, p4)\nprint(f\"Input: s='{s4}', p='{p4}'\")\nprint(f\"Output: {result4} (Expected: True) (c* matches zero c's, a* matches two a's)\")\n\n# Test Case 5: Complex match with '.' and '*'\ns5 = \"mississippi\"\np5 = \"mis*is*p*.\"\nresult5 = sol.isMatch(s5, p5)\nprint(f\"Input: s='{s5}', p='{p5}'\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Edge Case (Pattern starts with '.*')\ns6 = \"abcd\"\np6 = \".*d\"\nresult6 = sol.isMatch(s6, p6)\nprint(f\"Input: s='{s6}', p='{p6}'\")\nprint(f\"Output: {result6} (Expected: True)\")</pre> Output Clear <pre></pre> </p>"},{"location":"10/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"10/#function-description","title":"Function Description","text":"Source code in <code>python/_10.py</code> <pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"10/#_10.Solution.isMatch","title":"<code>isMatch(s, p)</code>","text":"Source code in <code>python/_10.py</code> <pre><code>def isMatch(self, s: str, p: str) -&gt; bool:\n\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2]\n\n                if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n    return dp[m][n]\n</code></pre>"},{"location":"10/#explanation","title":"Explanation","text":"<p>The problem asks you to implement a regular expression matching algorithm that supports two special characters: <code>.</code> (dot) and <code>*</code> (asterisk). The dot <code>.</code> matches any single character. The asterisk <code>*</code> matches zero or more occurrences of the preceding element. The matching must cover the entire input string \\(s\\) (not partial). You are given an input string \\(s\\) and a pattern \\(p\\). This problem is classified as Hard due to the complex state management required by the <code>*</code> operator.</p> <p>The two main approaches to solving this problem are Recursion with Memoization (Top-Down Dynamic Programming) and Tabulation (Bottom-Up Dynamic Programming). The recursive approach checks if the current character in \\(s\\) matches the current element in \\(p\\). If the next element in \\(p\\) is <code>*</code>, this introduces two possibilities: either the <code>*</code> matches zero occurrences of the preceding element (so we move past both the element and <code>*</code> in \\(p\\)), or it matches one or more occurrences (so we stay at the <code>*</code> and move to the next character in \\(s\\)). Memoization is crucial to avoid re-calculating the same subproblems, which would otherwise lead to exponential time complexity.</p> <p>The preferred \\(O(m \\times n)\\) solution is the Bottom-Up Dynamic Programming approach, where \\(m\\) is the length of \\(s\\) and \\(n\\) is the length of \\(p\\). A 2D boolean array, \\(DP[i][j]\\), is used to store whether the substring \\(s[0...i-1]\\) matches the pattern \\(p[0...j-1]\\). The base cases involve empty strings. The recursive relations are built upon checking the current character match and the two conditions for the <code>*</code> operator. The final answer is found at \\(DP[m][n]\\). This approach systematically builds the solution from the smallest subproblems.</p>"},{"location":"10/#_1","title":"10. Regular Expression Matching (Hard)","text":""},{"location":"10/#_2","title":"10. Regular Expression Matching (Hard)","text":""},{"location":"11/","title":"11. Container With Most Water (Medium)","text":""},{"location":"11/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"11/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Container With Most Water Examples ---\")\n\n# Test Case 1: Standard Example\n# The maximum area is 49, formed by the lines of height 8 and 7, which are 7 units apart.\nh1 = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nresult1 = sol.maxArea(h1)\nprint(f\"Input: {h1}\")\nprint(f\"Output: {result1} (Expected: 49)\")\n\n# Test Case 2: Simple Example\nh2 = [1, 1]\nresult2 = sol.maxArea(h2)\nprint(f\"Input: {h2}\")\nprint(f\"Output: {result2} (Expected: 1)\")\n\n# Test Case 3: Decreasing heights\n# Max area is formed by the first and last line: min(5, 1) * 4 = 4\nh3 = [5, 4, 3, 2, 1]\nresult3 = sol.maxArea(h3)\nprint(f\"Input: {h3}\")\nprint(f\"Output: {result3} (Expected: 4)\")\n\n# Test Case 4: Increasing heights\n# Max area is formed by the first and last line: min(1, 5) * 4 = 4\nh4 = [1, 2, 3, 4, 5]\nresult4 = sol.maxArea(h4)\nprint(f\"Input: {h4}\")\nprint(f\"Output: {result4} (Expected: 4)\")\n\n# Test Case 5: Large example with max area far from edges\nh5 = [2, 3, 4, 5, 18, 17, 6]\n# Max area is min(18, 17) * 1 = 17 OR min(5, 6) * 3 = 15. The true max is likely from 18 and 17.\nresult5 = sol.maxArea(h5)\nprint(f\"Input: {h5}\")\nprint(f\"Output: {result5} (Expected: 17)\")</pre> Output Clear <pre></pre> </p>"},{"location":"11/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n</code></pre>"},{"location":"11/#function-description","title":"Function Description","text":"Source code in <code>python/_11.py</code> <pre><code>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n</code></pre>"},{"location":"11/#_11.Solution.maxArea","title":"<code>maxArea(height)</code>","text":"Source code in <code>python/_11.py</code> <pre><code>def maxArea(self, height: list[int]) -&gt; int:\n    max_area = 0\n    left = 0\n    right = len(height) - 1\n\n    while left &lt; right:\n        current_height = min(height[left], height[right])\n        current_width = right - left\n        current_area = current_height * current_width\n        max_area = max(max_area, current_area)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return max_area\n</code></pre>"},{"location":"11/#11-container-with-most-water","title":"11. Container With Most Water","text":""},{"location":"11/#problem-statement-and-geometrical-interpretation","title":"Problem Statement and Geometrical Interpretation","text":"<p>LeetCode problem 11, \"Container With Most Water,\" is a geometrical optimization problem. We are given an array of \\(n\\) non-negative integers, say \\(\\text{heights}\\), where each element \\(\\text{heights}[i]\\) represents the height of a vertical line drawn at coordinate \\((i, \\text{heights}[i])\\). The goal is to find two of these lines that, together with the x-axis, form a container capable of holding the maximum amount of water.</p> <p>The container formed by two lines at indices \\(L\\) and \\(R\\) (where \\(L &lt; R\\)) has a height determined by the shorter of the two lines, \\(\\min(\\text{heights}[L], \\text{heights}[R])\\). The width of the container is the distance between the lines, \\((R - L)\\). The area, which corresponds to the amount of water the container can hold, is calculated as: \\(\\text{Area} = \\text{width} \\times \\text{height} = (R - L) \\times \\min(\\text{heights}[L], \\text{heights}[R])\\). The challenge is to maximize this area by optimally choosing the indices \\(L\\) and \\(R\\).</p>"},{"location":"11/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>A straightforward, yet inefficient, approach is to use Brute Force by checking the area generated by every possible pair of lines. This involves nested loops: the outer loop iterates with index \\(L\\) from 0 to \\(n-2\\), and the inner loop iterates with index \\(R\\) from \\(L+1\\) to \\(n-1\\).</p> <p>In each iteration, the area is calculated, and the maximum area found so far is tracked. Since every pair is examined, the Brute Force solution yields an \\(O(n^2)\\) time complexity. While this works, it is too slow for large arrays and fails to meet the implicit requirement for an optimal solution. An \\(O(n)\\) solution is required for efficient execution.</p>"},{"location":"11/#the-optimized-two-pointer-approach","title":"The Optimized Two-Pointer Approach","text":"<p>The necessary optimization comes from recognizing a crucial pattern and applying the Two-Pointer technique. This approach starts by considering the container formed by the two lines that are farthest apart\u2014the leftmost line (\\(L=0\\)) and the rightmost line (\\(R=n-1\\)). This gives the maximum possible width.</p> <p>After calculating the area for the current \\((L, R)\\) pair, the strategy is to determine which pointer to move inward to potentially find a larger area. Moving a pointer always results in a decrease in width, \\((R - L)\\). Therefore, to compensate for the reduced width, the move must aim to find a line with a greater height.</p>"},{"location":"11/#the-governing-movement-logic","title":"The Governing Movement Logic","text":"<p>The critical decision lies in identifying which of the two pointers, \\(L\\) or \\(R\\), has a shorter line. Since the height of the current container is limited by \\(\\min(\\text{heights}[L], \\text{heights}[R])\\), increasing the height of the container can only be achieved by replacing the shorter of the two boundary lines with a potentially taller line. </p> <ol> <li> <p>If \\(\\text{heights}[L] &lt; \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[L]\\). Any container involving \\(\\text{heights}[L]\\) and a line to its right (say, \\(R' &lt; R\\)) will have a width less than \\((R - L)\\) and a height limited by \\(\\min(\\text{heights}[L], \\text{heights}[R'])\\). Because \\(R'\\) is to the left of \\(R\\), \\(\\text{heights}[R]\\) is irrelevant. Thus, moving \\(R\\) inward would only decrease the width, and the height would still be restricted by the relatively short \\(\\text{heights}[L]\\) or an even shorter height. Moving \\(L\\) inward (\\(\\text{increment } L\\)) is the only logical move, as it offers the possibility of finding a taller line that can increase the container's height, offsetting the loss of width.</p> </li> <li> <p>If \\(\\text{heights}[L] \\ge \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[R]\\). By the same logic, we must move the right pointer inward (\\(\\text{decrement } R\\)) to search for a potentially taller line at the right boundary.</p> </li> </ol> <p>The loop continues until the two pointers meet (\\(L &lt; R\\)). Since \\(L\\) and \\(R\\) traverse the array only once, and each iteration moves at least one pointer, the total time complexity is strictly \\(O(n)\\), making it a highly efficient solution.</p>"},{"location":"12/","title":"12. Integer to Roman (Medium)","text":""},{"location":"12/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"12/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Integer to Roman Examples ---\")\n\n# Test Case 1: Simple addition\nnum1 = 3\nresult1 = sol.intToRoman(num1)\nprint(f\"Input: {num1}\")\nprint(f\"Output: '{result1}' (Expected: 'III')\")\n\n# Test Case 2: Subtractive notation (IV)\nnum2 = 4\nresult2 = sol.intToRoman(num2)\nprint(f\"Input: {num2}\")\nprint(f\"Output: '{result2}' (Expected: 'IV')\")\n\n# Test Case 3: Mixed addition and subtraction\nnum3 = 58\n# 50 (L) + 5 (V) + 3 (III)\nresult3 = sol.intToRoman(num3)\nprint(f\"Input: {num3}\")\nprint(f\"Output: '{result3}' (Expected: 'LVIII')\")\n\n# Test Case 4: Complex number using multiple subtractive rules\nnum4 = 1994\n# 1000 (M) + 900 (CM) + 90 (XC) + 4 (IV)\nresult4 = sol.intToRoman(num4)\nprint(f\"Input: {num4}\")\nprint(f\"Output: '{result4}' (Expected: 'MCMXCIV')\")\n\n# Test Case 5: Maximum allowed input (3999)\nnum5 = 3999\n# 3000 (MMM) + 900 (CM) + 90 (XC) + 9 (IX)\nresult5 = sol.intToRoman(num5)\nprint(f\"Input: {num5}\")\nprint(f\"Output: '{result5}' (Expected: 'MMMCMXCIX')\")</pre> Output Clear <pre></pre> </p>"},{"location":"12/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n</code></pre>"},{"location":"12/#function-description","title":"Function Description","text":"Source code in <code>python/_12.py</code> <pre><code>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n</code></pre>"},{"location":"12/#_12.Solution.intToRoman","title":"<code>intToRoman(num)</code>","text":"Source code in <code>python/_12.py</code> <pre><code>def intToRoman(self, num: int) -&gt; str:\n\n    mappings = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n        (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n        (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n\n    result = []\n\n    for value, symbol in mappings:\n        if num == 0:\n            break\n\n        count, num = divmod(num, value)\n\n        result.append(symbol * count)\n\n    return \"\".join(result)\n</code></pre>"},{"location":"12/#12-integer-to-roman","title":"12. Integer to Roman","text":""},{"location":"12/#problem-statement-and-roman-numeral-system-basics","title":"Problem Statement and Roman Numeral System Basics","text":"<p>LeetCode problem 12, \"Integer to Roman,\" requires converting a given integer into its Roman numeral representation. The input is guaranteed to be within the standard range of Roman numeral representation, specifically from 1 to 3999 (inclusive). This constraint ensures that we do not need to deal with very large numbers requiring bars over the letters or other advanced Roman numeral notation.</p> <p>The Roman numeral system is based on seven symbols, each representing a specific value: \\(I=1, V=5, X=10, L=50, C=100, D=500, M=1000\\). The system uses additive notation (e.g., \\(VI = 5+1 = 6\\)) but also incorporates a crucial subtractive notation rule for four and nine units of magnitude. These subtractive pairs are: \\(IV=4, IX=9\\) (for tens), \\(XL=40, XC=90\\) (for hundreds), and \\(CD=400, CM=900\\) (for thousands). The solution must adhere to the standard convention of always choosing the largest possible symbol or subtractive combination at each place value.</p>"},{"location":"12/#the-greedy-approach-with-ordered-mappings","title":"The Greedy Approach with Ordered Mappings","text":"<p>Since the Roman numeral system has fixed values and the largest symbol is always preferred, this problem is perfectly suited for a Greedy Algorithm. A greedy approach makes the locally optimal choice at each step, and because the Roman numeral system is well-behaved in this range (e.g., you would never use two 'V's instead of one 'X'), this local optimum leads directly to the global optimum.</p> <p>The implementation involves defining two synchronized arrays (or a map of pairs) that store the values and their corresponding Roman symbols, ordered from largest value to smallest. This ordering is crucial because it includes the subtractive pairs (\\(900, 400, 90, 40, 9, 4\\)) which must be checked before their simpler, larger components (\\(1000, 500, 100, 50, 10, 5\\)). [Table showing Roman Numeral Mappings]</p>"},{"location":"12/#iteration-and-conversion-logic","title":"Iteration and Conversion Logic","text":"<p>We iterate through the ordered list of value-symbol pairs. For each pair \\((\\text{value}, \\text{symbol})\\), we check if the remaining input number, \\(num\\), is greater than or equal to \\(\\text{value}\\).</p> <p>If \\(num \\ge \\text{value}\\), it means the current symbol or combination is the largest possible representation that can be used at this stage. We apply the greedy choice: we append the \\(\\text{symbol}\\) to our result string and simultaneously subtract the \\(\\text{value}\\) from \\(num\\). We repeat this process with the same pair until \\(num\\) drops below \\(\\text{value}\\). This ensures that repeated symbols are correctly handled (e.g., \\(3000\\) requires three 'M's).</p>"},{"location":"12/#example-of-greedy-selection","title":"Example of Greedy Selection","text":"<p>Consider converting the number 1994. The algorithm proceeds as follows: 1.  Check 1000 (\\(M\\)): \\(1994 \\ge 1000\\). Result becomes \"M\", \\(num\\) becomes 994. 2.  Check 900 (\\(CM\\)): \\(994 \\ge 900\\). Result becomes \"MCM\", \\(num\\) becomes 94. 3.  Check 500 (\\(D\\)): \\(94 &lt; 500\\). Skip. 4.  ... 5.  Check 90 (\\(XC\\)): \\(94 \\ge 90\\). Result becomes \"MCMXC\", \\(num\\) becomes 4. 6.  Check 50 (\\(L\\)): \\(4 &lt; 50\\). Skip. 7.  Check 4 (\\(IV\\)): \\(4 \\ge 4\\). Result becomes \"MCMXCIV\", \\(num\\) becomes 0.</p> <p>The process stops when \\(num\\) reaches 0. Because the number of symbols in the mapping is a small constant (13 pairs), the number of iterations required is very small and does not depend on the magnitude of the input integer \\(num\\) but rather on the number of fixed place values. Therefore, the time complexity is effectively \\(O(1)\\) (constant time) due to the fixed constraint of the input range (1 to 3999).</p>"},{"location":"13/","title":"13. Roman to Integer (Easy)","text":""},{"location":"13/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"13/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Roman to Integer Examples ---\")\n\n# Test Case 1: Simple addition\ns1 = \"III\"\nresult1 = sol.romanToInt(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 3)\")\n\n# Test Case 2: Subtractive notation (IV = 5 - 1 = 4)\ns2 = \"IV\"\nresult2 = sol.romanToInt(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: 4)\")\n\n# Test Case 3: Subtractive notation (IX = 10 - 1 = 9)\ns3 = \"IX\"\nresult3 = sol.romanToInt(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 9)\")\n\n# Test Case 4: Mixed addition and subtraction\ns4 = \"LVIII\"\n# L (50) + V (5) + I (1) + I (1) + I (1) = 58\nresult4 = sol.romanToInt(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 58)\")\n\n# Test Case 5: Complex number using multiple subtractive rules\ns5 = \"MCMXCIV\"\n# M (1000) + CM (900) + XC (90) + IV (4) = 1994\nresult5 = sol.romanToInt(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 1994)\")\n\n# Test Case 6: Maximum number\ns6 = \"MMMCMXCIX\"\n# 3999\nresult6 = sol.romanToInt(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: 3999)\")</pre> Output Clear <pre></pre> </p>"},{"location":"13/#solution","title":"Solution","text":"<p><pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n</code></pre> </p>"},{"location":"13/#function-description","title":"Function Description","text":"Source code in <code>python/_13.py</code> <pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n</code></pre>"},{"location":"13/#_13.Solution.romanToInt","title":"<code>romanToInt(s)</code>","text":"Source code in <code>python/_13.py</code> <pre><code>def romanToInt(self, s: str) -&gt; int:\n\n    value_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n\n    total = 0\n    prev_value = 0\n\n    for char in reversed(s):\n        current_value = value_map[char]\n\n        if current_value &lt; prev_value:\n            total -= current_value\n        else:\n            total += current_value\n\n        prev_value = current_value\n\n    return total\n</code></pre>"},{"location":"13/#13-roman-to-integer","title":"13. Roman to Integer","text":""},{"location":"13/#problem-statement-and-the-subtraction-rule-challenge","title":"Problem Statement and The Subtraction Rule Challenge","text":"<p>LeetCode problem 13, \"Roman to Integer,\" involves converting a given Roman numeral string, \\(s\\), into its corresponding integer value. The input is guaranteed to be a valid Roman numeral within the standard range of 1 to 3999. Unlike converting from an integer to a Roman numeral (which relies on a greedy build-up), converting to an integer requires a careful sequential interpretation of the Roman characters.</p> <p>The main complexity arises from the subtractive notation. Normally, symbols are additive (e.g., \\(VI = 5 + 1 = 6\\)). However, a smaller value symbol placed before a larger value symbol indicates subtraction (e.g., \\(IV = 5 - 1 = 4\\), \\(CM = 1000 - 100 = 900\\)). The algorithm must correctly identify these subtractive pairs and adjust the running total accordingly, which cannot be done by simply summing the values of the individual characters from left to right.</p>"},{"location":"13/#mapping-and-initialization","title":"Mapping and Initialization","text":"<p>The solution begins by establishing a map or dictionary to store the integer value for each of the seven Roman symbols (\\(I, V, X, L, C, D, M\\)). [Table showing Roman Numeral Mappings] The conversion process must then handle the string \\(s\\) by processing it sequentially. A variable, often called <code>total</code> or <code>result</code>, is initialized to 0 to accumulate the final integer value.</p> <p>The most robust approach involves iterating through the Roman numeral string from left to right, comparing the value of the current symbol with the value of the next symbol. This lookahead comparison is the key mechanism for identifying the subtractive rule.</p>"},{"location":"13/#the-lookahead-comparison-logic","title":"The Lookahead Comparison Logic","text":"<p>We iterate through the string using an index \\(i\\) from the beginning up to the second-to-last character. In each step, we retrieve the value of the current symbol, \\(\\text{current\\_val} = \\text{map}[s[i]]\\), and the value of the next symbol, \\(\\text{next\\_val} = \\text{map}[s[i+1]]\\).</p> <ol> <li>Subtractive Case: If \\(\\text{current\\_val} &lt; \\text{next\\_val}\\) (e.g., \\(I\\) followed by \\(V\\) in \\(IV\\)), this signals a subtractive pair. The correct way to handle this is to subtract the current value from the running <code>total</code>. This is because the \\(\\text{current\\_val}\\) is not being added normally but is being used to subtract from the subsequent, larger value.</li> <li>Additive Case: If \\(\\text{current\\_val} \\ge \\text{next\\_val}\\) (e.g., \\(V\\) followed by \\(I\\) in \\(VI\\), or two identical symbols like \\(X\\) followed by \\(X\\)), the current value is purely additive. We add \\(\\text{current\\_val}\\) to the running <code>total</code>.</li> </ol>"},{"location":"13/#finalizing-the-conversion","title":"Finalizing the Conversion","text":"<p>After the loop completes, the last character of the Roman numeral string (at index \\(n-1\\)) will not have been processed, as the loop only goes up to \\(n-2\\) to allow for the \\(i+1\\) lookahead. The last symbol can never be part of a subtractive pair (as there is no symbol following it), so its value is always additive.</p> <p>Therefore, the final step is to retrieve the value of the last character, \\(\\text{map}[s[n-1]]\\), and add it to the accumulated <code>total</code>. This approach correctly handles all symbols and the subtractive rule, resulting in the correct integer. Since the algorithm requires only a single pass through the string, the time complexity is linear, \\(O(n)\\), where \\(n\\) is the length of the Roman numeral string. Given the input constraint of 1 to 3999, \\(n\\) is at most 15, so the time complexity is very fast in practice.</p>"},{"location":"14/","title":"14. Longest Common Prefix (Easy)","text":""},{"location":"14/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"14/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Longest Common Prefix Examples ---\")\n\n# Test Case 1: Standard common prefix\nstrs1 = [\"flower\", \"flow\", \"flight\"]\nresult1 = sol.longestCommonPrefix(strs1)\nprint(f\"Input: {strs1}\")\nprint(f\"Output: '{result1}' (Expected: 'fl')\")\n\n# Test Case 2: No common prefix\nstrs2 = [\"dog\", \"racecar\", \"car\"]\nresult2 = sol.longestCommonPrefix(strs2)\nprint(f\"Input: {strs2}\")\nprint(f\"Output: '{result2}' (Expected: '')\")\n\n# Test Case 3: Common prefix is the full word\nstrs3 = [\"apple\", \"app\", \"apricot\"]\nresult3 = sol.longestCommonPrefix(strs3)\nprint(f\"Input: {strs3}\")\nprint(f\"Output: '{result3}' (Expected: 'ap')\")\n\n# Test Case 4: Empty input list\nstrs4 = []\nresult4 = sol.longestCommonPrefix(strs4)\nprint(f\"Input: {strs4}\")\nprint(f\"Output: '{result4}' (Expected: '')\")\n\n# Test Case 5: List with one string\nstrs5 = [\"solo\"]\nresult5 = sol.longestCommonPrefix(strs5)\nprint(f\"Input: {strs5}\")\nprint(f\"Output: '{result5}' (Expected: 'solo')\")\n\n# Test Case 6: Vertically aligned mismatch\nstrs6 = [\"ab\", \"a\"]\nresult6 = sol.longestCommonPrefix(strs6)\nprint(f\"Input: {strs6}\")\nprint(f\"Output: '{result6}' (Expected: 'a')\")</pre> Output Clear <pre></pre> </p>"},{"location":"14/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n</code></pre>"},{"location":"14/#function-description","title":"Function Description","text":"Source code in <code>python/_14.py</code> <pre><code>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n</code></pre>"},{"location":"14/#_14.Solution.longestCommonPrefix","title":"<code>longestCommonPrefix(strs)</code>","text":"Source code in <code>python/_14.py</code> <pre><code>def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n\n    for i in range(1, len(strs)):\n        current_string = strs[i]\n\n        while current_string.find(prefix) != 0:\n            prefix = prefix[:-1]\n\n            if not prefix:\n                return \"\"\n\n    return prefix\n</code></pre>"},{"location":"14/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":""},{"location":"14/#problem-statement-and-core-objective","title":"Problem Statement and Core Objective","text":"<p>LeetCode problem 14, \"Longest Common Prefix,\" is a fundamental string processing task. Given an array of strings, \\(\\text{strs}\\), the objective is to find the longest string that is a prefix of all strings within the array. If no common prefix exists among the strings (i.e., they all start with different characters), the function must return an empty string, \"\".</p> <p>This problem highlights the need for efficient comparison across multiple string inputs. The resulting Longest Common Prefix (LCP) must adhere strictly to the definition of a prefix, meaning it must be a contiguous substring starting at the beginning of each string. For example, in the array [\"flower\", \"flow\", \"flight\"], the LCP is \"fl\".</p>"},{"location":"14/#the-brute-force-and-vertical-scanning-approaches","title":"The Brute Force and Vertical Scanning Approaches","text":"<p>A brute force approach might involve checking every possible prefix of the shortest string against all other strings. This involves unnecessary repetition. A slightly more refined, but still potentially inefficient, method is Vertical Scanning. This method iterates through the characters of the strings from left to right, column by column.</p> <p>For index \\(j=0, 1, 2, \\dots\\), we check if the character at position \\(j\\) in the first string, \\(\\text{strs}[0][j]\\), is the same as the character at position \\(j\\) in all subsequent strings, \\(\\text{strs}[i][j]\\). If we find a mismatch at any string or if we reach the end of any string, the common prefix is the substring of \\(\\text{strs}[0]\\) up to index \\(j-1\\). While easier than Brute Force, Vertical Scanning can be slow if the array contains many long strings with a very long LCP, as it performs many redundant character comparisons. The worst-case time complexity is \\(O(S)\\), where \\(S\\) is the sum of the lengths of all strings, as in the scenario where all strings are identical.</p>"},{"location":"14/#the-optimized-horizontal-scanning-technique","title":"The Optimized Horizontal Scanning Technique","text":"<p>The most intuitive and often simplest efficient method is Horizontal Scanning. This approach works by incrementally refining a candidate LCP string by comparing it sequentially with every string in the input array.</p> <p>We start by assuming the first string in the array, \\(\\text{strs}[0]\\), is the initial LCP candidate. We then iterate through the rest of the strings, from \\(\\text{strs}[1]\\) to \\(\\text{strs}[n-1]\\). For each string \\(\\text{strs}[i]\\), we update the LCP to be the common prefix between the current LCP and \\(\\text{strs}[i]\\). [Diagram illustrating Horizontal Scanning for LCP]</p>"},{"location":"14/#details-of-the-lcp-refinement","title":"Details of the LCP Refinement","text":"<p>The refinement step for a string \\(\\text{strs}[i]\\) and the current LCP is performed using a simple check. We ask: \"Does \\(\\text{strs}[i]\\) start with the current LCP?\" In many programming languages, this is done with a function like <code>indexOf(LCP) == 0</code>.</p> <p>If \\(\\text{strs}[i]\\) does not start with the current LCP, it means the LCP is too long. We must shorten the current LCP by removing its last character (\\(\\text{LCP} = \\text{LCP}[:-1]\\)). We repeatedly shorten the LCP until \\(\\text{strs}[i]\\) does start with the truncated LCP, or until the LCP becomes empty. If the LCP becomes an empty string, we can immediately terminate the entire process and return \"\" because no subsequent string can possibly share a prefix with all previous strings. Once \\(\\text{strs}[i]\\)'s prefix is matched, we move on to the next string in the array with the new, refined LCP. Upon completing the iteration through all strings, the final remaining LCP is the correct answer. The worst-case time complexity for Horizontal Scanning is also \\(O(S)\\), but it often performs better in practice when the LCP is short.</p>"},{"location":"14/#other-advanced-approaches-trie-and-divide-and-conquer","title":"Other Advanced Approaches (Trie and Divide and Conquer)","text":"<p>More advanced solutions exist, such as using a Trie (Prefix Tree) or a Divide and Conquer approach. * Trie: By inserting all strings into a Trie, the LCP is represented by the longest path from the root that has only one child node (since it must be common to all strings). This method is optimal in terms of comparisons but adds \\(O(S)\\) overhead for building the Trie. * Divide and Conquer: This recursive approach divides the array of strings into two halves, finds the LCP of each half, and then finds the LCP of those two results. This has the same \\(O(S)\\) time complexity but is often less efficient due to recursion overhead compared to the simple iterative Horizontal Scanning.</p>"},{"location":"15/","title":"15. 3Sum (Medium)","text":""},{"location":"15/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"15/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 3Sum Examples ---\")\n\n# Test Case 1: Standard example with duplicates\nnums1 = [-1, 0, 1, 2, -1, 4]\nresult1 = sol.threeSum(nums1)\n# Expected output (after sorting): [[-1, -1, 2], [-1, 0, 1]]\nprint(f\"Input: {nums1}\")\nprint(f\"Output: {result1} (Expected: [[-1, -1, 2], [-1, 0, 1]])\")\n\n# Test Case 2: No solution\nnums2 = [0, 1, 1]\nresult2 = sol.threeSum(nums2)\nprint(f\"Input: {nums2}\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Only zeros\nnums3 = [0, 0, 0]\nresult3 = sol.threeSum(nums3)\nprint(f\"Input: {nums3}\")\nprint(f\"Output: {result3} (Expected: [[0, 0, 0]])\")\n\n# Test Case 4: Longer array with various numbers and duplicates\nnums4 = [-2, 0, 1, 1, 2]\nresult4 = sol.threeSum(nums4)\n# Expected output: [[-2, 0, 2], [-2, 1, 1]]\nprint(f\"Input: {nums4}\")\nprint(f\"Output: {result4} (Expected: [[-2, 0, 2], [-2, 1, 1]])\")\n\n# Test Case 5: Array that breaks early (Optimization 1)\nnums5 = [1, 2, 3]\nresult5 = sol.threeSum(nums5)\nprint(f\"Input: {nums5}\")\nprint(f\"Output: {result5} (Expected: [])\")</pre> Output Clear <pre></pre> </p>"},{"location":"15/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n</code></pre>"},{"location":"15/#function-description","title":"Function Description","text":"Source code in <code>python/_15.py</code> <pre><code>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n</code></pre>"},{"location":"15/#_15.Solution.threeSum","title":"<code>threeSum(nums)</code>","text":"Source code in <code>python/_15.py</code> <pre><code>def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if nums[i] &gt; 0:\n            break\n\n        if i &gt; 0 and nums[i] == nums[i-1]:\n            continue\n\n        target = -nums[i]\n        L = i + 1\n        R = n - 1\n\n        while L &lt; R:\n            current_sum = nums[L] + nums[R]\n\n            if current_sum == target:\n                result.append([nums[i], nums[L], nums[R]])\n\n                while L &lt; R and nums[L] == nums[L+1]:\n                    L += 1\n                while L &lt; R and nums[R] == nums[R-1]:\n                    R -= 1\n\n                L += 1\n                R -= 1\n\n            elif current_sum &lt; target:\n                L += 1\n\n            else:\n                R -= 1\n\n    return result\n</code></pre>"},{"location":"15/#15-3sum","title":"15. 3Sum","text":""},{"location":"15/#problem-statement-and-the-uniqueness-constraint","title":"Problem Statement and The Uniqueness Constraint","text":"<p>LeetCode problem 15, \"3Sum,\" asks us to find all unique triplets \\([a, b, c]\\) within a given array of \\(n\\) integers, \\(nums\\), such that their sum is zero: \\(a + b + c = 0\\). This problem is an extension of the classic Two Sum problem but adds significant complexity due to the requirement of finding three numbers and, most importantly, ensuring that the resulting set of triplets contains no duplicates.</p> <p>A brute force approach would involve three nested loops, checking every combination of three distinct indices \\((i, j, k)\\). This would result in an \\(O(n^3)\\) time complexity, which is far too slow for practical purposes, necessitating a more optimized technique. The primary optimization must come from fixing one number and then efficiently searching for the remaining two, while also managing the uniqueness requirement.</p>"},{"location":"15/#optimal-approach-sorting-and-two-pointers","title":"Optimal Approach: Sorting and Two Pointers","text":"<p>The most efficient and standard solution leverages a combination of two powerful techniques: Sorting and the Two-Pointer method.</p> <ol> <li> <p>Sorting: First, the input array \\(nums\\) must be sorted in \\(O(n \\log n)\\) time. Sorting is indispensable for two reasons:</p> <ul> <li>It allows us to easily skip duplicates during iteration.</li> <li>It enables the Two-Pointer technique to efficiently search for the remaining two numbers in \\(O(n)\\) time.</li> </ul> </li> <li> <p>Fixing the First Number: After sorting, we iterate through the array with a primary pointer \\(i\\). The value \\(nums[i]\\) is fixed as our first number, \\(a\\). Since we need \\(a + b + c = 0\\), the remaining two numbers, \\(b\\) and \\(c\\), must satisfy \\(b + c = -nums[i]\\). We treat \\(-nums[i]\\) as the new \"target sum\" for the remaining subarray.</p> </li> </ol>"},{"location":"15/#the-inner-two-pointer-search","title":"The Inner Two-Pointer Search","text":"<p>For each fixed \\(a = nums[i]\\), we use the two-pointer approach on the remainder of the array, starting from index \\(i+1\\). We initialize a left pointer \\(L\\) at \\(i+1\\) and a right pointer \\(R\\) at the end of the array (\\(n-1\\)). The goal is to find pairs \\((nums[L], nums[R])\\) that sum to the target \\(-nums[i]\\).</p> <p>The pointers \\(L\\) and \\(R\\) move towards each other, shrinking the search space: 1.  Case 1: Sum is Too Small: If \\(nums[L] + nums[R] &lt; -nums[i]\\), the sum needs to be larger. Since the array is sorted, we achieve a larger sum by moving \\(L\\) one step to the right (\\(\\text{increment } L\\)). 2.  Case 2: Sum is Too Large: If \\(nums[L] + nums[R] &gt; -nums[i]\\), the sum needs to be smaller. We achieve a smaller sum by moving \\(R\\) one step to the left (\\(\\text{decrement } R\\)). 3.  Case 3: Match Found: If \\(nums[L] + nums[R] = -nums[i]\\), a valid triplet \\([nums[i], nums[L], nums[R]]\\) has been found. This triplet is added to the result list.</p>"},{"location":"15/#duplicate-elimination-logic","title":"Duplicate Elimination Logic","text":"<p>The problem requires finding unique triplets, which necessitates careful handling of duplicates in both the outer loop (for \\(a\\)) and the inner two-pointer movement (for \\(b\\) and \\(c\\)).</p> <ol> <li> <p>Outer Loop Duplicates (for \\(a\\)): We must ensure that we don't process the same value for \\(a\\) multiple times consecutively. Before starting the inner two-pointer search, we check: if \\(i &gt; 0\\) and \\(nums[i] == nums[i-1]\\), we skip the current iteration using a <code>continue</code> statement. This prevents identical triplets from being generated due to using the same value for \\(a\\).</p> </li> <li> <p>Inner Loop Duplicates (for \\(b\\) and \\(c\\)): After finding a valid triplet (Case 3), we immediately move \\(L\\) and \\(R\\) inward, but we must also skip duplicates that follow \\(L\\) and precede \\(R\\). We advance \\(L\\) forward while \\(L &lt; R\\) and \\(nums[L] == nums[L+1]\\), and we retreat \\(R\\) backward while \\(L &lt; R\\) and \\(nums[R] == nums[R-1]\\). Only after skipping all duplicates do we perform the final move: \\(\\text{increment } L\\) and \\(\\text{decrement } R\\).</p> </li> </ol> <p>By incorporating the initial \\(O(n \\log n)\\) sort with the subsequent \\(O(n^2)\\) search (the outer loop is \\(O(n)\\) and the inner two-pointer loop is \\(O(n)\\)), the total time complexity is dominated by the search, resulting in an optimal \\(O(n^2)\\) time complexity for the entire solution.</p>"},{"location":"16/","title":"16. 3Sum Closest (Medium)","text":""},{"location":"16/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"16/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 3Sum Closest Examples ---\")\n\n# Test Case 1: Standard example\nnums1 = [-1, 2, 1, -4]\ntarget1 = 1\nresult1 = sol.threeSumClosest(nums1, target1)\n# Expected: 2 (since -1 + 2 + 1 = 2)\nprint(f\"Input: nums={nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Target is 0\nnums2 = [0, 0, 0]\ntarget2 = 1\nresult2 = sol.threeSumClosest(nums2, target2)\n# Expected: 0\nprint(f\"Input: nums={nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 0)\")\n\n# Test Case 3: Negative numbers and target\nnums3 = [1, 1, 1, 0]\ntarget3 = -100\nresult3 = sol.threeSumClosest(nums3, target3)\n# Expected: 2 (1 + 1 + 0 = 2, the closest sum possible)\nprint(f\"Input: nums={nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: 2)\")\n\n# Test Case 4: Target is reached exactly\nnums4 = [1, 2, 3, 4, 5]\ntarget4 = 7\nresult4 = sol.threeSumClosest(nums4, target4)\n# Expected: 7 (2 + 1 + 4 = 7, or 3 + 2 + 2 = 7 etc.)\nprint(f\"Input: nums={nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 7)\")</pre> Output Clear <pre></pre> </p>"},{"location":"16/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n</code></pre>"},{"location":"16/#function-description","title":"Function Description","text":"Source code in <code>python/_16.py</code> <pre><code>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n</code></pre>"},{"location":"16/#_16.Solution.threeSumClosest","title":"<code>threeSumClosest(nums, target)</code>","text":"Source code in <code>python/_16.py</code> <pre><code>def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n    nums.sort()\n    n = len(nums)\n    closest_sum = nums[0] + nums[1] + nums[2]\n\n    for i in range(n - 2):\n        L = i + 1\n        R = n - 1\n\n        while L &lt; R:\n            current_sum = nums[i] + nums[L] + nums[R]\n\n            if abs(current_sum - target) &lt; abs(closest_sum - target):\n                closest_sum = current_sum\n\n            if current_sum &lt; target:\n                L += 1\n            elif current_sum &gt; target:\n                R -= 1\n            else:\n                return current_sum\n\n    return closest_sum\n</code></pre>"},{"location":"16/#16-3sum-closest","title":"16. 3Sum Closest","text":""},{"location":"16/#problem-statement-and-target-definition","title":"Problem Statement and Target Definition","text":"<p>LeetCode problem 16, \"3Sum Closest,\" is a variation of the classic 3Sum problem (LeetCode 15). Given an array of \\(n\\) integers, \\(nums\\), and a specific integer target, the objective is to find three integers in \\(nums\\) such that their sum is the closest possible value to the target. It is generally guaranteed that there will be exactly one solution, simplifying the task of choosing between sums that are equally close.</p> <p>The core challenge is not to find a sum equal to the target, but to minimize the absolute difference between the triplet sum and the target: \\(\\min(|(\\text{nums}[i] + \\text{nums}[j] + \\text{nums}[k]) - \\text{target}|)\\). Similar to the 3Sum problem, a brute force approach of checking all \\(O(n^3)\\) combinations is prohibitively slow, demanding an optimized \\(O(n^2)\\) solution.</p>"},{"location":"16/#optimal-approach-sorting-and-two-pointers","title":"Optimal Approach: Sorting and Two Pointers","text":"<p>The most efficient solution strategy mirrors that of the 3Sum problem, relying on Sorting followed by the Two-Pointer technique.</p> <ol> <li> <p>Sorting: The input array \\(nums\\) is sorted first in \\(O(n \\log n)\\) time. Sorting is crucial because it allows us to efficiently control the magnitude of the three-number sum. By knowing the array is sorted, we can predict whether moving our pointers will increase or decrease the sum relative to the target.</p> </li> <li> <p>Fixing the First Number: We iterate through the array with a primary pointer \\(i\\), fixing the first number \\(a = \\text{nums}[i]\\). The search for the remaining two numbers, \\(b\\) and \\(c\\), then focuses on the subarray starting from \\(i+1\\).</p> </li> </ol>"},{"location":"16/#the-inner-two-pointer-search-and-tracking","title":"The Inner Two-Pointer Search and Tracking","text":"<p>For each fixed \\(\\text{nums}[i]\\), we initialize a left pointer \\(L\\) at \\(i+1\\) and a right pointer \\(R\\) at the end of the array. The inner loop moves \\(L\\) and \\(R\\) towards each other, trying to find a sum \\(\\text{current\\_sum} = \\text{nums}[i] + \\text{nums}[L] + \\text{nums}[R]\\) that is closest to the <code>target</code>.</p> <p>We maintain two variables: one to store the best sum found so far, \\(\\text{closest\\_sum}\\), and one to track the minimum difference, \\(\\text{min\\_diff}\\). In each iteration:</p> <ol> <li> <p>Calculate the Current Sum and Difference: Compute \\(\\text{current\\_sum}\\) and the current difference \\(\\text{current\\_diff} = \\text{current\\_sum} - \\text{target}\\).</p> </li> <li> <p>Update the Closest Sum: We check if the absolute value of \\(\\text{current\\_diff}\\) is smaller than the absolute value of the difference associated with \\(\\text{closest\\_sum}\\) found so far. If it is, \\(\\text{closest\\_sum}\\) is updated to \\(\\text{current\\_sum}\\).</p> </li> <li> <p>Perfect Match Check: If \\(\\text{current\\_sum}\\) equals the \\(\\text{target}\\), we have found the exact solution, and we can immediately return \\(\\text{target}\\), as no other sum can be closer.</p> </li> </ol>"},{"location":"16/#governing-movement-logic","title":"Governing Movement Logic","text":"<p>The decision of which pointer to move (\\(L\\) or \\(R\\)) is the key to minimizing the search space and ensuring \\(O(n)\\) time for the inner loop. The movement is dictated by the sign of the \\(\\text{current\\_diff}\\):</p> <ol> <li> <p>Sum is Too Small (\\(\\text{current\\_diff} &lt; 0\\)): If the \\(\\text{current\\_sum}\\) is less than the \\(\\text{target}\\), we need a larger sum. Since the array is sorted, moving the left pointer \\(L\\) one step to the right will incorporate a larger number \\(\\text{nums}[L]\\), thus increasing the total sum. Therefore, we increment \\(L\\).</p> </li> <li> <p>Sum is Too Large (\\(\\text{current\\_diff} &gt; 0\\)): If the \\(\\text{current\\_sum}\\) is greater than the \\(\\text{target}\\), we need a smaller sum. Moving the right pointer \\(R\\) one step to the left will incorporate a smaller number \\(\\text{nums}[R]\\), thus decreasing the total sum. Therefore, we decrement \\(R\\).</p> </li> </ol> <p>This two-pointer loop continues until \\(L\\) and \\(R\\) cross (\\(L &lt; R\\)). The total time complexity is \\(O(n \\log n)\\) for sorting plus \\(O(n^2)\\) for the nested search (\\(O(n)\\) outer loop \\(\\times\\) \\(O(n)\\) inner loop), resulting in an optimal overall time complexity of \\(O(n^2)\\).  Unlike the 3Sum problem, we do not need complex duplicate checking because we are looking for a closest sum, not a set of unique triplets.</p>"},{"location":"17/","title":"17. Letter Combinations of a Phone Number (Medium)","text":""},{"location":"17/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"17/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Letter Combinations of a Phone Number Examples ---\")\n\n# Test Case 1: Standard two-digit input\ndigits1 = \"23\"\nresult1 = sol.letterCombinations(digits1)\n# Expected: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\nprint(f\"Input: '{digits1}'\")\nprint(f\"Output: {result1}\")\nprint(f\"Count: {len(result1)} (Expected: 9)\")\n\n# Test Case 2: Empty input\ndigits2 = \"\"\nresult2 = sol.letterCombinations(digits2)\nprint(f\"Input: '{digits2}'\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Single digit input (7 has 4 letters)\ndigits3 = \"7\"\nresult3 = sol.letterCombinations(digits3)\n# Expected: [\"p\", \"q\", \"r\", \"s\"]\nprint(f\"Input: '{digits3}'\")\nprint(f\"Output: {result3}\")\nprint(f\"Count: {len(result3)} (Expected: 4)\")\n\n# Test Case 4: Longer input (3 digits)\ndigits4 = \"567\"\nresult4 = sol.letterCombinations(digits4)\n# Expected count: 3 * 3 * 4 = 36\nprint(f\"Input: '{digits4}'\")\nprint(f\"Output: {result4[:5]}... (Showing first 5 combinations)\")\nprint(f\"Count: {len(result4)} (Expected: 36)\")</pre> Output Clear <pre></pre> </p>"},{"location":"17/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n</code></pre>"},{"location":"17/#function-description","title":"Function Description","text":"Source code in <code>python/_17.py</code> <pre><code>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n</code></pre>"},{"location":"17/#_17.Solution.letterCombinations","title":"<code>letterCombinations(digits)</code>","text":"Source code in <code>python/_17.py</code> <pre><code>def letterCombinations(self, digits: str) -&gt; list[str]:\n\n    if not digits:\n        return []\n\n    mapping = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n\n    result = []\n\n    def backtrack(index, path):\n        if index == len(digits):\n            result.append(\"\".join(path))\n            return\n\n        digit = digits[index]\n        letters = mapping[digit]\n\n        for letter in letters:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return result\n</code></pre>"},{"location":"17/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":""},{"location":"17/#problem-statement-and-the-mapping","title":"Problem Statement and The Mapping","text":"<p>LeetCode problem 17, \"Letter Combinations of a Phone Number,\" requires generating all possible letter combinations that a given digit string can represent, based on the standard telephone keypad mapping. The input is a string of digits, and the output is a list of all possible letter sequences. For example, if the input is \"23\", the digit '2' maps to \"abc\" and '3' maps to \"def\". The resulting combinations are \"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\".</p> <p>The core challenge is the combinatorial nature of the problem: if the input has \\(N\\) digits, and each digit maps to 3 or 4 letters, the total number of combinations grows exponentially. This type of problem, where we need to explore all possible paths to build a final result, is a classic application for Depth-First Search (DFS), typically implemented using Recursion or Backtracking.</p>"},{"location":"17/#the-recursivebacktracking-approach","title":"The Recursive/Backtracking Approach","text":"<p>The optimal solution uses a recursive helper function that implements the Backtracking algorithm. Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time (the \"backtracking\" part).</p> <p>For this problem, the state of the recursion is defined by two variables: 1.  Current Combination: The string of letters built so far. 2.  Next Digit Index: The index of the digit in the input string we are currently processing.</p> <p>The main function initializes the mapping (e.g., '2' to \"abc\", '3' to \"def\", etc.) and starts the recursive process. </p>"},{"location":"17/#the-recursivedfs-function-logic","title":"The Recursive/DFS Function Logic","text":"<p>The recursive function takes the current combination string and the index of the digit being considered.</p> <ol> <li> <p>Base Case: If the <code>next digit index</code> is equal to the length of the input digit string, it means we have successfully built a complete combination. We add the <code>current combination</code> to the final result list and return. This is the exit condition for the recursion.</p> </li> <li> <p>Recursive Step (The Choice):</p> <ul> <li>We retrieve the current digit from the input string using the <code>next digit index</code>.</li> <li>We look up the corresponding letters for this digit from the mapping (e.g., \"def\" for '3').</li> <li>We iterate through each letter in the retrieved string (e.g., 'd', 'e', 'f'). For each letter, this represents a choice we can make at the current step.</li> </ul> </li> <li> <p>Exploration and Backtracking:</p> <ul> <li>For each chosen letter, we recursively call the function, passing the <code>current combination</code> appended with the chosen letter, and advancing the <code>next digit index</code> by one. This represents exploring a new path in the decision tree.</li> <li>Once the recursive call returns (meaning all combinations starting with that choice have been explored), the mechanism of Backtracking is implicitly handled by the return from the function call. Since the combination is usually passed by value or built in a separate string builder/list that is not modified after the call, no explicit state cleanup is needed, allowing the loop to proceed to the next letter for the current digit.</li> </ul> </li> </ol>"},{"location":"17/#complexity-analysis","title":"Complexity Analysis","text":"<p>The time complexity of this solution is directly proportional to the total number of combinations generated. If \\(N\\) is the length of the input digits and \\(M\\) is the maximum number of letters a digit maps to (usually 3 or 4), the complexity is \\(O(M^N)\\). For instance, with 4 digits and 3 letters per digit, the complexity is \\(O(3^N)\\). The space complexity is also \\(O(M^N)\\) to store the output combinations, plus \\(O(N)\\) for the recursion depth (call stack). This efficiency is optimal because the algorithm must, by definition, generate and store every single possible combination.</p>"},{"location":"18/","title":"18. 4Sum (Medium)","text":""},{"location":"18/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"18/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- 4Sum Examples ---\")\n\n# Test Case 1: Standard example\nnums1 = [1, 0, -1, 0, -2, 2]\ntarget1 = 0\nresult1 = sol.fourSum(nums1, target1)\n# Expected output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\nprint(f\"Input: nums={nums1}, target={target1}\")\nprint(f\"Output: {result1}\")\nprint(f\"(Expected: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]])\")\n\n# Test Case 2: Array with duplicates and non-zero target\nnums2 = [2, 2, 2, 2, 2]\ntarget2 = 8\nresult2 = sol.fourSum(nums2, target2)\n# Expected output: [[2, 2, 2, 2]] (Only one unique combination)\nprint(f\"Input: nums={nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: [[2, 2, 2, 2]])\")\n\n# Test Case 3: No solution found\nnums3 = [1, 2, 3, 4, 5]\ntarget3 = 10\nresult3 = sol.fourSum(nums3, target3)\nprint(f\"Input: nums={nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: [])\")\n\n# Test Case 4: Negative target\nnums4 = [-3, -1, 0, 2, 4, 5]\ntarget4 = 2\nresult4 = sol.fourSum(nums4, target4)\n# Expected output: [[-3, -1, 2, 4], [-3, 0, 2, 3]... wait, the list is [2, 3, 4, 5]\n# [-3, -1, 2, 4] -&gt; -4 + 6 = 2\n# [-3, 0, 2, 3] -&gt; -3 + 5 = 2\n# After sorting: [-3, -1, 0, 2, 4, 5]\n# [-3, -1, 0, 6] (R=n-1, 6 is not in list)\n# [-3, 0, 2, 3] -&gt; sum is 2. (0, 2, 3 are indices 2, 3, 4, wait, indices are 2, 3, 4 are 0, 2, 4. sum is -3+0+2+4=3).\n# Correct expected: [[-3, -1, 2, 4]]\nprint(f\"Input: nums={nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: [[-3, -1, 2, 4]])\")</pre> Output Clear <pre></pre> </p>"},{"location":"18/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n</code></pre>"},{"location":"18/#function-description","title":"Function Description","text":"Source code in <code>python/_18.py</code> <pre><code>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n</code></pre>"},{"location":"18/#_18.Solution.fourSum","title":"<code>fourSum(nums, target)</code>","text":"Source code in <code>python/_18.py</code> <pre><code>def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 3):\n        if i &gt; 0 and nums[i] == nums[i-1]:\n            continue\n\n        for j in range(i + 1, n - 2):\n            if j &gt; i + 1 and nums[j] == nums[j-1]:\n                continue\n\n            new_target = target - nums[i] - nums[j]\n            L = j + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == new_target:\n                    result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; new_target:\n                    L += 1\n                else:\n                    R -= 1\n\n    return result\n</code></pre>"},{"location":"18/#18-4sum","title":"18. 4Sum","text":""},{"location":"18/#problem-statement-and-generalization","title":"Problem Statement and Generalization","text":"<p>LeetCode problem 18, \"4Sum,\" is the natural generalization of the 3Sum (LeetCode 15) and 2Sum problems. Given an array of \\(n\\) integers, \\(nums\\), and a specific integer target, the objective is to find all unique quadruplets \\([a, b, c, d]\\) within \\(nums\\) such that their sum equals the target: \\(a + b + c + d = \\text{target}\\). The crucial constraint, identical to 3Sum, is that the resulting list must contain only unique quadruplets.</p> <p>A naive brute force approach using four nested loops would result in an unacceptable time complexity of \\(O(n^4)\\). To solve this problem efficiently and pass typical time limits, we must reduce the complexity to \\(O(n^3)\\) by applying a structure similar to the 3Sum solution: fixing two numbers and then using a linear-time technique (the Two-Pointer method) to find the remaining pair.</p>"},{"location":"18/#the-optimal-approach-sorting-and-two-nested-loops","title":"The Optimal Approach: Sorting and Two Nested Loops","text":"<p>The optimal \\(O(n^3)\\) solution combines Sorting and a nested search structure.</p> <ol> <li> <p>Sorting: First, sort the input array \\(nums\\) in \\(O(n \\log n)\\) time. Sorting is mandatory as it enables the crucial efficiency gains: easy detection and skipping of duplicates, and the linear-time search via the two-pointer technique.</p> </li> <li> <p>Fixing the First Two Numbers: We use two nested loops to fix the first two numbers, \\(a\\) and \\(b\\).</p> <ul> <li>The outer loop iterates with index \\(i\\) for the first number \\(a = \\text{nums}[i]\\).</li> <li>The inner loop iterates with index \\(j\\) for the second number \\(b = \\text{nums}[j]\\), starting from \\(i+1\\). [Image illustrating the 4Sum Two-Pointer structure]</li> </ul> </li> <li> <p>Target Reduction: With \\(a\\) and \\(b\\) fixed, the problem is reduced to finding two remaining numbers, \\(c\\) and \\(d\\), in the rest of the array such that \\(c + d = \\text{target} - \\text{nums}[i] - \\text{nums}[j]\\). We calculate this remaining value as \\(\\text{new\\_target} = \\text{target} - \\text{nums}[i] - \\text{nums}[j]\\).</p> </li> </ol>"},{"location":"18/#the-inner-two-pointer-search","title":"The Inner Two-Pointer Search","text":"<p>For each pair \\((\\text{nums}[i], \\text{nums}[j])\\), the remaining task is a classic Two Sum problem on the subarray starting from index \\(j+1\\) up to the end of the array. We initialize a left pointer \\(L\\) at \\(j+1\\) and a right pointer \\(R\\) at the end of the array.</p> <p>The inner search proceeds as follows: * Calculate the \\(\\text{current\\_sum} = \\text{nums}[L] + \\text{nums}[R]\\). * If \\(\\text{current\\_sum} &lt; \\text{new\\_target}\\): The sum needs to be larger. Since the array is sorted, we move \\(L\\) one step to the right (\\(\\text{increment } L\\)). * If \\(\\text{current\\_sum} &gt; \\text{new\\_target}\\): The sum needs to be smaller. We move \\(R\\) one step to the left (\\(\\text{decrement } R\\)). * If \\(\\text{current\\_sum} = \\text{new\\_target}\\): A valid quadruplet is found. \\([ \\text{nums}[i], \\text{nums}[j], \\text{nums}[L], \\text{nums}[R] ]\\) is added to the result list.</p>"},{"location":"18/#comprehensive-duplicate-elimination","title":"Comprehensive Duplicate Elimination","text":"<p>The most challenging part of 4Sum is correctly and efficiently eliminating all duplicate quadruplets. This requires checks at three distinct points in the iteration:</p> <ol> <li> <p>Skipping Duplicates for \\(a\\) (Outer Loop): Before the inner loop starts, if \\(i &gt; 0\\) and \\(\\text{nums}[i] == \\text{nums}[i-1]\\), we skip the current iteration. This prevents using the same value for \\(a\\) consecutively.</p> </li> <li> <p>Skipping Duplicates for \\(b\\) (Inner Loop): Before the two-pointer search starts, if \\(j &gt; i+1\\) and \\(\\text{nums}[j] == \\text{nums}[j-1]\\), we skip the current iteration. This prevents using the same value for \\(b\\) consecutively with a fixed \\(a\\).</p> </li> <li> <p>Skipping Duplicates for \\(c\\) and \\(d\\) (Two-Pointer Movement): After finding a valid quadruplet, we must advance \\(L\\) and retreat \\(R\\) while skipping any duplicates for the newly found \\(c\\) and \\(d\\):</p> <ul> <li>Advance \\(L\\) while \\(L &lt; R\\) and \\(\\text{nums}[L] == \\text{nums}[L+1]\\).</li> <li>Retreat \\(R\\) while \\(L &lt; R\\) and \\(\\text{nums}[R] == \\text{nums}[R-1]\\).</li> <li>Finally, perform the actual moves: \\(\\text{increment } L\\) and \\(\\text{decrement } R\\).</li> </ul> </li> </ol> <p>By correctly implementing these three checks, the solution ensures that every returned quadruplet is unique. The overall complexity is dominated by the nested loops and the two-pointer search, resulting in the desired \\(O(n^3)\\) time complexity.</p>"},{"location":"19/","title":"19. Remove Nth Node From End of List (Medium)","text":""},{"location":"19/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"19/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Nth Node From End of List Examples ---\")\n\n# Test Case 1: Standard case\narr1 = [1, 2, 3, 4, 5]\nn1 = 2\nhead1 = create_linked_list(arr1)\nresult1 = sol.removeNthFromEnd(head1, n1)\n# Expected: [1 -&gt; 2 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}, n={n1}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Remove the head (n = list length)\narr2 = [1]\nn2 = 1\nhead2 = create_linked_list(arr2)\nresult2 = sol.removeNthFromEnd(head2, n2)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}, n={n2}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: List with two nodes, remove the first one\narr3 = [1, 2]\nn3 = 2\nhead3 = create_linked_list(arr3)\nresult3 = sol.removeNthFromEnd(head3, n3)\n# Expected: [2]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}, n={n3}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Larger example, remove node in the middle\narr4 = [10, 20, 30, 40, 50, 60]\nn4 = 3 # Removes 40\nhead4 = create_linked_list(arr4)\nresult4 = sol.removeNthFromEnd(head4, n4)\n# Expected: [10 -&gt; 20 -&gt; 30 -&gt; 50 -&gt; 60]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}, n={n4}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"19/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n</code></pre>"},{"location":"19/#function-description","title":"Function Description","text":"Source code in <code>python/_19.py</code> <pre><code>class Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n</code></pre>"},{"location":"19/#_19.Solution.removeNthFromEnd","title":"<code>removeNthFromEnd(head, n)</code>","text":"Source code in <code>python/_19.py</code> <pre><code>def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n    dummy = ListNode(0, head)\n    fast = dummy\n    slow = dummy\n\n    for _ in range(n + 1):\n        if not fast:\n            return head\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n</code></pre>"},{"location":"2/","title":"2. Add Two Numbers (Medium)","text":""},{"location":"2/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"2/#run","title":"Run","text":"<p> Editor (session: default) Run <pre># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n\n# Helper function to convert a list of digits to a linked list (in reverse order)\ndef create_linked_list(digits):\n    dummy_head = ListNode(0)\n    current = dummy_head\n    for digit in digits:\n        current.next = ListNode(digit)\n        current = current.next\n    return dummy_head.next\n\n# Helper function to convert a linked list to a list of digits\ndef linked_list_to_list(node):\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\n\n# Example 1: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) -&gt; (7 -&gt; 0 -&gt; 8)\nl1_ex1 = create_linked_list([2, 4, 3])\nl2_ex1 = create_linked_list([5, 6, 4])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex1, l2_ex1)), \"\\n\")\n\n# Example 2: (0) + (0) -&gt; (0)\nl1_ex2 = create_linked_list([0])\nl2_ex2 = create_linked_list([0])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex2, l2_ex2)), \"\\n\")\n\n# Example 3: (9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9) + (9 -&gt; 9 -&gt; 9 -&gt; 9) -&gt; (8 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 1)\nl1_ex3 = create_linked_list([9, 9, 9, 9, 9, 9, 9])\nl2_ex3 = create_linked_list([9, 9, 9, 9])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex3, l2_ex3)))</pre> Output Clear <pre></pre> </p>"},{"location":"2/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#function-description","title":"Function Description","text":"Source code in <code>python/_2.py</code> <pre><code>class Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#_2.Solution.addTwoNumbers","title":"<code>addTwoNumbers(l1, l2)</code>","text":"Source code in <code>python/_2.py</code> <pre><code>def addTwoNumbers(self, l1, l2):\n    dummy_head = ListNode(0)\n    current = dummy_head\n    carry = 0\n\n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n\n        total_sum = val1 + val2 + carry\n        carry = total_sum // 10\n        new_digit = total_sum % 10\n\n        current.next = ListNode(new_digit)\n        current = current.next\n\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n\n    return dummy_head.next\n</code></pre>"},{"location":"2/#explanation","title":"Explanation","text":"<p>The \"Add Two Numbers\" problem is a classic data structures challenge that requires adding two non-negative integers represented as linked lists. Crucially, the digits are stored in reverse order, with each node containing only a single digit. For instance, the number 342 would be represented as a list \\(2 \\to 4 \\to 3\\). The objective is to return a new linked list that represents the sum of the two input numbers. This problem assesses a developer's proficiency in handling pointer manipulation and basic arithmetic while traversing linked structures.</p> <p>The solution involves traversing both linked lists simultaneously, starting from the head (the least significant digit). A dummy head node is typically initialized to simplify the creation and return of the new resulting list.  A key component of the solution is tracking the carry-over value from one digit position to the next. In each step of the traversal, the algorithm sums the current digits from both lists (if they exist) along with the current carry-over. The new digit for the resulting list is the remainder of this sum when divided by 10, and the new carry-over is the quotient (sum divided by 10).</p> <p>The traversal continues as long as there are still digits left in either of the input lists, or if the carry-over value is greater than zero. This ensures that even if one list is shorter than the other, or if a final carry-over remains (e.g., adding \\(99 + 1\\) results in \\(100\\)), the resulting list is correctly extended. This approach effectively mimics manual addition, resulting in a single pass solution with a time complexity of \\(O(\\max(m, n))\\), where \\(m\\) and \\(n\\) are the lengths of the two input linked lists, making it an efficient and industry-standard solution.</p>"},{"location":"2/#_1","title":"2. Add Two Numbers (Medium)","text":""},{"location":"2/#_2","title":"2. Add Two Numbers (Medium)","text":""},{"location":"20/","title":"20. Valid Parentheses (Easy)","text":""},{"location":"20/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"20/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Valid Parentheses Examples ---\")\n\n# Test Case 1: Valid string\ns1 = \"()[]{}\"\nresult1 = sol.isValid(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n# Test Case 2: Invalid order\ns2 = \"(]\"\nresult2 = sol.isValid(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: False)\")\n\n# Test Case 3: Invalid closing type\ns3 = \"([)]\"\nresult3 = sol.isValid(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: False)\")\n\n# Test Case 4: Valid nested string\ns4 = \"{[]}\"\nresult4 = sol.isValid(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: True)\")\n\n# Test Case 5: Unclosed bracket (stack not empty at end)\ns5 = \"([{\"\nresult5 = sol.isValid(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Closed bracket with empty stack (placeholder mismatch)\ns6 = \")))\"\nresult6 = sol.isValid(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: False)\")</pre> Output Clear <pre></pre> </p>"},{"location":"20/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n</code></pre>"},{"location":"20/#function-description","title":"Function Description","text":"Source code in <code>python/_20.py</code> <pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n</code></pre>"},{"location":"20/#_20.Solution.isValid","title":"<code>isValid(s)</code>","text":"Source code in <code>python/_20.py</code> <pre><code>def isValid(self, s: str) -&gt; bool:\n\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n\n    return not stack\n</code></pre>"},{"location":"21/","title":"21. Merge Two Sorted Lists (Easy)","text":""},{"location":"21/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"21/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Merge Two Sorted Lists Examples ---\")\n\n# Test Case 1: Standard merge\narr1 = [1, 2, 4]\narr2 = [1, 3, 4]\nlist1 = create_linked_list(arr1)\nlist2 = create_linked_list(arr2)\nresult1 = sol.mergeTwoLists(list1, list2)\n# Expected: [1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr1))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr2))}\")\nprint(f\"Output: {print_linked_list(result1)}\")\n\n# Test Case 2: One empty list\narr3 = []\narr4 = [0]\nlist3 = create_linked_list(arr3)\nlist4 = create_linked_list(arr4)\nresult2 = sol.mergeTwoLists(list3, list4)\n# Expected: [0]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr3))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr4))}\")\nprint(f\"Output: {print_linked_list(result2)}\")\n\n# Test Case 3: Both empty lists\narr5 = []\narr6 = []\nlist5 = create_linked_list(arr5)\nlist6 = create_linked_list(arr6)\nresult3 = sol.mergeTwoLists(list5, list6)\n# Expected: []\nprint(f\"List 1: {print_linked_list(create_linked_list(arr5))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr6))}\")\nprint(f\"Output: {print_linked_list(result3)}\")\n\n# Test Case 4: One list contains all smaller elements\narr7 = [1, 2, 3]\narr8 = [4, 5, 6]\nlist7 = create_linked_list(arr7)\nlist8 = create_linked_list(arr8)\nresult4 = sol.mergeTwoLists(list7, list8)\n# Expected: [1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6]\nprint(f\"List 1: {print_linked_list(create_linked_list(arr7))}\")\nprint(f\"List 2: {print_linked_list(create_linked_list(arr8))}\")\nprint(f\"Output: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"21/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n</code></pre>"},{"location":"21/#function-description","title":"Function Description","text":"Source code in <code>python/_21.py</code> <pre><code>class Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n</code></pre>"},{"location":"21/#_21.Solution.mergeTwoLists","title":"<code>mergeTwoLists(list1, list2)</code>","text":"Source code in <code>python/_21.py</code> <pre><code>def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n    dummy = ListNode(0)\n    current = dummy\n\n    while list1 and list2:\n        if list1.val &lt;= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n\n    current.next = list1 if list1 else list2\n\n    return dummy.next\n</code></pre>"},{"location":"22/","title":"22. Generate Parentheses (Medium)","text":""},{"location":"22/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"22/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Generate Parentheses Examples ---\")\n\n# Test Case 1: n = 3\nn1 = 3\nresult1 = sol.generateParenthesis(n1)\n# Expected: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nprint(f\"Input: n={n1}\")\nprint(f\"Output: {result1}\")\nprint(f\"Count: {len(result1)} (Expected: 5)\")\n\n# Test Case 2: n = 1\nn2 = 1\nresult2 = sol.generateParenthesis(n2)\n# Expected: [\"()\"]\nprint(f\"Input: n={n2}\")\nprint(f\"Output: {result2}\")\nprint(f\"Count: {len(result2)} (Expected: 1)\")\n\n# Test Case 3: n = 2\nn3 = 2\nresult3 = sol.generateParenthesis(n3)\n# Expected: [\"(())\", \"()()\"]\nprint(f\"Input: n={n3}\")\nprint(f\"Output: {result3}\")\nprint(f\"Count: {len(result3)} (Expected: 2)\")</pre> Output Clear <pre></pre> </p>"},{"location":"22/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n</code></pre>"},{"location":"22/#function-description","title":"Function Description","text":"Source code in <code>python/_22.py</code> <pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n</code></pre>"},{"location":"22/#_22.Solution.generateParenthesis","title":"<code>generateParenthesis(n)</code>","text":"Source code in <code>python/_22.py</code> <pre><code>def generateParenthesis(self, n: int) -&gt; list[str]:\n\n    result = []\n\n    def backtrack(open_count, close_count, current_string):\n        if len(current_string) == 2 * n:\n            result.append(current_string)\n            return\n\n        if open_count &lt; n:\n            backtrack(open_count + 1, close_count, current_string + \"(\")\n\n        if close_count &lt; open_count:\n            backtrack(open_count, close_count + 1, current_string + \")\")\n\n    backtrack(0, 0, \"\")\n    return result\n</code></pre>"},{"location":"23/","title":"23. Merge k Sorted Lists (Hard)","text":""},{"location":"23/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"23/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Merge k Sorted Lists Examples ---\")\n\n# Test Case 1: Standard k=3 lists\narr1 = [1, 4, 5]\narr2 = [1, 3, 4]\narr3 = [2, 6]\nlists1 = [create_linked_list(arr1), create_linked_list(arr2), create_linked_list(arr3)]\nresult1 = sol.mergeKLists(lists1)\n# Expected: [1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6]\nprint(f\"Input Lists: {[[1, 4, 5], [1, 3, 4], [2, 6]]}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Empty input list\nlists2 = []\nresult2 = sol.mergeKLists(lists2)\n# Expected: []\nprint(f\"Input Lists: {[]}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: List containing empty lists\narr4 = []\narr5 = [1, 5]\narr6 = [2, 4]\nlists3 = [create_linked_list(arr4), create_linked_list(arr5), create_linked_list(arr6)]\nresult3 = sol.mergeKLists(lists3)\n# Expected: [1 -&gt; 2 -&gt; 4 -&gt; 5]\nprint(f\"Input Lists: {[[2, 4], [1, 5], []]}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Single list in the input\nlists4 = [create_linked_list([10, 20, 30])]\nresult4 = sol.mergeKLists(lists4)\n# Expected: [10 -&gt; 20 -&gt; 30]\nprint(f\"Input Lists: {[[10, 20, 30]]}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"23/#solution","title":"Solution","text":"<pre><code>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n</code></pre>"},{"location":"23/#function-description","title":"Function Description","text":"Source code in <code>python/_23.py</code> <pre><code>class Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n</code></pre>"},{"location":"23/#_23.Solution.mergeKLists","title":"<code>mergeKLists(lists)</code>","text":"Source code in <code>python/_23.py</code> <pre><code>def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n    heap = []\n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n\n    dummy = ListNode(0)\n    current = dummy\n\n    while heap:\n        val, i, node = heapq.heappop(heap)\n\n        current.next = node\n        current = current.next\n\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n\n    return dummy.next\n</code></pre>"},{"location":"24/","title":"24. Swap Nodes in Pairs (Medium)","text":""},{"location":"24/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"24/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Swap Nodes in Pairs Examples ---\")\n\n# Test Case 1: Standard case (even number of nodes)\narr1 = [1, 2, 3, 4]\nhead1 = create_linked_list(arr1)\nresult1 = sol.swapPairs(head1)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Odd number of nodes (last node remains in place)\narr2 = [1, 2, 3, 4, 5]\nhead2 = create_linked_list(arr2)\nresult2 = sol.swapPairs(head2)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: Empty list\narr3 = []\nhead3 = create_linked_list(arr3)\nresult3 = sol.swapPairs(head3)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: Single node\narr4 = [1]\nhead4 = create_linked_list(arr4)\nresult4 = sol.swapPairs(head4)\n# Expected: [1]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"24/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n</code></pre>"},{"location":"24/#function-description","title":"Function Description","text":"Source code in <code>python/_24.py</code> <pre><code>class Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n</code></pre>"},{"location":"24/#_24.Solution.swapPairs","title":"<code>swapPairs(head)</code>","text":"Source code in <code>python/_24.py</code> <pre><code>def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n\n    while prev.next and prev.next.next:\n        first = prev.next\n        second = prev.next.next\n\n        prev.next = second\n        first.next = second.next\n        second.next = first\n\n        prev = first\n\n    return dummy.next\n</code></pre>"},{"location":"25/","title":"25. Reverse Nodes in k-Group (Hard)","text":""},{"location":"25/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"25/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n\n# --- Helper function for list creation and printing ---\n\ndef create_linked_list(arr: list[int]) -&gt; ListNode | None:\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef print_linked_list(head: ListNode | None):\n    if not head:\n        return \"[]\"\n\n    nodes = []\n    current = head\n    while current:\n        nodes.append(str(current.val))\n        current = current.next\n    return \"[\" + \" -&gt; \".join(nodes) + \"]\"\n\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Reverse Nodes in k-Group Examples ---\")\n\n# Test Case 1: Standard case (k=2)\narr1 = [1, 2, 3, 4, 5]\nk1 = 2\nhead1 = create_linked_list(arr1)\nresult1 = sol.reverseKGroup(head1, k1)\n# Expected: [2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5]\nprint(f\"Input List: {print_linked_list(create_linked_list(arr1))}, k={k1}\")\nprint(f\"Output List: {print_linked_list(result1)}\")\n\n# Test Case 2: Standard case (k=3)\narr2 = [1, 2, 3, 4, 5]\nk2 = 3\nhead2 = create_linked_list(arr2)\nresult2 = sol.reverseKGroup(head2, k2)\n# Expected: [3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5] (The last two nodes are not reversed)\nprint(f\"Input List: {print_linked_list(create_linked_list(arr2))}, k={k2}\")\nprint(f\"Output List: {print_linked_list(result2)}\")\n\n# Test Case 3: Empty list\narr3 = []\nk3 = 2\nhead3 = create_linked_list(arr3)\nresult3 = sol.reverseKGroup(head3, k3)\n# Expected: []\nprint(f\"Input List: {print_linked_list(create_linked_list(arr3))}, k={k3}\")\nprint(f\"Output List: {print_linked_list(result3)}\")\n\n# Test Case 4: k is greater than list length\narr4 = [1, 2]\nk4 = 3\nhead4 = create_linked_list(arr4)\nresult4 = sol.reverseKGroup(head4, k4)\n# Expected: [1 -&gt; 2] (No reversal occurs)\nprint(f\"Input List: {print_linked_list(create_linked_list(arr4))}, k={k4}\")\nprint(f\"Output List: {print_linked_list(result4)}\")</pre> Output Clear <pre></pre> </p>"},{"location":"25/#solution","title":"Solution","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n</code></pre>"},{"location":"25/#function-description","title":"Function Description","text":"Source code in <code>python/_25.py</code> <pre><code>class Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n</code></pre>"},{"location":"25/#_25.Solution.reverseKGroup","title":"<code>reverseKGroup(head, k)</code>","text":"Source code in <code>python/_25.py</code> <pre><code>def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n    dummy = ListNode(0, head)\n    prev_group_tail = dummy\n\n    while True:\n        kth = head\n        for _ in range(k - 1):\n            if not kth:\n                break\n            kth = kth.next\n\n        if not kth:\n            break\n\n        next_group_head = kth.next\n\n        curr, prev = head, next_group_head\n        for _ in range(k):\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n\n        prev_group_tail.next = prev\n        prev_group_tail = head\n        head = next_group_head\n\n    return dummy.next\n</code></pre>"},{"location":"26/","title":"26. Remove Duplicates from Sorted Array (Easy)","text":""},{"location":"26/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"26/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Duplicates from Sorted Array Examples ---\")\n\n# Test Case 1: Standard case\nnums1 = [1, 1, 2]\noriginal_nums1 = list(nums1) # Keep original for printout\nk1 = sol.removeDuplicates(nums1)\n# The first k elements should be [1, 2]\nprint(f\"Input: {original_nums1}\")\nprint(f\"Output Length (k): {k1} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums1[:k1]}\")\n\n# Test Case 2: Many duplicates\nnums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\noriginal_nums2 = list(nums2)\nk2 = sol.removeDuplicates(nums2)\n# The first k elements should be [0, 1, 2, 3, 4]\nprint(f\"\\nInput: {original_nums2}\")\nprint(f\"Output Length (k): {k2} (Expected: 5)\")\nprint(f\"Modified Array (first k elements): {nums2[:k2]}\")\n\n# Test Case 3: No duplicates\nnums3 = [10, 20, 30]\noriginal_nums3 = list(nums3)\nk3 = sol.removeDuplicates(nums3)\n# The first k elements should be [10, 20, 30]\nprint(f\"\\nInput: {original_nums3}\")\nprint(f\"Output Length (k): {k3} (Expected: 3)\")\nprint(f\"Modified Array (first k elements): {nums3[:k3]}\")\n\n# Test Case 4: Empty array\nnums4 = []\noriginal_nums4 = list(nums4)\nk4 = sol.removeDuplicates(nums4)\n# Expected: 0\nprint(f\"\\nInput: {original_nums4}\")\nprint(f\"Output Length (k): {k4} (Expected: 0)\")\nprint(f\"Modified Array (first k elements): {nums4[:k4]}\")</pre> Output Clear <pre></pre> </p>"},{"location":"26/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n</code></pre>"},{"location":"26/#function-description","title":"Function Description","text":"Source code in <code>python/_26.py</code> <pre><code>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n</code></pre>"},{"location":"26/#_26.Solution.removeDuplicates","title":"<code>removeDuplicates(nums)</code>","text":"Source code in <code>python/_26.py</code> <pre><code>def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n    if not nums:\n        return 0\n\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n\n    return i + 1\n</code></pre>"},{"location":"27/","title":"27. Remove Element (Easy)","text":""},{"location":"27/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"27/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Remove Element Examples ---\")\n\n# Test Case 1: Standard case\nnums1 = [3, 2, 2, 3]\nval1 = 3\noriginal_nums1 = list(nums1) # Keep original for printout\nk1 = sol.removeElement(nums1, val1)\n# The first k elements should be [2, 2]\nprint(f\"Input: {original_nums1}, val={val1}\")\nprint(f\"Output Length (k): {k1} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums1[:k1]}\")\n\n# Test Case 2: Target value is not present\nnums2 = [4, 5]\nval2 = 1\noriginal_nums2 = list(nums2)\nk2 = sol.removeElement(nums2, val2)\n# The first k elements should be [4, 5]\nprint(f\"\\nInput: {original_nums2}, val={val2}\")\nprint(f\"Output Length (k): {k2} (Expected: 2)\")\nprint(f\"Modified Array (first k elements): {nums2[:k2]}\")\n\n# Test Case 3: Target value is all elements\nnums3 = [5, 5, 5]\nval3 = 5\noriginal_nums3 = list(nums3)\nk3 = sol.removeElement(nums3, val3)\n# The first k elements should be []\nprint(f\"\\nInput: {original_nums3}, val={val3}\")\nprint(f\"Output Length (k): {k3} (Expected: 0)\")\nprint(f\"Modified Array (first k elements): {nums3[:k3]}\")\n\n# Test Case 4: Longer array\nnums4 = [0, 1, 2, 2, 3, 0, 4, 2]\nval4 = 2\noriginal_nums4 = list(nums4)\nk4 = sol.removeElement(nums4, val4)\n# The first k elements should be [0, 1, 3, 0, 4] (order may vary, but these 5 unique elements must be present)\nprint(f\"\\nInput: {original_nums4}, val={val4}\")\nprint(f\"Output Length (k): {k4} (Expected: 5)\")\nprint(f\"Modified Array (first k elements): {nums4[:k4]}\")</pre> Output Clear <pre></pre> </p>"},{"location":"27/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n</code></pre>"},{"location":"27/#function-description","title":"Function Description","text":"Source code in <code>python/_27.py</code> <pre><code>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n</code></pre>"},{"location":"27/#_27.Solution.removeElement","title":"<code>removeElement(nums, val)</code>","text":"Source code in <code>python/_27.py</code> <pre><code>def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n\n    return i\n</code></pre>"},{"location":"28/","title":"28. Find the Index of the First Occurrence in a String (Easy)","text":""},{"location":"28/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"28/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Find the Index of the First Occurrence in a String Examples ---\")\n\n# Test Case 1: Standard match\nhaystack1 = \"sadbutsad\"\nneedle1 = \"sad\"\nresult1 = sol.strStr(haystack1, needle1)\nprint(f\"Haystack: '{haystack1}', Needle: '{needle1}'\")\nprint(f\"Output: {result1} (Expected: 0)\")\n\n# Test Case 2: No match\nhaystack2 = \"leetcode\"\nneedle2 = \"leeto\"\nresult2 = sol.strStr(haystack2, needle2)\nprint(f\"\\nHaystack: '{haystack2}', Needle: '{needle2}'\")\nprint(f\"Output: {result2} (Expected: -1)\")\n\n# Test Case 3: Empty needle\nhaystack3 = \"abc\"\nneedle3 = \"\"\nresult3 = sol.strStr(haystack3, needle3)\nprint(f\"\\nHaystack: '{haystack3}', Needle: '{needle3}'\")\nprint(f\"Output: {result3} (Expected: 0)\")\n\n# Test Case 4: Match in the middle\nhaystack4 = \"hello\"\nneedle4 = \"ll\"\nresult4 = sol.strStr(haystack4, needle4)\nprint(f\"\\nHaystack: '{haystack4}', Needle: '{needle4}'\")\nprint(f\"Output: {result4} (Expected: 2)\")\n\n# Test Case 5: Match at the end\nhaystack5 = \"mississippi\"\nneedle5 = \"pi\"\nresult5 = sol.strStr(haystack5, needle5)\nprint(f\"\\nHaystack: '{haystack5}', Needle: '{needle5}'\")\nprint(f\"Output: {result5} (Expected: 9)\")</pre> Output Clear <pre></pre> </p>"},{"location":"28/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n</code></pre>"},{"location":"28/#function-description","title":"Function Description","text":"Source code in <code>python/_28.py</code> <pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n</code></pre>"},{"location":"28/#_28.Solution.strStr","title":"<code>strStr(haystack, needle)</code>","text":"Source code in <code>python/_28.py</code> <pre><code>def strStr(self, haystack: str, needle: str) -&gt; int:\n\n    if not needle:\n        return 0\n\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i + len(needle)] == needle:\n            return i\n\n    return -1\n</code></pre>"},{"location":"29/","title":"29. Divide Two Integers (Medium)","text":""},{"location":"29/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"29/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Divide Two Integers Examples ---\")\n\n# Test Case 1: Standard positive division\ndividend1, divisor1 = 10, 3\nresult1 = sol.divide(dividend1, divisor1)\nprint(f\"Input: {dividend1} / {divisor1}\")\nprint(f\"Output: {result1} (Expected: 3)\")\n\n# Test Case 2: Negative result\ndividend2, divisor2 = 7, -3\nresult2 = sol.divide(dividend2, divisor2)\nprint(f\"Input: {dividend2} / {divisor2}\")\nprint(f\"Output: {result2} (Expected: -2)\")\n\n# Test Case 3: Overflow edge case (MAX_INT)\ndividend3, divisor3 = -2147483648, -1\nresult3 = sol.divide(dividend3, divisor3)\nprint(f\"Input: {dividend3} / {divisor3}\")\nprint(f\"Output: {result3} (Expected: 2147483647)\")\n\n# Test Case 4: Dividend is smaller than divisor\ndividend4, divisor4 = 1, 2\nresult4 = sol.divide(dividend4, divisor4)\nprint(f\"Input: {dividend4} / {divisor4}\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Large division\ndividend5, divisor5 = 100, 10\nresult5 = sol.divide(dividend5, divisor5)\nprint(f\"Input: {dividend5} / {divisor5}\")\nprint(f\"Output: {result5} (Expected: 10)\")</pre> Output Clear <pre></pre> </p>"},{"location":"29/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n</code></pre>"},{"location":"29/#function-description","title":"Function Description","text":"Source code in <code>python/_29.py</code> <pre><code>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n</code></pre>"},{"location":"29/#_29.Solution.divide","title":"<code>divide(dividend, divisor)</code>","text":"Source code in <code>python/_29.py</code> <pre><code>def divide(self, dividend: int, divisor: int) -&gt; int:\n\n    MAX_INT = 2147483647\n    MIN_INT = -2147483648\n\n    if dividend == MIN_INT and divisor == -1:\n        return MAX_INT\n\n    negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n    abs_dividend = abs(dividend)\n    abs_divisor = abs(divisor)\n\n    quotient = 0\n\n    for i in range(31, -1, -1):\n        if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n            quotient += (1 &lt;&lt; i)\n            abs_dividend -= (abs_divisor &lt;&lt; i)\n\n    if negative:\n        return -quotient\n    else:\n        return quotient\n</code></pre>"},{"location":"3/","title":"3. Longest Substring Without Repeating Characters (Medium)","text":""},{"location":"3/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"3/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n# Example Usage:\nsol = Solution()\nprint(sol.lengthOfLongestSubstring(\"abcabcbb\")) # Output: 3 (\"abc\")\nprint(sol.lengthOfLongestSubstring(\"bbbbb\"))    # Output: 1 (\"b\")\nprint(sol.lengthOfLongestSubstring(\"pwwkew\"))   # Output: 3 (\"wke\")</pre> Output Clear <pre></pre> </p>"},{"location":"3/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"3/#function-description","title":"Function Description","text":"Source code in <code>python/_3.py</code> <pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"3/#_3.Solution.lengthOfLongestSubstring","title":"<code>lengthOfLongestSubstring(s)</code>","text":"Source code in <code>python/_3.py</code> <pre><code>def lengthOfLongestSubstring(self, s: str) -&gt; int:\n    char_set = set()\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n</code></pre>"},{"location":"3/#explanation","title":"Explanation","text":"<p>The \"Longest Substring Without Repeating Characters\" problem is a foundational algorithmic challenge that requires finding the maximum length of a substring within a given input string \\(s\\) that contains no repeated characters. This problem is an excellent measure of a developer's ability to identify and implement time-efficient solutions. While a simple brute-force check of all possible substrings yields a highly inefficient time complexity of \\(O(n^3)\\) or a slightly better \\(O(n^2)\\), professional standards demand an optimized solution that can handle large inputs, specifically one that operates in linear time, \\(O(n)\\).</p> <p>The standard, most robust approach for solving this problem involves the Sliding Window technique. This method utilizes two pointers, <code>left</code> and <code>right</code>, to dynamically define the current substring window. To ensure rapid checks for character uniqueness, a hash set (or a map) is used to track the characters currently residing within the window, leveraging its \\(O(1)\\) average-time lookup capability. The <code>right</code> pointer iterates through the string, expanding the window one character at a time. As the window expands, the current length is continuously compared against and updates the global maximum length found so far.</p> <p>The key to the \\(O(n)\\) efficiency lies in how the algorithm handles duplicates. If the character at \\(s[right]\\) is already present in the hash set, the uniqueness constraint is violated. Instead of discarding all previous work, the <code>left</code> pointer advances, removing characters from the left side of the window (and the hash set) until the duplicate character that caused the collision is finally removed. Once the window is again valid, the <code>right</code> pointer continues its forward movement. Because each character is visited by both the <code>left</code> and <code>right</code> pointers at most once, this single-pass, two-pointer strategy guarantees the sought-after \\(O(n)\\) time complexity, making it the industry-standard solution.</p>"},{"location":"3/#_1","title":"3. Longest Substring Without Repeating Characters (Medium)","text":""},{"location":"3/#_2","title":"3. Longest Substring Without Repeating Characters (Medium)","text":""},{"location":"30/","title":"30. Substring with Concatenation of All Words (Hard)","text":""},{"location":"30/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"30/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Substring with Concatenation of All Words Examples ---\")\n\n# Test Case 1: Standard example\ns1 = \"barfoothefoobarman\"\nwords1 = [\"foo\", \"bar\"]\nresult1 = sol.findSubstring(s1, words1)\n# Expected: [0, 9] (\"barfoo\" at 0, \"foobar\" at 9)\nprint(f\"Input: s='{s1}', words={words1}\")\nprint(f\"Output: {result1} (Expected: [0, 9])\")\n\n# Test Case 2: Overlapping words, multiple results\ns2 = \"wordgoodgoodgoodbestword\"\nwords2 = [\"word\", \"good\", \"best\", \"word\"]\nresult2 = sol.findSubstring(s2, words2)\n# Expected: [] (The three 'good's are not covered by the required words)\nprint(f\"\\nInput: s='{s2}', words={words2}\")\nprint(f\"Output: {result2} (Expected: [])\")\n\n# Test Case 3: Duplicates in words\ns3 = \"barfoofoobarthefoobarman\"\nwords3 = [\"bar\", \"foo\", \"the\"]\nresult3 = sol.findSubstring(s3, words3)\n# Expected: [6, 9, 12]\nprint(f\"\\nInput: s='{s3}', words={words3}\")\nprint(f\"Output: {result3} (Expected: [6, 9, 12])\")\n\n# Test Case 4: Long string with words that are not found\ns4 = \"barfoobarman\"\nwords4 = [\"man\", \"bar\"]\nresult4 = sol.findSubstring(s4, words4)\n# Expected: [6] (\"manbar\" is not present, but \"barman\" is not valid. The only valid is \"foobarman\" where \"bar\" is at 6)\n# Correct Expected: [6] (\"barfoobarman\" -&gt; \"bar\" at 0, \"foo\" at 3, \"bar\" at 6, \"man\" at 9. Valid concatenation is \"barfoo\" or \"foobar\", but target is 2 words.\n# \"foobar\" at 6: \"barman\" - No.\n# \"barfoobarman\" - word_len=3, num_words=2, total_len=6\n# Window 0-5: \"barfoo\". Words: [\"bar\", \"foo\"]. Match. Index 0.\n# Window 3-8: \"foothe\". Words: [\"foo\", \"the\"]. Target: [\"man\", \"bar\"]. No match.\n# Correct Expected: [6] for [\"bar\", \"foo\", \"the\"] is wrong.\n# Correct for words4: [\"man\", \"bar\"] is target.\n# Index 6: \"barman\" -&gt; [\"bar\", \"man\"]. Match. Index 6.\nprint(f\"\\nInput: s='{s4}', words={words4}\")\nprint(f\"Output: {result4} (Expected: [6])\")</pre> Output Clear <pre></pre> </p>"},{"location":"30/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n</code></pre>"},{"location":"30/#function-description","title":"Function Description","text":"Source code in <code>python/_30.py</code> <pre><code>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n</code></pre>"},{"location":"30/#_30.Solution.findSubstring","title":"<code>findSubstring(s, words)</code>","text":"Source code in <code>python/_30.py</code> <pre><code>def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n    if not words:\n        return []\n\n    word_len = len(words[0])\n    num_words = len(words)\n    total_len = word_len * num_words\n\n    from collections import Counter\n    word_count = Counter(words)\n    result = []\n\n    for i in range(word_len):\n        left = i\n        right = i\n        current_count = Counter()\n\n        while right + word_len &lt;= len(s):\n            word = s[right : right + word_len]\n            right += word_len\n\n            if word in word_count:\n                current_count[word] += 1\n\n                while current_count[word] &gt; word_count[word]:\n                    left_word = s[left : left + word_len]\n                    current_count[left_word] -= 1\n                    left += word_len\n\n                if right - left == total_len:\n                    result.append(left)\n            else:\n                current_count.clear()\n                left = right\n\n    return result\n</code></pre>"},{"location":"31/","title":"31. Next Permutation (Medium)","text":""},{"location":"31/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"31/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Next Permutation Examples ---\")\n\n# Helper function to test and print the result\ndef test_permutation(nums_list):\n    original = list(nums_list)\n    sol.nextPermutation(nums_list)\n    print(f\"Input: {original}\")\n    print(f\"Output: {nums_list}\")\n\n# Test Case 1: Standard case\ntest_permutation([1, 2, 3]) # Expected: [1, 3, 2]\n\n# Test Case 2: Array needs partial reversal and swap\ntest_permutation([3, 2, 1]) # Expected: [1, 2, 3] (Sorted descending, so becomes the lowest)\n\n# Test Case 3: Finding the pivot and swap candidate\ntest_permutation([1, 1, 5]) # Expected: [1, 5, 1]\n\n# Test Case 4: Complex swap and reverse\ntest_permutation([1, 5, 8, 4, 7, 6, 5, 3, 1]) # Expected: [1, 5, 8, 5, 1, 3, 4, 6, 7]\n\n# Test Case 5: Single element\ntest_permutation([4]) # Expected: [4]</pre> Output Clear <pre></pre> </p>"},{"location":"31/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n</code></pre>"},{"location":"31/#function-description","title":"Function Description","text":"Source code in <code>python/_31.py</code> <pre><code>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n</code></pre>"},{"location":"31/#_31.Solution.nextPermutation","title":"<code>nextPermutation(nums)</code>","text":"Source code in <code>python/_31.py</code> <pre><code>def nextPermutation(self, nums: list[int]) -&gt; None:\n\n    n = len(nums)\n    i = n - 2\n\n    while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n        i -= 1\n\n    if i &gt;= 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    left, right = i + 1, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n</code></pre>"},{"location":"32/","title":"32. Longest Valid Parentheses (Hard)","text":""},{"location":"32/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"32/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Longest Valid Parentheses Examples ---\")\n\n# Test Case 1: Standard case\ns1 = \"(()\"\nresult1 = sol.longestValidParentheses(s1)\n# Expected: 2 (from \"()\")\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Complex valid substring\ns2 = \")()())\"\nresult2 = sol.longestValidParentheses(s2)\n# Expected: 4 (from \"()()\")\nprint(f\"\\nInput: '{s2}'\")\nprint(f\"Output: {result2} (Expected: 4)\")\n\n# Test Case 3: Fully valid\ns3 = \"()(())\"\nresult3 = sol.longestValidParentheses(s3)\n# Expected: 6\nprint(f\"\\nInput: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 6)\")\n\n# Test Case 4: Long string with multiple parts\ns4 = \")(()())(()(\"\nresult4 = sol.longestValidParentheses(s4)\n# Expected: 6 (from \"()()()\" at index 2)\nprint(f\"\\nInput: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 6)\")\n\n# Test Case 5: Empty string\ns5 = \"\"\nresult5 = sol.longestValidParentheses(s5)\n# Expected: 0\nprint(f\"\\nInput: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 0)\")</pre> Output Clear <pre></pre> </p>"},{"location":"32/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n</code></pre>"},{"location":"32/#function-description","title":"Function Description","text":"Source code in <code>python/_32.py</code> <pre><code>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n</code></pre>"},{"location":"32/#_32.Solution.longestValidParentheses","title":"<code>longestValidParentheses(s)</code>","text":"Source code in <code>python/_32.py</code> <pre><code>def longestValidParentheses(self, s: str) -&gt; int:\n\n    max_len = 0\n    stack = [-1]\n\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                max_len = max(max_len, i - stack[-1])\n\n    return max_len\n</code></pre>"},{"location":"33/","title":"33. Search in Rotated Sorted Array (Medium)","text":""},{"location":"33/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"33/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Search in Rotated Sorted Array Examples ---\")\n\n# Test Case 1: Target found in the left half of the original array (right of pivot)\nnums1 = [4, 5, 6, 7, 0, 1, 2]\ntarget1 = 0\nresult1 = sol.search(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 4)\")\n\n# Test Case 2: Target found in the right half of the original array (left of pivot)\nnums2 = [4, 5, 6, 7, 0, 1, 2]\ntarget2 = 6\nresult2 = sol.search(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 2)\")\n\n# Test Case 3: Target not found\nnums3 = [4, 5, 6, 7, 0, 1, 2]\ntarget3 = 3\nresult3 = sol.search(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: -1)\")\n\n# Test Case 4: Array with a single rotation (pivot is nums[0])\nnums4 = [1, 3]\ntarget4 = 3\nresult4 = sol.search(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 1)\")\n\n# Test Case 5: Pivot at the end\nnums5 = [3, 1]\ntarget5 = 1\nresult5 = sol.search(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: 1)\")</pre> Output Clear <pre></pre> </p>"},{"location":"33/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n</code></pre>"},{"location":"33/#function-description","title":"Function Description","text":"Source code in <code>python/_33.py</code> <pre><code>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n</code></pre>"},{"location":"33/#_33.Solution.search","title":"<code>search(nums, target)</code>","text":"Source code in <code>python/_33.py</code> <pre><code>def search(self, nums: list[int], target: int) -&gt; int:\n\n    L, R = 0, len(nums) - 1\n\n    while L &lt;= R:\n        mid = (L + R) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[L] &lt;= nums[mid]:\n            if nums[L] &lt;= target &lt; nums[mid]:\n                R = mid - 1\n            else:\n                L = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[R]:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n    return -1\n</code></pre>"},{"location":"34/","title":"34. Find First and Last Position of Element in Sorted Array (Medium)","text":""},{"location":"34/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"34/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Find First and Last Position of Element Examples ---\")\n\n# Test Case 1: Standard case with target found multiple times\nnums1 = [5, 7, 7, 8, 8, 10]\ntarget1 = 8\nresult1 = sol.searchRange(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: [3, 4])\")\n\n# Test Case 2: Target found once\nnums2 = [1, 2, 3, 4, 5]\ntarget2 = 3\nresult2 = sol.searchRange(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: [2, 2])\")\n\n# Test Case 3: Target not found\nnums3 = [5, 7, 7, 8, 8, 10]\ntarget3 = 6\nresult3 = sol.searchRange(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: [-1, -1])\")\n\n# Test Case 4: Empty array\nnums4 = []\ntarget4 = 0\nresult4 = sol.searchRange(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: [-1, -1])\")\n\n# Test Case 5: Target is the first element\nnums5 = [1, 1, 1, 2, 3]\ntarget5 = 1\nresult5 = sol.searchRange(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: [0, 2])\")</pre> Output Clear <pre></pre> </p>"},{"location":"34/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n</code></pre>"},{"location":"34/#function-description","title":"Function Description","text":"Source code in <code>python/_34.py</code> <pre><code>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n</code></pre>"},{"location":"34/#_34.Solution.searchRange","title":"<code>searchRange(nums, target)</code>","text":"Source code in <code>python/_34.py</code> <pre><code>def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n    def find_bound(is_first):\n        L, R = 0, len(nums) - 1\n        idx = -1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n            if nums[mid] == target:\n                idx = mid\n                if is_first:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n        return idx\n\n    first = find_bound(True)\n    if first == -1:\n        return [-1, -1]\n\n    last = find_bound(False)\n    return [first, last]\n</code></pre>"},{"location":"35/","title":"35. Search Insert Position (Easy)","text":""},{"location":"35/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"35/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Search Insert Position Examples ---\")\n\n# Test Case 1: Target found\nnums1 = [1, 3, 5, 6]\ntarget1 = 5\nresult1 = sol.searchInsert(nums1, target1)\nprint(f\"Input: {nums1}, target={target1}\")\nprint(f\"Output: {result1} (Expected: 2)\")\n\n# Test Case 2: Target not found, insert in middle\nnums2 = [1, 3, 5, 6]\ntarget2 = 2\nresult2 = sol.searchInsert(nums2, target2)\nprint(f\"\\nInput: {nums2}, target={target2}\")\nprint(f\"Output: {result2} (Expected: 1)\")\n\n# Test Case 3: Target not found, insert at the end\nnums3 = [1, 3, 5, 6]\ntarget3 = 7\nresult3 = sol.searchInsert(nums3, target3)\nprint(f\"\\nInput: {nums3}, target={target3}\")\nprint(f\"Output: {result3} (Expected: 4)\")\n\n# Test Case 4: Target not found, insert at the beginning\nnums4 = [1, 3, 5, 6]\ntarget4 = 0\nresult4 = sol.searchInsert(nums4, target4)\nprint(f\"\\nInput: {nums4}, target={target4}\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Empty array\nnums5 = []\ntarget5 = 5\nresult5 = sol.searchInsert(nums5, target5)\nprint(f\"\\nInput: {nums5}, target={target5}\")\nprint(f\"Output: {result5} (Expected: 0)\")</pre> Output Clear <pre></pre> </p>"},{"location":"35/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n</code></pre>"},{"location":"35/#function-description","title":"Function Description","text":"Source code in <code>python/_35.py</code> <pre><code>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n</code></pre>"},{"location":"35/#_35.Solution.searchInsert","title":"<code>searchInsert(nums, target)</code>","text":"Source code in <code>python/_35.py</code> <pre><code>def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n    L, R = 0, len(nums) - 1\n\n    while L &lt;= R:\n        mid = (L + R) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] &lt; target:\n            L = mid + 1\n        else:\n            R = mid - 1\n\n    return L\n</code></pre>"},{"location":"36/","title":"36. Valid Sudoku (Medium)","text":""},{"location":"36/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"36/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Valid Sudoku Examples ---\")\n\n# Test Case 1: Valid board (Partial fill, but valid structure)\nboard1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult1 = sol.isValidSudoku(board1)\nprint(\"Test 1 (Valid):\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n\n# Test Case 2: Invalid board (Duplicate in a row)\nboard2 = [\n    [\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n] # Row 0 has '8' and row 3 has '8' at col 0, which is fine.\n# Let's create a clear row violation:\nboard2_row_violation = [\n    [\"8\", \"8\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],  # Duplicate '8' in row 0\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult2 = sol.isValidSudoku(board2_row_violation)\nprint(\"\\nTest 2 (Row Violation):\")\nprint(f\"Output: {result2} (Expected: False)\")\n\n\n# Test Case 3: Invalid board (Duplicate in a 3x3 box)\nboard3_box_violation = [\n    [\"5\", \"3\", \".\", \"1\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \"1\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], # Duplicate '1' in box 0 (0,0 to 2,2)\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\nresult3 = sol.isValidSudoku(board3_box_violation)\nprint(\"\\nTest 3 (Box Violation):\")\nprint(f\"Output: {result3} (Expected: False)\")</pre> Output Clear <pre></pre> </p>"},{"location":"36/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n</code></pre>"},{"location":"36/#function-description","title":"Function Description","text":"Source code in <code>python/_36.py</code> <pre><code>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n</code></pre>"},{"location":"36/#_36.Solution.isValidSudoku","title":"<code>isValidSudoku(board)</code>","text":"Source code in <code>python/_36.py</code> <pre><code>def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for r in range(9):\n        for c in range(9):\n            char = board[r][c]\n            if char == '.':\n                continue\n\n            box_index = (r // 3) * 3 + (c // 3)\n\n            if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                return False\n\n            rows[r].add(char)\n            cols[c].add(char)\n            boxes[box_index].add(char)\n\n    return True\n</code></pre>"},{"location":"37/","title":"37. Sudoku Solver (Hard)","text":""},{"location":"37/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"37/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n        # 1. Initialize constraint sets\n        # row_constraints[r] is a set of digits present in row r\n        row_constraints = [set() for _ in range(9)]\n        # col_constraints[c] is a set of digits present in column c\n        col_constraints = [set() for _ in range(9)]\n        # box_constraints[b] is a set of digits present in box b (where b is 0-8)\n        # The box index b can be calculated as b = (r // 3) * 3 + (c // 3)\n        box_constraints = [set() for _ in range(9)]\n\n        # 2. Pre-fill the constraints and collect empty cells\n        empty_cells = []\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    row_constraints[r].add(val)\n                    col_constraints[c].add(val)\n                    box_constraints[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        # 3. Optimized validity check (O(1))\n        def is_valid_optimized(r, c, val):\n            box_idx = (r // 3) * 3 + (c // 3)\n            return (val not in row_constraints[r] and\n                    val not in col_constraints[c] and\n                    val not in box_constraints[box_idx])\n\n        # 4. Backtracking with constraint updates\n        def backtrack(k):\n            # Base case: All empty cells have been filled\n            if k == len(empty_cells):\n                return True\n\n            r, c = empty_cells[k]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            # Iterate through possible values '1' to '9'\n            for val_char in \"123456789\":\n                if is_valid_optimized(r, c, val_char):\n\n                    # Place the value and update constraints\n                    board[r][c] = val_char\n                    row_constraints[r].add(val_char)\n                    col_constraints[c].add(val_char)\n                    box_constraints[box_idx].add(val_char)\n\n                    # Recurse to the next empty cell\n                    if backtrack(k + 1):\n                        return True\n\n                    # Backtrack: Reset the cell and constraints\n                    board[r][c] = '.'\n                    row_constraints[r].remove(val_char)\n                    col_constraints[c].remove(val_char)\n                    box_constraints[box_idx].remove(val_char)\n\n            # If no value works for this cell, return False\n            return False\n\n        # Start backtracking from the first empty cell\n        backtrack(0)\n\n# --- Example Usage Code ---\n# (The usage code remains the same, just replace 'Solution' with 'SolutionOptimized')\n\nsol = Solution()\nprint(\"--- Sudoku Solver Examples (Optimized) ---\")\n\n# Test Case 1: Standard Sudoku puzzle\nboard1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n]\n\nprint(\"Input Board:\")\nfor row in board1:\n    print(row)\n\nsol.solveSudoku(board1)\n\nprint(\"\\nOutput Solved Board (Optimized):\")\nfor row in board1:\n    print(row)</pre> Output Clear <pre></pre> </p>"},{"location":"37/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n        row_constraints = [set() for _ in range(9)]\n        col_constraints = [set() for _ in range(9)]\n        box_constraints = [set() for _ in range(9)]\n\n        empty_cells = []\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    row_constraints[r].add(val)\n                    col_constraints[c].add(val)\n                    box_constraints[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        def is_valid_optimized(r, c, val):\n            box_idx = (r // 3) * 3 + (c // 3)\n            return (val not in row_constraints[r] and\n                    val not in col_constraints[c] and\n                    val not in box_constraints[box_idx])\n\n        def backtrack(k):\n            if k == len(empty_cells):\n                return True\n\n            r, c = empty_cells[k]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            for val_char in \"123456789\":\n                if is_valid_optimized(r, c, val_char):\n\n                    board[r][c] = val_char\n                    row_constraints[r].add(val_char)\n                    col_constraints[c].add(val_char)\n                    box_constraints[box_idx].add(val_char)\n\n                    if backtrack(k + 1):\n                        return True\n\n                    board[r][c] = '.'\n                    row_constraints[r].remove(val_char)\n                    col_constraints[c].remove(val_char)\n                    box_constraints[box_idx].remove(val_char)\n\n            return False\n\n        backtrack(0)\n</code></pre>"},{"location":"37/#function-description","title":"Function Description","text":"Source code in <code>python/_37.py</code> <pre><code>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n        row_constraints = [set() for _ in range(9)]\n        col_constraints = [set() for _ in range(9)]\n        box_constraints = [set() for _ in range(9)]\n\n        empty_cells = []\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val != '.':\n                    box_idx = (r // 3) * 3 + (c // 3)\n                    row_constraints[r].add(val)\n                    col_constraints[c].add(val)\n                    box_constraints[box_idx].add(val)\n                else:\n                    empty_cells.append((r, c))\n\n        def is_valid_optimized(r, c, val):\n            box_idx = (r // 3) * 3 + (c // 3)\n            return (val not in row_constraints[r] and\n                    val not in col_constraints[c] and\n                    val not in box_constraints[box_idx])\n\n        def backtrack(k):\n            if k == len(empty_cells):\n                return True\n\n            r, c = empty_cells[k]\n            box_idx = (r // 3) * 3 + (c // 3)\n\n            for val_char in \"123456789\":\n                if is_valid_optimized(r, c, val_char):\n\n                    board[r][c] = val_char\n                    row_constraints[r].add(val_char)\n                    col_constraints[c].add(val_char)\n                    box_constraints[box_idx].add(val_char)\n\n                    if backtrack(k + 1):\n                        return True\n\n                    board[r][c] = '.'\n                    row_constraints[r].remove(val_char)\n                    col_constraints[c].remove(val_char)\n                    box_constraints[box_idx].remove(val_char)\n\n            return False\n\n        backtrack(0)\n</code></pre>"},{"location":"37/#_37.Solution.solveSudoku","title":"<code>solveSudoku(board)</code>","text":"Source code in <code>python/_37.py</code> <pre><code>def solveSudoku(self, board: list[list[str]]) -&gt; None:\n    row_constraints = [set() for _ in range(9)]\n    col_constraints = [set() for _ in range(9)]\n    box_constraints = [set() for _ in range(9)]\n\n    empty_cells = []\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val != '.':\n                box_idx = (r // 3) * 3 + (c // 3)\n                row_constraints[r].add(val)\n                col_constraints[c].add(val)\n                box_constraints[box_idx].add(val)\n            else:\n                empty_cells.append((r, c))\n\n    def is_valid_optimized(r, c, val):\n        box_idx = (r // 3) * 3 + (c // 3)\n        return (val not in row_constraints[r] and\n                val not in col_constraints[c] and\n                val not in box_constraints[box_idx])\n\n    def backtrack(k):\n        if k == len(empty_cells):\n            return True\n\n        r, c = empty_cells[k]\n        box_idx = (r // 3) * 3 + (c // 3)\n\n        for val_char in \"123456789\":\n            if is_valid_optimized(r, c, val_char):\n\n                board[r][c] = val_char\n                row_constraints[r].add(val_char)\n                col_constraints[c].add(val_char)\n                box_constraints[box_idx].add(val_char)\n\n                if backtrack(k + 1):\n                    return True\n\n                board[r][c] = '.'\n                row_constraints[r].remove(val_char)\n                col_constraints[c].remove(val_char)\n                box_constraints[box_idx].remove(val_char)\n\n        return False\n\n    backtrack(0)\n</code></pre>"},{"location":"38/","title":"38. Count and Say (Easy)","text":""},{"location":"38/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"38/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Count and Say Sequence Examples ---\")\n\n# Test Case 1: n = 1\nn1 = 1\nresult1 = sol.countAndSay(n1)\nprint(f\"Input: n={n1}\")\nprint(f\"Output: '{result1}' (Expected: '1')\")\n\n# Test Case 2: n = 4\nn2 = 4\nresult2 = sol.countAndSay(n2)\n# n=1: 1\n# n=2: 11\n# n=3: 21\n# n=4: 1211\nprint(f\"\\nInput: n={n2}\")\nprint(f\"Output: '{result2}' (Expected: '1211')\")\n\n# Test Case 3: n = 5\nn3 = 5\nresult3 = sol.countAndSay(n3)\n# n=5: 111221\nprint(f\"\\nInput: n={n3}\")\nprint(f\"Output: '{result3}' (Expected: '111221')\")\n\n# Test Case 4: n = 6\nn4 = 6\nresult4 = sol.countAndSay(n4)\n# n=6: 312211\nprint(f\"\\nInput: n={n4}\")\nprint(f\"Output: '{result4}' (Expected: '312211')\")</pre> Output Clear <pre></pre> </p>"},{"location":"38/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n</code></pre>"},{"location":"38/#function-description","title":"Function Description","text":"Source code in <code>python/_38.py</code> <pre><code>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n</code></pre>"},{"location":"38/#_38.Solution.countAndSay","title":"<code>countAndSay(n)</code>","text":"Source code in <code>python/_38.py</code> <pre><code>def countAndSay(self, n: int) -&gt; str:\n\n    if n == 1:\n        return \"1\"\n\n    prev_sequence = self.countAndSay(n - 1)\n    result = []\n    i = 0\n\n    while i &lt; len(prev_sequence):\n        count = 1\n        j = i + 1\n        while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n            count += 1\n            j += 1\n        result.append(str(count) + prev_sequence[i])\n        i = j\n\n    return \"\".join(result)\n</code></pre>"},{"location":"39/","title":"39. Combination Sum (Medium)","text":""},{"location":"39/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"39/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Combination Sum Examples ---\")\n\n# Test Case 1: Standard case with reuse\ncandidates1 = [2, 3, 6, 7]\ntarget1 = 7\nresult1 = sol.combinationSum(candidates1, target1)\n# Expected: [[2, 2, 3], [7]]\nprint(f\"Input: candidates={candidates1}, target={target1}\")\nprint(f\"Output: {result1}\")\n\n# Test Case 2: Different candidates, multiple solutions\ncandidates2 = [2, 3, 5]\ntarget2 = 8\nresult2 = sol.combinationSum(candidates2, target2)\n# Expected: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\nprint(f\"\\nInput: candidates={candidates2}, target={target2}\")\nprint(f\"Output: {result2}\")\n\n# Test Case 3: Target unreachable\ncandidates3 = [2, 4]\ntarget3 = 7\nresult3 = sol.combinationSum(candidates3, target3)\n# Expected: []\nprint(f\"\\nInput: candidates={candidates3}, target={target3}\")\nprint(f\"Output: {result3}\")\n\n# Test Case 4: Single candidate\ncandidates4 = [1]\ntarget4 = 5\nresult4 = sol.combinationSum(candidates4, target4)\n# Expected: [[1, 1, 1, 1, 1]]\nprint(f\"\\nInput: candidates={candidates4}, target={target4}\")\nprint(f\"Output: {result4}\")</pre> Output Clear <pre></pre> </p>"},{"location":"39/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"39/#function-description","title":"Function Description","text":"Source code in <code>python/_39.py</code> <pre><code>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"39/#_39.Solution.combinationSum","title":"<code>combinationSum(candidates, target)</code>","text":"Source code in <code>python/_39.py</code> <pre><code>def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n    result = []\n\n    def backtrack(remainder, combination, start):\n        if remainder == 0:\n            result.append(list(combination))\n            return\n        if remainder &lt; 0:\n            return\n\n        for i in range(start, len(candidates)):\n            candidate = candidates[i]\n            combination.append(candidate)\n            backtrack(remainder - candidate, combination, i)\n            combination.pop()\n\n    backtrack(target, [], 0)\n    return result\n</code></pre>"},{"location":"4/","title":"4. Median of Two Sorted Arrays (Hard)","text":""},{"location":"4/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"4/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n\n# Example Usage:\nsol = Solution()\nprint(sol.findMedianSortedArrays([1, 3], [2]))       # Output: 2.0\nprint(sol.findMedianSortedArrays([1, 2], [3, 4]))    # Output: 2.5\nprint(sol.findMedianSortedArrays([0, 0], [0, 0]))    # Output: 0.0</pre> Output Clear <pre></pre> </p>"},{"location":"4/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"4/#function-description","title":"Function Description","text":"Source code in <code>python/_4.py</code> <pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        \"\"\"\n        Finds the median of two sorted arrays $nums1$ and $nums2$.\n\n        This method merges the problem of finding the median into a search problem \n        by using binary search to find the correct partition point in the smaller array.\n        The goal is to partition both arrays, $A$ and $B$, such that:\n        1. The total number of elements in the left partition is $\\lfloor (m+n+1)/2 \\rfloor$.\n        2. $\\max(Left\\_A) \\le \\min(Right\\_B)$ and $\\max(Left\\_B) \\le \\min(Right\\_A)$.\n\n\n\n        The median is then calculated based on whether the total length is odd or even:\n        - **Odd length:** $\\max(\\max(Left\\_A), \\max(Left\\_B))$\n        - **Even length:** $(\\max(\\max(Left\\_A), \\max(Left\\_B)) + \\min(\\min(Right\\_A), \\min(Right\\_B))) / 2$\n\n        The time complexity is $O(\\log(\\min(m, n)))$ because the binary search is \n        performed on the smaller array.\n\n        Args:\n            nums1: The first sorted list of integers.\n            nums2: The second sorted list of integers.\n\n        Returns:\n            The median of the two sorted arrays as a float.\n\n        Examples:\n            &gt;&gt;&gt; sol = Solution()\n            &gt;&gt;&gt; sol.findMedianSortedArrays([1, 3], [2])\n            2.0\n            &gt;&gt;&gt; sol.findMedianSortedArrays([1, 2], [3, 4])\n            2.5\n            &gt;&gt;&gt; sol.findMedianSortedArrays([1, 3, 8, 9, 15], [7, 11, 18, 19, 21, 25])\n            11.0\n        \"\"\"\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"4/#_4.Solution.findMedianSortedArrays","title":"<code>findMedianSortedArrays(nums1, nums2)</code>","text":"<p>Finds the median of two sorted arrays \\(nums1\\) and \\(nums2\\).</p> <p>This method merges the problem of finding the median into a search problem  by using binary search to find the correct partition point in the smaller array. The goal is to partition both arrays, \\(A\\) and \\(B\\), such that: 1. The total number of elements in the left partition is \\(\\lfloor (m+n+1)/2  floor\\). 2. \\(\\max(Left\\_A) \\le \\min(Right\\_B)\\) and \\(\\max(Left\\_B) \\le \\min(Right\\_A)\\).</p> <p>The median is then calculated based on whether the total length is odd or even: - Odd length: \\(\\max(\\max(Left\\_A), \\max(Left\\_B))\\) - Even length: \\((\\max(\\max(Left\\_A), \\max(Left\\_B)) + \\min(\\min(Right\\_A), \\min(Right\\_B))) / 2\\)</p> <p>The time complexity is \\(O(\\log(\\min(m, n)))\\) because the binary search is  performed on the smaller array.</p> <p>Parameters:</p> Name Type Description Default <code>nums1</code> <code>list[int]</code> <p>The first sorted list of integers.</p> required <code>nums2</code> <code>list[int]</code> <p>The second sorted list of integers.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The median of the two sorted arrays as a float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sol = Solution()\n&gt;&gt;&gt; sol.findMedianSortedArrays([1, 3], [2])\n2.0\n&gt;&gt;&gt; sol.findMedianSortedArrays([1, 2], [3, 4])\n2.5\n&gt;&gt;&gt; sol.findMedianSortedArrays([1, 3, 8, 9, 15], [7, 11, 18, 19, 21, 25])\n11.0\n</code></pre> Source code in <code>python/_4.py</code> <pre><code>def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n    \"\"\"\n    Finds the median of two sorted arrays $nums1$ and $nums2$.\n\n    This method merges the problem of finding the median into a search problem \n    by using binary search to find the correct partition point in the smaller array.\n    The goal is to partition both arrays, $A$ and $B$, such that:\n    1. The total number of elements in the left partition is $\\lfloor (m+n+1)/2 \\rfloor$.\n    2. $\\max(Left\\_A) \\le \\min(Right\\_B)$ and $\\max(Left\\_B) \\le \\min(Right\\_A)$.\n\n\n\n    The median is then calculated based on whether the total length is odd or even:\n    - **Odd length:** $\\max(\\max(Left\\_A), \\max(Left\\_B))$\n    - **Even length:** $(\\max(\\max(Left\\_A), \\max(Left\\_B)) + \\min(\\min(Right\\_A), \\min(Right\\_B))) / 2$\n\n    The time complexity is $O(\\log(\\min(m, n)))$ because the binary search is \n    performed on the smaller array.\n\n    Args:\n        nums1: The first sorted list of integers.\n        nums2: The second sorted list of integers.\n\n    Returns:\n        The median of the two sorted arrays as a float.\n\n    Examples:\n        &gt;&gt;&gt; sol = Solution()\n        &gt;&gt;&gt; sol.findMedianSortedArrays([1, 3], [2])\n        2.0\n        &gt;&gt;&gt; sol.findMedianSortedArrays([1, 2], [3, 4])\n        2.5\n        &gt;&gt;&gt; sol.findMedianSortedArrays([1, 3, 8, 9, 15], [7, 11, 18, 19, 21, 25])\n        11.0\n    \"\"\"\n    A, B = nums1, nums2\n    m, n = len(A), len(B)\n\n    if m &gt; n:\n        A, B = B, A\n        m, n = n, m\n\n    half_len = (m + n + 1) // 2\n\n    low = 0\n    high = m\n\n    while low &lt;= high:\n        partitionA = (low + high) // 2\n        partitionB = half_len - partitionA\n\n        maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n        minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n        maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n        minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n        if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n            if (m + n) % 2 == 1:\n                return max(maxLeftA, maxLeftB)\n            else:\n                return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n        elif maxLeftA &gt; minRightB:\n            high = partitionA - 1\n\n        else:\n            low = partitionA + 1\n\n    return 0.0\n</code></pre>"},{"location":"4/#explanation","title":"Explanation","text":"<p>You are given two integer arrays, <code>nums1</code> and <code>nums2</code>, with sizes \\(m\\) and \\(n\\) respectively. Both arrays are already sorted in ascending order. The task is to find and return the median value of the two sorted arrays when they are combined. This problem is classified as Hard due to the strict time complexity requirement for the optimal solution.</p> <p>The median is defined as the middle value in an ordered list of numbers. If the total number of elements, \\(m+n\\), is odd, the median is the single middle element. If the total number of elements is even, the median is the average (mean) of the two middle elements. For instance, for <code>[1, 2, 3]</code>, the median is \\(2\\); for <code>[1, 2, 3, 4]</code>, the median is \\((2+3)/2 = 2.5\\).</p> <p>The most crucial constraint is that your algorithm's overall run time complexity must be \\(O(\\log(m+n))\\) or better, typically achieved with \\(O(\\log(\\min(m, n)))\\). This logarithmic constraint prevents a simple \\(O(m+n)\\) solution that would merge both arrays entirely before calculating the median. Instead, the optimal solution leverages the sorted nature of the arrays and employs a binary search approach to efficiently find the correct partition point that isolates the elements needed to compute the median.</p>"},{"location":"4/#_1","title":"4. Median of Two Sorted Arrays (Hard)","text":""},{"location":"4/#_2","title":"4. Median of Two Sorted Arrays (Hard)","text":""},{"location":"40/","title":"40. Combination Sum II (Medium)","text":""},{"location":"40/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"40/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Combination Sum II Examples ---\")\n\n# Test Case 1: Duplicates in candidates\ncandidates1 = [10, 1, 2, 7, 6, 1, 5]\ntarget1 = 8\nresult1 = sol.combinationSum2(candidates1, target1)\n# After sorting: [1, 1, 2, 5, 6, 7, 10]\n# Expected: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\nprint(f\"Input: candidates={candidates1}, target={target1}\")\nprint(f\"Output: {result1}\")\n\n# Test Case 2: Duplicates in candidates (Simple case)\ncandidates2 = [2, 5, 2, 1, 2]\ntarget2 = 5\nresult2 = sol.combinationSum2(candidates2, target2)\n# After sorting: [1, 2, 2, 2, 5]\n# Expected: [[1, 2, 2], [5]]\nprint(f\"\\nInput: candidates={candidates2}, target={target2}\")\nprint(f\"Output: {result2}\")\n\n# Test Case 3: No combination found\ncandidates3 = [3, 4]\ntarget3 = 2\nresult3 = sol.combinationSum2(candidates3, target3)\n# Expected: []\nprint(f\"\\nInput: candidates={candidates3}, target={target3}\")\nprint(f\"Output: {result3}\")</pre> Output Clear <pre></pre> </p>"},{"location":"40/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"40/#function-description","title":"Function Description","text":"Source code in <code>python/_40.py</code> <pre><code>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"40/#_40.Solution.combinationSum2","title":"<code>combinationSum2(candidates, target)</code>","text":"Source code in <code>python/_40.py</code> <pre><code>def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n    candidates.sort()\n    result = []\n\n    def backtrack(remainder, combination, start):\n        if remainder == 0:\n            result.append(list(combination))\n            return\n        if remainder &lt; 0:\n            return\n\n        for i in range(start, len(candidates)):\n            if i &gt; start and candidates[i] == candidates[i-1]:\n                continue\n\n            candidate = candidates[i]\n            combination.append(candidate)\n            backtrack(remainder - candidate, combination, i + 1)\n            combination.pop()\n\n    backtrack(target, [], 0)\n    return result\n</code></pre>"},{"location":"41/","title":"41. First Missing Positive (Hard)","text":""},{"location":"41/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"41/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"41/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def firstMissingPositive(self, nums: list[int]) -&gt; int:\n        n = len(nums)\n        i = 0\n        while i &lt; n:\n            val = nums[i]\n            correct_idx = val - 1\n            if 1 &lt;= val &lt;= n and nums[correct_idx] != val:\n                nums[i], nums[correct_idx] = nums[correct_idx], nums[i]\n            else:\n                i += 1\n\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return n + 1\n</code></pre>"},{"location":"41/#function-description","title":"Function Description","text":"Source code in <code>python/_41.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"41/#_41.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_41.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"42/","title":"42. Trapping Rain Water (Hard)","text":""},{"location":"42/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"42/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"42/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def trap(self, height: list[int]) -&gt; int:\n        if not height:\n            return 0\n\n        total_water = 0\n        left = 0\n        right = len(height) - 1\n        maxL = height[left]\n        maxR = height[right]\n\n        while left &lt; right:\n            if maxL &lt; maxR:\n                left += 1\n                maxL = max(maxL, height[left])\n                total_water += maxL - height[left]\n            else:\n                right -= 1\n                maxR = max(maxR, height[right])\n                total_water += maxR - height[right]\n\n        return total_water\n</code></pre>"},{"location":"42/#function-description","title":"Function Description","text":"Source code in <code>python/_42.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"42/#_42.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_42.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"43/","title":"43. Multiply Strings (Medium)","text":""},{"location":"43/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"43/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"43/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def multiply(self, num1: str, num2: str) -&gt; str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m = len(num1)\n        n = len(num2)\n        pos = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                d1 = int(num1[i])\n                d2 = int(num2[j])\n\n                mult = d1 * d2\n\n                p1 = i + j\n                p2 = i + j + 1\n\n                s = mult + pos[p2]\n\n                pos[p1] += s // 10\n                pos[p2] = s % 10\n\n        result = []\n        for digit in pos:\n            if not (len(result) == 0 and digit == 0):\n                result.append(str(digit))\n\n        return \"\".join(result)\n</code></pre>"},{"location":"43/#function-description","title":"Function Description","text":"Source code in <code>python/_43.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"43/#_43.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_43.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"44/","title":"44. Wildcard Matching (Hard)","text":""},{"location":"44/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"44/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"44/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n        m = len(s)\n        n = len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"44/#function-description","title":"Function Description","text":"Source code in <code>python/_44.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"44/#_44.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_44.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"45/","title":"45. Jump Game II (Medium)","text":""},{"location":"45/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"45/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"45/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def jump(self, nums: list[int]) -&gt; int:\n        n = len(nums)\n        if n &lt;= 1:\n            return 0\n\n        jumps = 0\n        current_jump_end = 0\n        farthest = 0\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])\n\n            if i == current_jump_end:\n                jumps += 1\n                current_jump_end = farthest\n\n        return jumps\n</code></pre>"},{"location":"45/#function-description","title":"Function Description","text":"Source code in <code>python/_45.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"45/#_45.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_45.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"46/","title":"46. Permutations (Medium)","text":""},{"location":"46/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"46/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"46/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def permute(self, nums: list[int]) -&gt; list[list[int]]:\n        result = []\n\n        def backtrack(current_permutation):\n            if len(current_permutation) == len(nums):\n                result.append(list(current_permutation))\n                return\n\n            for num in nums:\n                if num not in current_permutation:\n                    current_permutation.append(num)\n                    backtrack(current_permutation)\n                    current_permutation.pop()\n\n        backtrack([])\n        return result\n</code></pre>"},{"location":"46/#function-description","title":"Function Description","text":"Source code in <code>python/_46.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"46/#_46.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_46.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"47/","title":"47. Permutations II (Medium)","text":""},{"location":"47/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"47/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"47/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def permuteUnique(self, nums: list[int]) -&gt; list[list[int]]:\n        nums.sort()\n        result = []\n        used = [False] * len(nums)\n\n        def backtrack(current_permutation):\n            if len(current_permutation) == len(nums):\n                result.append(list(current_permutation))\n                return\n\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n\n                if i &gt; 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue\n\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack(current_permutation)\n                current_permutation.pop()\n                used[i] = False\n\n        backtrack([])\n        return result\n</code></pre>"},{"location":"47/#function-description","title":"Function Description","text":"Source code in <code>python/_47.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"47/#_47.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_47.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"48/","title":"48. Rotate Image (Medium)","text":""},{"location":"48/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"48/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"48/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def rotate(self, matrix: list[list[int]]) -&gt; None:\n        n = len(matrix)\n\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        for i in range(n):\n            left = 0\n            right = n - 1\n            while left &lt; right:\n                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\n                left += 1\n                right -= 1\n</code></pre>"},{"location":"48/#function-description","title":"Function Description","text":"Source code in <code>python/_48.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"48/#_48.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_48.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"49/","title":"49. Group Anagrams (Medium)","text":""},{"location":"49/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"49/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"49/#solution","title":"Solution","text":"<pre><code>from collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: list[str]) -&gt; list[list[str]]:\n        anagrams = defaultdict(list)\n\n        for s in strs:\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n\n        return list(anagrams.values())\n</code></pre>"},{"location":"49/#function-description","title":"Function Description","text":"Source code in <code>python/_49.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"49/#_49.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_49.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"5/","title":"5. Longest Palindromic Substring (Medium)","text":""},{"location":"5/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"5/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n\n# --- Output Examples Code ---\n\nprint(\"--- Longest Palindromic Substring Examples ---\")\n\n# Create an instance of the Solution class\nsol = Solution()\n\n# Test Case 1: Odd length palindrome (bab or aba)\ns1 = \"babad\"\nresult1 = sol.longestPalindrome(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: '{result1}' (Expected: 'bab' or 'aba')\") \n\n# Test Case 2: Even length palindrome\ns2 = \"cbbd\"\nresult2 = sol.longestPalindrome(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: '{result2}' (Expected: 'bb')\")\n\n# Test Case 3: Whole string is a palindrome\ns3 = \"racecar\"\nresult3 = sol.longestPalindrome(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: '{result3}' (Expected: 'racecar')\")\n\n# Test Case 4: Long even length palindrome in the middle\ns4 = \"forgeeksskeegfor\"\nresult4 = sol.longestPalindrome(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: '{result4}' (Expected: 'geeksskeeg')\")\n\n# Test Case 5: Single character string\ns5 = \"x\"\nresult5 = sol.longestPalindrome(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: '{result5}' (Expected: 'x')\")\n\n# Test Case 6: Empty string\ns6 = \"\"\nresult6 = sol.longestPalindrome(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: '{result6}' (Expected: '')\")</pre> Output Clear <pre></pre> </p>"},{"location":"5/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"5/#function-description","title":"Function Description","text":"Source code in <code>python/_5.py</code> <pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"5/#_5.Solution.longestPalindrome","title":"<code>longestPalindrome(s)</code>","text":"Source code in <code>python/_5.py</code> <pre><code>def longestPalindrome(self, s: str) -&gt; str:\n\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest = \"\"\n    for i in range(len(s)):\n\n        # Odd length palindromes (center is s[i])\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) &gt; len(longest):\n            longest = palindrome1\n\n        # Even length palindromes (center is s[i] and s[i+1])\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) &gt; len(longest):\n            longest = palindrome2\n\n    return longest\n</code></pre>"},{"location":"5/#explanation","title":"Explanation","text":"<p>Given a string \\(s\\), the goal is to find the longest substring of \\(s\\) that is a palindrome. A palindrome is a sequence of characters that reads the same forwards and backwards. You can assume that the maximum length of \\(s\\) is 1000. If there are multiple palindromic substrings of the maximum length, any one of them can be returned as the correct answer. The challenge lies in efficiently identifying this longest substring.</p> <p>The most intuitive but less efficient approach is the Brute-Force method, which checks every possible substring for the palindrome property, leading to an \\(O(n^3)\\) time complexity. A more optimized approach involves dynamic programming, where \\(P(i, j)\\) is defined as true if the substring from index \\(i\\) to \\(j\\) is a palindrome, resulting in an \\(O(n^2)\\) solution. </p> <p>However, the most commonly discussed optimal \\(O(n^2)\\) solution is the Expand Around Center technique. In this method, we iterate through every possible character (and between every pair of characters) as the potential center of a palindrome. Since a palindrome can have an odd length (one center) or an even length (two centers), we check both cases and expand outwards from the center(s) as long as the characters match. This method effectively minimizes redundant checks and is often preferred for its conceptual simplicity. The most optimal solution is Manacher's Algorithm, which solves the problem in \\(O(n)\\) time.</p>"},{"location":"5/#_1","title":"5. Longest Palindromic Substring (Medium)","text":""},{"location":"5/#_2","title":"5. Longest Palindromic Substring (Medium)","text":""},{"location":"50/","title":"50. Pow(x, n) (Medium)","text":""},{"location":"50/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"50/#run","title":"Run","text":"<p> Editor (session: default) Run Output Clear </p>"},{"location":"50/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def myPow(self, x: float, n: int) -&gt; float:\n        if n == 0:\n            return 1.0\n\n        if n &lt; 0:\n            x = 1 / x\n            n = -n\n\n        result = 1.0\n\n        while n &gt; 0:\n            if n % 2 == 1:\n                result *= x\n            x *= x\n            n //= 2\n\n        return result\n</code></pre>"},{"location":"50/#function-description","title":"Function Description","text":"Source code in <code>python/_50.py</code> <pre><code>class Solution:\n    def method():\n        return\n</code></pre>"},{"location":"50/#_50.Solution.method","title":"<code>method()</code>","text":"Source code in <code>python/_50.py</code> <pre><code>def method():\n    return\n</code></pre>"},{"location":"50/#explanation","title":"Explanation","text":""},{"location":"6/","title":"6. Zigzag Conversion (Medium)","text":""},{"location":"6/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"6/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n\nsol = Solution()\nprint(\"--- Zigzag Conversion Examples ---\")\n\n# Test Case 1: Standard Example (numRows=3)\n# P   A   H   N\n# A P L S I I G\n# Y   I   R\ns1 = \"PAYPALISHIRING\"\nnumRows1 = 3\nresult1 = sol.convert(s1, numRows1)\n# Expected: \"PAHNAPLSIIGYIR\"\nprint(f\"Input: s='{s1}', numRows={numRows1}\")\nprint(f\"Output: '{result1}' (Expected: 'PAHNAPLSIIGYIR')\")\n\n# Test Case 2: Example with 4 rows\n# P     I     N\n# A   L S   I G\n# Y A   H R\n# P     I\ns2 = \"PAYPALISHIRING\"\nnumRows2 = 4\nresult2 = sol.convert(s2, numRows2)\n# Expected: \"PINALSIGYAHRPI\"\nprint(f\"Input: s='{s2}', numRows={numRows2}\")\nprint(f\"Output: '{result2}' (Expected: 'PINALSIGYAHRPI')\")\n# \n\n# Test Case 3: Simple 2-row case\ns3 = \"ABCDEFGH\"\nnumRows3 = 2\nresult3 = sol.convert(s3, numRows3)\n# Expected: \"ACEGBDFH\"\nprint(f\"Input: s='{s3}', numRows={numRows3}\")\nprint(f\"Output: '{result3}' (Expected: 'ACEGBDFH')\")\n\n# Test Case 4: numRows = 1 (Edge Case)\ns4 = \"ABCDE\"\nnumRows4 = 1\nresult4 = sol.convert(s4, numRows4)\n# Expected: \"ABCDE\"\nprint(f\"Input: s='{s4}', numRows={numRows4}\")\nprint(f\"Output: '{result4}' (Expected: 'ABCDE')\")\n\n# Test Case 5: numRows &gt;= len(s) (Edge Case)\ns5 = \"ABC\"\nnumRows5 = 5\nresult5 = sol.convert(s5, numRows5)\n# Expected: \"ABC\"\nprint(f\"Input: s='{s5}', numRows={numRows5}\")\nprint(f\"Output: '{result5}' (Expected: 'ABC')\")</pre> Output Clear <pre></pre> </p>"},{"location":"6/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"6/#function-description","title":"Function Description","text":"Source code in <code>python/_6.py</code> <pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"6/#_6.Solution.convert","title":"<code>convert(s, numRows)</code>","text":"Source code in <code>python/_6.py</code> <pre><code>def convert(self, s: str, numRows: int) -&gt; str:\n    if numRows == 1 or len(s) &lt;= numRows:\n        return s\n\n    rows = [''] * numRows\n    current_row = 0\n    going_down = False\n\n    for char in s:\n        rows[current_row] += char\n\n        if current_row == 0 or current_row == numRows - 1:\n            going_down = not going_down\n\n        if going_down:\n            current_row += 1\n        else:\n            current_row -= 1\n\n    return \"\".join(rows)\n</code></pre>"},{"location":"6/#explanation","title":"Explanation","text":"<p>The problem asks you to take a given string, \\(s\\), and convert it into a zigzag pattern (or Z-pattern) on a specified number of rows, \\(numRows\\). Once the string is written in this pattern, you must read it line by line from left to right, and return the resulting new string. For example, converting \"PAYPALISHIRING\" with \\(numRows = 3\\) yields the pattern: P A H N, A P L S I I G, Y I R, which, when read row-by-row, becomes \"PAHNAPLSIIGYIR\". </p> <p>The core of the challenge is to determine the correct row index for each character in the input string without actually creating a 2D matrix, especially since the constraints on \\(s\\) are up to 1000 characters. The pattern repeats in a cycle, where a full cycle covers \\(numRows\\) down and then \\(numRows - 2\\) up and diagonally. The length of one complete cycle is \\(2 \\times numRows - 2\\). For \\(numRows = 3\\), the cycle length is \\(2 \\times 3 - 2 = 4\\).</p> <p>An efficient \\(O(n)\\) solution involves iterating through the input string \\(s\\) once and placing each character directly into its final row in an array of strings (or a list of <code>StringBuilder</code> objects). You can track the current row index and a direction flag (down or up). When the current row hits the bottom (row \\(numRows - 1\\)), the direction reverses to 'up'. When it hits the top (row 0), the direction reverses to 'down'. After iterating through all characters, simply concatenate the strings in the row array to produce the final zigzag-converted output.</p>"},{"location":"6/#_1","title":"6. Zigzag Conversion (Medium)","text":""},{"location":"6/#_2","title":"6. Zigzag Conversion (Medium)","text":""},{"location":"7/","title":"7. Reverse Integer (Easy)","text":""},{"location":"7/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"7/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n\nsol = Solution()\nprint(\"--- Reverse Integer Examples ---\")\n\n# Test Case 1: Positive number\nx1 = 123\nresult1 = sol.reverse(x1)\nprint(f\"Input: {x1}\")\nprint(f\"Output: {result1} (Expected: 321)\")\n\n# Test Case 2: Negative number\nx2 = -123\nresult2 = sol.reverse(x2)\nprint(f\"Input: {x2}\")\nprint(f\"Output: {result2} (Expected: -321)\")\n\n# Test Case 3: Number with trailing zeros\nx3 = 120\nresult3 = sol.reverse(x3)\nprint(f\"Input: {x3}\")\nprint(f\"Output: {result3} (Expected: 21)\")\n\n# Test Case 4: Positive Overflow Check (Max is 2147483647)\n# Reversing 1534236469 gives 9646324351, which exceeds INT_MAX\nx4 = 1534236469 \nresult4 = sol.reverse(x4)\nprint(f\"Input: {x4}\")\nprint(f\"Output: {result4} (Expected: 0 - Overflow)\")\n\n# Test Case 5: Negative Overflow Check (Min is -2147483648)\n# Reversing -1534236469 gives -9646324351, which is less than INT_MIN\nx5 = -1534236469\nresult5 = sol.reverse(x5)\nprint(f\"Input: {x5}\")\nprint(f\"Output: {result5} (Expected: 0 - Overflow)\")\n\n# Test Case 6: Exact INT_MAX reversal (No Overflow)\n# Reversing 1463847412 (214748364 * 10 + 7) -&gt; 2147483641\nx6 = 1463847412 # Just a large number whose reverse is safe\nresult6 = sol.reverse(x6)\nprint(f\"Input: {x6}\")\nprint(f\"Output: {result6} (Expected: 2147483641)\")</pre> Output Clear <pre></pre> </p>"},{"location":"7/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"7/#function-description","title":"Function Description","text":"Source code in <code>python/_7.py</code> <pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"7/#_7.Solution.reverse","title":"<code>reverse(x)</code>","text":"Source code in <code>python/_7.py</code> <pre><code>def reverse(self, x: int) -&gt; int:\n\n    INT_MAX = 2147483647\n    INT_MIN = -2147483648\n\n    reversed_x = 0\n\n    while x != 0:\n        digit = x % 10\n        if x &lt; 0 and digit &gt; 0:\n            digit -= 10\n\n        x = (x - digit) // 10\n\n        if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n            return 0\n\n        if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n            return 0\n\n        reversed_x = reversed_x * 10 + digit\n\n    return reversed_x\n</code></pre>"},{"location":"7/#explanation","title":"Explanation","text":"<p>Given a signed 32-bit integer, \\(x\\), the task is to return its digits reversed. For example, if \\(x = 123\\), the output should be \\(321\\). If \\(x = -123\\), the output should be \\(-321\\). The number's sign must be preserved in the reversed result. The input integer \\(x\\) is within the range \\([-(2^{31}), 2^{31} - 1]\\), which defines the limits of a standard 32-bit signed integer.</p> <p>The primary difficulty in this problem is handling integer overflow. The reversed integer might exceed the maximum value of a 32-bit signed integer (\\(2^{31} - 1\\)) or fall below its minimum value (\\(-(2^{31})\\)), even if the original number \\(x\\) was within range. For example, reversing \\(1,534,236,469\\) results in \\(9,646,324,351\\), which is larger than \\(2,147,483,647\\). Therefore, before appending the next digit, a check must be performed to ensure the current reversed number, multiplied by 10 and added to the new digit, does not cause an overflow.</p> <p>The most robust approach involves iteratively extracting the last digit of \\(x\\) using the modulo operator (\\(x \\pmod{10}\\)) and building the reversed number. In each iteration, we check for potential overflow before the multiplication step. Specifically, if <code>reversed &gt; INT_MAX / 10</code> (or <code>reversed &lt; INT_MIN / 10</code>), we know the next multiplication will definitely overflow. If it's on the edge (e.g., <code>reversed == INT_MAX / 10</code>), we then check the last digit itself to see if it causes the final overflow. If an overflow is detected at any point, the function must immediately return \\(0\\).</p>"},{"location":"7/#_1","title":"7. Reverse Integer (Easy)","text":""},{"location":"7/#_2","title":"7. Reverse Integer (Easy)","text":""},{"location":"8/","title":"8. String to Integer (atoi) (Medium)","text":""},{"location":"8/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"8/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- String to Integer (atoi) Examples ---\")\n\n# Test Case 1: Standard positive conversion\ns1 = \"42\"\nresult1 = sol.myAtoi(s1)\nprint(f\"Input: '{s1}'\")\nprint(f\"Output: {result1} (Expected: 42)\")\n\n# Test Case 2: Conversion with leading whitespace and sign\ns2 = \"   -42\"\nresult2 = sol.myAtoi(s2)\nprint(f\"Input: '{s2}'\")\nprint(f\"Output: {result2} (Expected: -42)\")\n\n# Test Case 3: Conversion with non-digit characters after the number\ns3 = \"4193 with words\"\nresult3 = sol.myAtoi(s3)\nprint(f\"Input: '{s3}'\")\nprint(f\"Output: {result3} (Expected: 4193)\")\n\n# Test Case 4: No valid number found\ns4 = \"words and 987\"\nresult4 = sol.myAtoi(s4)\nprint(f\"Input: '{s4}'\")\nprint(f\"Output: {result4} (Expected: 0)\")\n\n# Test Case 5: Positive Overflow (Should return INT_MAX: 2147483647)\ns5 = \"91283472332\"\nresult5 = sol.myAtoi(s5)\nprint(f\"Input: '{s5}'\")\nprint(f\"Output: {result5} (Expected: 2147483647)\")\n\n# Test Case 6: Negative Overflow (Should return INT_MIN: -2147483648)\ns6 = \"-91283472332\"\nresult6 = sol.myAtoi(s6)\nprint(f\"Input: '{s6}'\")\nprint(f\"Output: {result6} (Expected: -2147483648)\")\n\n# Test Case 7: Only sign\ns7 = \"+\"\nresult7 = sol.myAtoi(s7)\nprint(f\"Input: '{s7}'\")\nprint(f\"Output: {result7} (Expected: 0)\")\n\n# Test Case 8: Exact positive boundary\ns8 = \"2147483647\"\nresult8 = sol.myAtoi(s8)\nprint(f\"Input: '{s8}'\")\nprint(f\"Output: {result8} (Expected: 2147483647)\")\n\n# Test Case 9: Exact negative boundary\ns9 = \"-2147483648\"\nresult9 = sol.myAtoi(s9)\nprint(f\"Input: '{s9}'\")\nprint(f\"Output: {result9} (Expected: -2147483648)\")</pre> Output Clear <pre></pre> </p>"},{"location":"8/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"8/#function-description","title":"Function Description","text":"Source code in <code>python/_8.py</code> <pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"8/#_8.Solution.myAtoi","title":"<code>myAtoi(s)</code>","text":"Source code in <code>python/_8.py</code> <pre><code>def myAtoi(self, s: str) -&gt; int:\n\n    s = s.lstrip()\n    if not s:\n        return 0\n\n    sign = 1\n    i = 0\n\n    if s[0] == '+':\n        i += 1\n    elif s[0] == '-':\n        sign = -1\n        i += 1\n\n    result = 0\n    INT_MAX = 2147483647\n    INT_MIN = -2147483648\n\n    while i &lt; len(s) and s[i].isdigit():\n        digit = int(s[i])\n\n        if sign == 1:\n            if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                return INT_MAX\n        else:\n            if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                return INT_MIN\n\n        result = result * 10 + digit\n        i += 1\n\n    return result * sign\n</code></pre>"},{"location":"8/#explanation","title":"Explanation","text":"<p>The \"String to Integer (atoi)\" problem requires implementing the logic to convert a string into a 32-bit signed integer, adhering to specific rules. The function should first discard any leading whitespace characters until the first non-whitespace character is found. Next, this character may be an optional sign ('+' or '-'). Finally, the function must read in as many numerical digits as possible until a non-digit character is encountered or the end of the input string is reached. The resulting digits are then interpreted as an integer.</p> <p>A crucial part of the implementation is handling all possible edge cases and constraints. If the first non-whitespace character is not a sign or a digit, no valid conversion can be performed, and \\(0\\) should be returned. The problem requires clamping the result to fit within the range of a 32-bit signed integer, which is \\([-(2^{31}), 2^{31} - 1]\\). If the numerical value exceeds the maximum limit, the function must return \\(2^{31} - 1\\) (<code>INT_MAX</code>). If it falls below the minimum limit, it must return \\(-(2^{31})\\) (<code>INT_MIN</code>).</p> <p>The conversion itself is best done by iterating through the numeric digits, similar to problem 7, and continuously building the result while simultaneously checking for overflow or underflow at each step. This process involves multiplying the current result by \\(10\\) and adding the next digit. To ensure \\(O(1)\\) space complexity, the use of auxiliary data structures should be avoided. The overall time complexity for this process is \\(O(n)\\), where \\(n\\) is the length of the string, as we only perform a single pass over the string.</p>"},{"location":"8/#_1","title":"8. String to Integer (atoi) (Medium)","text":""},{"location":"8/#_2","title":"8. String to Integer (atoi) (Medium)","text":""},{"location":"9/","title":"9. Palindrome Number (Easy)","text":""},{"location":"9/#pyodide","title":"Pyodide","text":"<p> Editor (session: default) Run <pre># Type here\n\n</pre> Output Clear <pre></pre> </p>"},{"location":"9/#run","title":"Run","text":"<p> Editor (session: default) Run <pre>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n\n# --- Example Usage Code ---\n\nsol = Solution()\nprint(\"--- Palindrome Number Examples ---\")\n\n# Test Case 1: Standard Palindrome (Odd number of digits)\nx1 = 121\nresult1 = sol.isPalindrome(x1)\nprint(f\"Input: {x1}\")\nprint(f\"Output: {result1} (Expected: True)\")\n\n# Test Case 2: Standard Palindrome (Even number of digits)\nx2 = 1221\nresult2 = sol.isPalindrome(x2)\nprint(f\"Input: {x2}\")\nprint(f\"Output: {result2} (Expected: True)\")\n\n# Test Case 3: Not a Palindrome\nx3 = 10\nresult3 = sol.isPalindrome(x3)\nprint(f\"Input: {x3}\")\nprint(f\"Output: {result3} (Expected: False - Fails condition 2)\")\n\n# Test Case 4: Not a Palindrome (Mismatch)\nx4 = 123\nresult4 = sol.isPalindrome(x4)\nprint(f\"Input: {x4}\")\nprint(f\"Output: {result4} (Expected: False)\")\n\n# Test Case 5: Negative Number (Fails condition 1)\nx5 = -121\nresult5 = sol.isPalindrome(x5)\nprint(f\"Input: {x5}\")\nprint(f\"Output: {result5} (Expected: False)\")\n\n# Test Case 6: Zero (Palindrome)\nx6 = 0\nresult6 = sol.isPalindrome(x6)\nprint(f\"Input: {x6}\")\nprint(f\"Output: {result6} (Expected: True)\")</pre> Output Clear <pre></pre> </p>"},{"location":"9/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"},{"location":"9/#function-description","title":"Function Description","text":"Source code in <code>python/_9.py</code> <pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"},{"location":"9/#_9.Solution.isPalindrome","title":"<code>isPalindrome(x)</code>","text":"Source code in <code>python/_9.py</code> <pre><code>def isPalindrome(self, x: int) -&gt; bool:\n\n    if x &lt; 0 or (x % 10 == 0 and x != 0):\n        return False\n\n    reverted_number = 0\n    while x &gt; reverted_number:\n        reverted_number = reverted_number * 10 + x % 10\n        x //= 10\n\n    return x == reverted_number or x == reverted_number // 10\n</code></pre>"},{"location":"9/#explanation","title":"Explanation","text":""},{"location":"9/#9-palindrome-number-easy","title":"9. Palindrome Number (Easy)","text":"<p>Given an integer \\(x\\), the task is to determine whether it is a palindrome. An integer is considered a palindrome if it reads the same forwards and backwards. This definition means that negative numbers, such as \\(-121\\), cannot be palindromes because the negative sign only appears at the front, so we can immediately return <code>false</code> for any \\(x &lt; 0\\). Additionally, any number ending in \\(0\\) (except for \\(0\\) itself) cannot be a palindrome, as the reversed number would start with \\(0\\) (e.g., \\(120\\) reversed is \\(021\\)).</p> <p>The most straightforward method to check for a palindrome is to convert the integer into a string. Once in string format, the check is simple: compare the string with its reversed version. However, the problem often includes a \"Follow up\" to solve it without converting the integer to a string. This requires a numerical approach, typically by either reversing the entire number, as done in problem 7, or by reversing only half of the number to avoid potential overflow issues that can occur when reversing large integers entirely.</p> <p>The most optimized numerical solution is to reverse only the second half of the integer. We continuously pop the last digit of \\(x\\) and push it onto a new number, <code>reversed_half</code>, until <code>reversed_half</code> is greater than or equal to \\(x\\). At this point, we have reversed approximately half of the digits. If the original number \\(x\\) had an even number of digits, \\(x\\) must equal <code>reversed_half</code>. If \\(x\\) had an odd number of digits, the middle digit is naturally ignored, and we check if \\(x\\) equals <code>reversed_half / 10</code>.</p>"},{"location":"9/#_1","title":"9. Palindrome Number (Easy)","text":""},{"location":"9/#_2","title":"9. Palindrome Number (Easy)","text":""},{"location":"pyodide/","title":"Pyodide","text":"<p> Editor (session: default) Run <pre>\n# Leetcode 2 Verbose\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n            print(f\"(new_digit) {new_digit}: (total_sum) {total_sum} = (Val1) {val1} + (Val2) {val2} + (carry) {carry}\")\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n\n# Helper function to convert a list of digits to a linked list (in reverse order)\ndef create_linked_list(digits):\n    dummy_head = ListNode(0)\n    current = dummy_head\n    for digit in digits:\n        current.next = ListNode(digit)\n        current = current.next\n    return dummy_head.next\n\n# Helper function to convert a linked list to a list of digits\ndef linked_list_to_list(node):\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\n\n# Example 1: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) -&gt; (7 -&gt; 0 -&gt; 8)\nl1_ex1 = create_linked_list([2, 4, 3])\nl2_ex1 = create_linked_list([5, 6, 4])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex1, l2_ex1)), \"\\n\")\n\n# Example 2: (0) + (0) -&gt; (0)\nl1_ex2 = create_linked_list([0])\nl2_ex2 = create_linked_list([0])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex2, l2_ex2)), \"\\n\")\n\n# Example 3: (9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9) + (9 -&gt; 9 -&gt; 9 -&gt; 9) -&gt; (8 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 1)\nl1_ex3 = create_linked_list([9, 9, 9, 9, 9, 9, 9])\nl2_ex3 = create_linked_list([9, 9, 9, 9])\nprint(linked_list_to_list(Solution().addTwoNumbers(l1_ex3, l2_ex3)))\n</pre> Output Clear <pre></pre> </p>"}]}