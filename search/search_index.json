{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeetCode Python","text":"<p>This repository holds my Python solutions for various LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment.</p> <p>Static site generation is done with Python Make Docs.</p> <p>View source code here or on GitHub</p> <p>Luke Clark</p> <p>Contact at me lukeclarksf@gmail.com</p> <p>Look at my CV</p>"},{"location":"1/","title":"Problem 1","text":"<pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#leetcode-problem-1-two-sum","title":"\ud83d\udca1 LeetCode Problem 1: Two Sum","text":""},{"location":"1/#problem-description","title":"Problem Description","text":"<p>Given an array of integers, <code>nums</code>, and an integer, <code>target</code>, return the indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>"},{"location":"1/#example","title":"Example","text":"<ul> <li>Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code></li> <li>Output: <code>[0, 1]</code></li> <li>Explanation: Because <code>nums[0] + nums[1] == 9</code>, we return <code>[0, 1]</code>.</li> </ul>"},{"location":"1/#approaches","title":"Approaches","text":"<p>There are a few ways to solve this problem, but the most efficient uses a Hash Map (or dictionary).</p>"},{"location":"1/#1-brute-force-inefficient","title":"1. Brute Force (Inefficient)","text":"<p>The simplest approach is to check every possible pair of numbers.</p> <ul> <li>Use a nested loop. The outer loop iterates from the first element up to the second-to-last element (<code>i</code>).</li> <li>The inner loop iterates from the element after the outer loop's current element up to the last element (<code>j</code>).</li> <li>In the inner loop, check if <code>nums[i] + nums[j]</code> equals <code>target</code>. If it does, return <code>[i, j]</code>.</li> </ul> Complexity Time Space Worst-Case \\(O(n^2)\\) \\(O(1)\\)"},{"location":"1/#2-two-pass-hash-map","title":"2. Two-Pass Hash Map","text":"<p>We can use a Hash Map to reduce the time complexity. A Hash Map allows us to look up an element in \\(O(1)\\) time on average.</p> <ol> <li>First Pass (Build Map): Iterate through the <code>nums</code> array and store each element's value as the key and its index as the value in the Hash Map.</li> <li>Second Pass (Find Complement): Iterate through the <code>nums</code> array again.<ul> <li>For the current number, \\(n_i = nums[i]\\), calculate the complement needed: \\(c = target - n_i\\).</li> <li>Check if the complement, \\(c\\), exists as a key in the Hash Map.</li> <li>Crucially: Ensure the index stored for the complement is not the current index \\(i\\).</li> <li>If the complement is found, return the current index \\(i\\) and the index stored in the map.</li> </ul> </li> </ol> Complexity Time Space Worst-Case \\(O(n)\\) \\(O(n)\\)"},{"location":"1/#3-one-pass-hash-map-optimal","title":"3. One-Pass Hash Map (Optimal)","text":"<p>We can combine the two passes into a single pass for optimal performance.</p> <ol> <li>Initialize an empty Hash Map.</li> <li>Iterate through the <code>nums</code> array with index \\(i\\).</li> <li>For the current number, \\(n_i = nums[i]\\), calculate the complement needed: \\(c = target - n_i\\).</li> <li>Check if the complement, \\(c\\), already exists as a key in the Hash Map.<ul> <li>If Found: We have found the solution! Return the complement's index (from the map) and the current index \\(i\\).</li> <li>If Not Found: Add the current number \\(n_i\\) and its index \\(i\\) to the Hash Map.</li> </ul> </li> </ol> <p>This works because by the time we check for the complement \\(c\\), any element that could be \\(c\\) has already been processed and stored in the map, unless \\(n_i\\) is its own complement (which is handled by the map not containing the current element's index).</p> Complexity Time Space Worst-Case \\(O(n)\\) \\(O(n)\\) ---"},{"location":"1/#why-the-one-pass-hash-map-is-optimal","title":"Why the One-Pass Hash Map is Optimal","text":"<p>The one-pass approach maintains the \\(O(n)\\) time complexity of the Two-Pass approach but only requires a single iteration through the list, making it generally faster in practice and the preferred solution. Both approaches trade extra \\(O(n)\\) space for a significant improvement in time complexity from \\(O(n^2)\\) to \\(O(n)\\).</p>"},{"location":"10/","title":"Problem 10","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"11/","title":"Problem 11","text":"<pre><code>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n</code></pre>"},{"location":"12/","title":"Problem 12","text":""},{"location":"13/","title":"Problem 13","text":""},{"location":"14/","title":"Problem 14","text":""},{"location":"15/","title":"Problem 15","text":""},{"location":"16/","title":"Problem 16","text":""},{"location":"17/","title":"Problem 17","text":""},{"location":"18/","title":"Problem 18","text":""},{"location":"19/","title":"Problem 19","text":""},{"location":"2/","title":"Problem 2","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#leetcode-problem-2-add-two-numbers","title":"\u26d3\ufe0f LeetCode Problem 2: Add Two Numbers","text":""},{"location":"2/#problem-description","title":"Problem Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>"},{"location":"2/#example","title":"Example","text":"<ul> <li>Input: <code>l1 = [2, 4, 3]</code>, <code>l2 = [5, 6, 4]</code></li> <li>Interpretation: <code>l1</code> represents the number 342, and <code>l2</code> represents the number 465.</li> <li>Calculation: 342 + 465 = 807</li> <li>Output: <code>[7, 0, 8]</code> (representing the number 807)</li> </ul>"},{"location":"2/#optimal-approach-iteration-with-carry","title":"Optimal Approach: Iteration with Carry","text":"<p>The most efficient solution is a single-pass iteration that simulates the manual process of adding numbers column by column, keeping track of any \"carry.\"</p>"},{"location":"2/#core-idea","title":"Core Idea","text":"<ol> <li>Initialize: Create a dummy head node for the result list and a pointer (<code>current</code>) to build the list. Initialize a <code>carry</code> variable to 0.</li> <li>Iterate: Loop while there are still digits in either list (<code>l1</code> or <code>l2</code>) or the <code>carry</code> is greater than 0.</li> <li>Sum Digits:<ul> <li>Get the value of the current node from <code>l1</code> (or 0 if <code>l1</code> is exhausted).</li> <li>Get the value of the current node from <code>l2</code> (or 0 if <code>l2</code> is exhausted).</li> <li>Calculate the <code>total_sum = val1 + val2 + carry</code>.</li> </ul> </li> <li>Update Carry and Digit:<ul> <li>The new <code>carry</code> is the integer division of the <code>total_sum</code> by 10 (e.g., \\(15 / 10 = 1\\)).</li> <li>The new digit is the remainder of the <code>total_sum</code> divided by 10 (e.g., \\(15 \\pmod{10} = 5\\)).</li> </ul> </li> <li>Build List: Create a new node with the calculated digit and append it to the <code>current</code> pointer in the result list. Move the <code>current</code> pointer forward.</li> <li>Advance Pointers: Move <code>l1</code> and <code>l2</code> to their next nodes (if they exist).</li> </ol>"},{"location":"2/#handling-the-final-carry","title":"Handling the Final Carry","text":"<p>The loop must continue as long as a carry exists. If, after processing the last digits of <code>l1</code> and <code>l2</code>, the <code>carry</code> is 1 (e.g., adding \\(99+1\\)), you must create one final node to hold that carry.</p> Complexity Time Space Worst-Case \\(O(\\max(m, n))\\) \\(O(\\max(m, n))\\) <ul> <li>Where \\(m\\) and \\(n\\) are the lengths</li> </ul>"},{"location":"20/","title":"Problem 20","text":""},{"location":"21/","title":"Problem 21","text":""},{"location":"22/","title":"Problem 22","text":""},{"location":"23/","title":"Problem 23","text":""},{"location":"24/","title":"Problem 24","text":""},{"location":"25/","title":"Problem 25","text":""},{"location":"26/","title":"Problem 26","text":""},{"location":"27/","title":"Problem 27","text":""},{"location":"28/","title":"Problem 28","text":""},{"location":"29/","title":"Problem 29","text":""},{"location":"3/","title":"Problem 3","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"30/","title":"Problem 30","text":""},{"location":"31/","title":"Problem 31","text":""},{"location":"32/","title":"Problem 32","text":""},{"location":"33/","title":"Problem 33","text":""},{"location":"34/","title":"Problem 34","text":""},{"location":"35/","title":"Problem 35","text":""},{"location":"36/","title":"Problem 36","text":""},{"location":"37/","title":"Problem 37","text":""},{"location":"38/","title":"Problem 38","text":""},{"location":"39/","title":"Problem 39","text":""},{"location":"4/","title":"Problem 4","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"40/","title":"Problem 40","text":""},{"location":"5/","title":"Problem 5","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"6/","title":"Problem 6","text":"<pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"7/","title":"Problem 7","text":"<pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"8/","title":"Problem 8","text":"<pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"9/","title":"Problem 9","text":"<pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"}]}