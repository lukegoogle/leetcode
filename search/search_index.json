{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeetCode Python","text":"<p>This repository holds my Python solutions for various LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment.</p> <p>Static site generation is done with Python Make Docs.</p> <p>View source code here or on GitHub</p> <p>Luke Clark</p> <p>Contact at me lukeclarksf@gmail.com</p> <p>Look at my CV</p>"},{"location":"#ivy-league-logos-3-images","title":"Ivy League Logos (3 Images)","text":""},{"location":"1/","title":"Problem 1","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"1/#two-sum","title":"\ud83d\udca1 Two Sum","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>"},{"location":"1/#example-1","title":"Example 1:","text":"<ul> <li>Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code></li> <li>Output: <code>[0, 1]</code></li> <li>Explanation: Because $\\text{nums}[0] + \\text{nums}[1] == 9$, we return <code>[0, 1]</code>.</li> </ul>"},{"location":"1/#optimal-approach-one-pass-hash-map","title":"\ud83d\ude80 Optimal Approach: One-Pass Hash Map","text":""},{"location":"1/#intuition","title":"Intuition","text":"<p>The goal is to find the complement ($\\text{target} - \\text{nums}[i]$) for every number $\\text{nums}[i]$ in the array. Using a Hash Map (or Dictionary) is the key to achieving $O(n)$ time complexity. A hash map allows us to store elements we've seen and check for the complement's existence in $O(1</p>"},{"location":"2/","title":"LeetCode Problem 2: Add Two Numbers","text":"Attribute Value Title Add Two Numbers Difficulty Medium Topics Linked List, Math URL LeetCode 2"},{"location":"2/#problem-description","title":"\u2753 Problem Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list (also in reverse order).</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>"},{"location":"2/#example","title":"Example","text":"<p>Input: <code>l1 = [2,4,3]</code>, <code>l2 = [5,6,4]</code> Output: <code>[7,0,8]</code> Explanation: $342 + 465 = 807$. The output list represents $807$ in reverse.</p>"},{"location":"2/#solution-approach-simulation-of-grade-school-addition","title":"\ud83d\udca1 Solution Approach: Simulation of Grade-School Addition","text":"<p>The structure of the input\u2014digits in reverse order\u2014is key. It means the head of the list corresponds to the ones place, allowing us to perform long addition by traversing the lists simultaneously from head to tail.</p>"},{"location":"2/#the-iterative-process","title":"The Iterative Process","text":"<p>We use an iterative approach, maintaining a <code>carry</code> variable to handle overflow whenever the sum of the digits exceeds $9$.</p> <ol> <li>Initialize: A <code>dummy</code> node is created to anchor the result list, and a <code>current</code> pointer tracks the tail of the sum list. <code>carry</code> is set to $0$.</li> <li>Iterate: We loop until both lists are exhausted AND the <code>carry</code> is $0$.</li> <li>Summation: In each step, we calculate the sum of the current digits from $l1$ and $l2$ (using $0$ if a list is exhausted) plus the incoming <code>carry</code>.</li> <li>Result &amp; Carry Update:<ul> <li>The digit for the new node is $sum \\pmod{10}$.</li> <li>The new <code>carry</code> is $sum // 10$.</li> </ul> </li> <li>List Building: A new node is created with the result digit and appended to the result list via the <code>current</code> pointer.</li> </ol>"},{"location":"2/#python-implementation","title":"\ud83d\udcbb Python Implementation","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    \"\"\"\n    Adds two numbers represented by linked lists.\n    \"\"\"\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:\n        # Create a dummy node to simplify list construction\n        dummy = ListNode(0)\n        current = dummy\n        carry = 0\n\n        # Loop continues if either list has nodes OR there is a remaining carry\n        while l1 is not None or l2 is not None or carry != 0:\n\n            # Get the values, defaulting to 0 if the list is finished\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n\n            # Calculate the total sum for the current position\n            sum_val = x + y + carry\n\n            # Determine the new carry and the digit for the result node\n            carry = sum_val // 10\n            new_digit = sum_val % 10\n\n            # Create and append the new node\n            current.next = ListNode(new_digit)\n\n            # Move the pointers forward\n            current = current.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n\n        # The result starts immediately after the dummy node\n        return dummy.next\n</code></pre>"},{"location":"3/","title":"Problem 3","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"4/","title":"Problem 4","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"}]}