{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LeetCode Python","text":"<p>This repository holds my Python solutions for various LeetCode problems, typically developed and tested within the Visual Studio Code integrated development environment.</p> <p>Static site generation is done with Python Make Docs.</p> <p>View source code here or on GitHub</p> <p>Luke Clark</p> <p>Contact at me lukeclarksf@gmail.com</p> <p>Look at my CV</p>"},{"location":"1/","title":"Problem 1","text":"<pre><code>class Solution:\n    def twoSum(self, nums: list[int], target: int) -&gt; list[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n\n        return []\n</code></pre>"},{"location":"1/#1-two-sum","title":"1. Two Sum","text":""},{"location":"1/#problem-statement-and-core-objective","title":"Problem Statement and Core Objective","text":"<p>The LeetCode Two Sum problem, designated as problem number 1, is a foundational question in computer science that introduces key concepts in algorithm design, particularly focusing on efficient searching and data structures. The primary objective is straightforward: given an array of integers, let's call it <code>nums</code>, and a specific target integer, the task is to identify and return the indices of two distinct numbers within <code>nums</code> whose sum equals the <code>target</code>.</p> <p>It is typically specified that the input array will contain exactly one valid solution pair, simplifying the process by eliminating the need to handle multiple possible answers or the non-existence of a solution. Furthermore, the constraint \"you may not use the same element twice\" means that even if an array contains duplicates (e.g., <code>[3, 3]</code> for a target of 6), the solution must involve two separate entries at two different indices.</p>"},{"location":"1/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>The most immediate and intuitive way to solve this problem is through Brute Force. This method involves an exhaustive search where every possible pair of numbers in the array is examined. While conceptually simple and always correct, it is highly inefficient, serving mainly as a benchmark for comparison against optimized solutions.</p> <p>To implement the Brute Force strategy, one would use two nested loops. The outer loop iterates over the array elements using an index \\(i\\), starting from the first element. The inner loop, using an index \\(j\\), starts from \\(i+1\\) to ensure that the same element is never used twice and that pairs are not checked redundantly (since \\((i, j)\\) and \\((j, i)\\) are the same pair). Within the inner loop, the condition \\(nums[i] + nums[j] == \\text{target}\\) is evaluated. If the equality holds, the indices \\([i, j]\\) are returned immediately. Because this approach involves comparing every element with every other element, the time complexity is squared, denoted as \\(O(n^2)\\), where \\(n\\) is the number of elements in the array. This quadratic complexity makes the solution impractical for large input arrays.</p>"},{"location":"1/#the-optimized-one-pass-hash-table-solution","title":"The Optimized One-Pass Hash Table Solution","text":"<p>The performance bottleneck in the Brute Force method is the repeated search for the second number. To dramatically improve efficiency, we can leverage the power of Hash Tables (also known as Maps or Dictionaries). A Hash Table allows for nearly instantaneous lookups\u2014specifically, \\(O(1)\\) time complexity on average\u2014by mapping keys to values.</p> <p>The strategy, often referred to as the One-Pass Hash Table method, involves iterating through the <code>nums</code> array only once. For each element \\(nums[i]\\) encountered, the algorithm calculates the complement that would be required to meet the target sum: \\(\\text{complement} = \\text{target} - nums[i]\\). Instead of searching the rest of the array for this complement, which would be \\(O(n)\\), we check if the complement already exists as a key within our Hash Table.</p>"},{"location":"1/#details-of-the-hash-table-logic","title":"Details of the Hash Table Logic","text":"<p>If the calculated complement is found as a key in the Hash Table, it means we have previously processed the required second number, and its index is stored as the value associated with that key. The indices of the two-sum pair are then the current index \\(i\\) and the index retrieved from the map.  This allows for an immediate return, achieving the required result with minimal effort.</p> <p>Conversely, if the complement is not found in the Hash Table, the current number \\(nums[i]\\) has not yet been used to form a pair. In this case, we simply add \\(nums[i]\\) as a key to the Hash Table, with its index \\(i\\) as the corresponding value. By adding the current number to the map, we prepare it to serve as the complement for any subsequent number that might need it. Because this entire process involves a single \\(O(n)\\) iteration and \\(O(1)\\) Hash Table operations (insertion and lookup), the overall time complexity is reduced to \\(O(n)\\), making it a highly efficient solution for the Two Sum problem. The trade-off for this speed improvement is an increase in space complexity to \\(O(n)\\) to store the Hash Table.</p>"},{"location":"10/","title":"Problem 10","text":"<pre><code>class Solution:\n    def isMatch(self, s: str, p: str) -&gt; bool:\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n        return dp[m][n]\n</code></pre>"},{"location":"10/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":""},{"location":"10/#problem-statement-and-key-features","title":"Problem Statement and Key Features","text":"<p>LeetCode problem 10, \"Regular Expression Matching,\" requires implementing a function that determines if a given text string \\(s\\) matches a pattern string \\(p\\). The pattern \\(p\\) supports two special characters: the dot (<code>.</code>) and the asterisk (<code>*</code>). The dot matches any single character, while the asterisk matches zero or more occurrences of the preceding element. The match must cover the entire input string \\(s\\), not just a part of it.</p> <p>This problem is highly challenging because the asterisk (<code>*</code>) introduces a complex ambiguity. The term preceding the asterisk can be matched zero times, one time, two times, or many times. For example, if the pattern is \"a*b\", the \"a*\" can match the empty string, \"a\", or \"aa...\", against the text \"b\", \"ab\", or \"aab\", respectively. This dynamic matching behavior makes a simple greedy or two-pointer approach insufficient.</p>"},{"location":"10/#the-necessity-of-dynamic-programming","title":"The Necessity of Dynamic Programming","text":"<p>Due to the overlapping subproblems and optimal substructure inherent in deciding how to match the <code>*</code> operator, this problem is classically and most effectively solved using Dynamic Programming (DP). The DP approach systematically builds up the solution for larger substrings and sub-patterns based on the solutions to smaller ones, ensuring all possibilities for the <code>*</code> operator are explored.</p> <p>We define a 2D DP array, \\(\\text{dp}[i][j]\\), which is a boolean value indicating whether the first \\(i\\) characters of the text \\(s\\) (i.e., \\(s[0 \\dots i-1]\\)) match the first \\(j\\) characters of the pattern \\(p\\) (i.e., \\(p[0 \\dots j-1]\\)). The ultimate answer to the problem will be stored in \\(\\text{dp}[m][n]\\), where \\(m\\) is the length of \\(s\\) and \\(n\\) is the length of \\(p\\).</p>"},{"location":"10/#base-case-and-character-matching","title":"Base Case and Character Matching","text":"<p>The base case initializes the table. \\(\\text{dp}[0][0]\\) is set to <code>true</code>, as an empty text string matches an empty pattern. For subsequent rows \\(\\text{dp}[0][j]\\) where \\(j&gt;0\\), these can only be <code>true</code> if the pattern consists of zero or more pairs of \\(\\langle \\text{char}, * \\rangle\\), such as \\(a^*\\), \\(a^*b^*\\), or \\((a.)^*\\). Specifically, \\(\\text{dp}[0][j]\\) is <code>true</code> only if \\(p[j-1]\\) is <code>*</code> and \\(\\text{dp}[0][j-2]\\) is <code>true</code>, signifying that the <code>*</code> matches zero occurrences of the preceding element \\(p[j-2]\\).</p> <p>For the general case, the transition logic depends on the character \\(p[j-1]\\): If \\(p[j-1]\\) is not the asterisk (<code>*</code>), a match is possible only if \\(s[i-1]\\) matches \\(p[j-1]\\) (either they are identical characters or \\(p[j-1]\\) is a dot <code>.</code>) and the preceding subproblem matched: \\(\\text{dp}[i][j] = \\text{dp}[i-1][j-1]\\) AND \\(\\text{match}(s[i-1], p[j-1])\\).</p>"},{"location":"10/#the-complex-asterisk-transition","title":"The Complex Asterisk Transition","text":"<p>The crucial complexity lies when \\(p[j-1]\\) is the asterisk (<code>*</code>). The <code>*</code> character dictates a choice between two fundamental matching scenarios, derived from the number of times the preceding element \\(p[j-2]\\) is matched: [Diagram showing DP transitions for Regular Expression Matching]</p> <ol> <li>Zero Occurrences: The asterisk matches zero occurrences of the preceding element \\(p[j-2]\\). In this case, both \\(p[j-2]\\) and \\(p[j-1]\\) (the <code>*</code>) are effectively ignored. The match depends solely on whether \\(s[i]\\) matches the pattern starting at \\(j-2\\). Thus, the solution includes \\(\\text{dp}[i][j-2]\\).</li> <li>One or More Occurrences: The asterisk matches one or more occurrences of \\(p[j-2]\\). This is only possible if the current text character \\(s[i-1]\\) successfully matches \\(p[j-2]\\) (or \\(p[j-2]\\) is a dot). If they match, the problem is reduced to checking if the rest of the text \\(s[0 \\dots i-2]\\) matches the current pattern \\(p[0 \\dots j-1]\\). This allows the asterisk to continue matching the next character in \\(s\\). Thus, the solution includes \\(\\text{dp}[i-1][j]\\) AND \\(\\text{match}(s[i-1], p[j-2])\\).</li> </ol> <p>The final recurrence relation for the asterisk case is an OR condition combining these possibilities: \\(\\text{dp}[i][j] = \\text{dp}[i][j-2] \\lor (\\text{match}(s[i-1], p[j-2]) \\land \\text{dp}[i-1][j])\\). By iterating through all possible \\(i\\) and \\(j\\) up to \\(m\\) and \\(n\\), this DP approach correctly explores all matching possibilities, resulting in an overall time complexity of \\(O(m \\times n)\\).</p>"},{"location":"11/","title":"Problem 11","text":"<pre><code>class Solution:\n    def maxArea(self, height: list[int]) -&gt; int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left &lt; right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            max_area = max(max_area, current_area)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area\n</code></pre>"},{"location":"11/#11-container-with-most-water","title":"11. Container With Most Water","text":""},{"location":"11/#problem-statement-and-geometrical-interpretation","title":"Problem Statement and Geometrical Interpretation","text":"<p>LeetCode problem 11, \"Container With Most Water,\" is a geometrical optimization problem. We are given an array of \\(n\\) non-negative integers, say \\(\\text{heights}\\), where each element \\(\\text{heights}[i]\\) represents the height of a vertical line drawn at coordinate \\((i, \\text{heights}[i])\\). The goal is to find two of these lines that, together with the x-axis, form a container capable of holding the maximum amount of water.</p> <p>The container formed by two lines at indices \\(L\\) and \\(R\\) (where \\(L &lt; R\\)) has a height determined by the shorter of the two lines, \\(\\min(\\text{heights}[L], \\text{heights}[R])\\). The width of the container is the distance between the lines, \\((R - L)\\). The area, which corresponds to the amount of water the container can hold, is calculated as: \\(\\text{Area} = \\text{width} \\times \\text{height} = (R - L) \\times \\min(\\text{heights}[L], \\text{heights}[R])\\). The challenge is to maximize this area by optimally choosing the indices \\(L\\) and \\(R\\).</p>"},{"location":"11/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>A straightforward, yet inefficient, approach is to use Brute Force by checking the area generated by every possible pair of lines. This involves nested loops: the outer loop iterates with index \\(L\\) from 0 to \\(n-2\\), and the inner loop iterates with index \\(R\\) from \\(L+1\\) to \\(n-1\\).</p> <p>In each iteration, the area is calculated, and the maximum area found so far is tracked. Since every pair is examined, the Brute Force solution yields an \\(O(n^2)\\) time complexity. While this works, it is too slow for large arrays and fails to meet the implicit requirement for an optimal solution. An \\(O(n)\\) solution is required for efficient execution.</p>"},{"location":"11/#the-optimized-two-pointer-approach","title":"The Optimized Two-Pointer Approach","text":"<p>The necessary optimization comes from recognizing a crucial pattern and applying the Two-Pointer technique. This approach starts by considering the container formed by the two lines that are farthest apart\u2014the leftmost line (\\(L=0\\)) and the rightmost line (\\(R=n-1\\)). This gives the maximum possible width.</p> <p>After calculating the area for the current \\((L, R)\\) pair, the strategy is to determine which pointer to move inward to potentially find a larger area. Moving a pointer always results in a decrease in width, \\((R - L)\\). Therefore, to compensate for the reduced width, the move must aim to find a line with a greater height.</p>"},{"location":"11/#the-governing-movement-logic","title":"The Governing Movement Logic","text":"<p>The critical decision lies in identifying which of the two pointers, \\(L\\) or \\(R\\), has a shorter line. Since the height of the current container is limited by \\(\\min(\\text{heights}[L], \\text{heights}[R])\\), increasing the height of the container can only be achieved by replacing the shorter of the two boundary lines with a potentially taller line. </p> <ol> <li> <p>If \\(\\text{heights}[L] &lt; \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[L]\\). Any container involving \\(\\text{heights}[L]\\) and a line to its right (say, \\(R' &lt; R\\)) will have a width less than \\((R - L)\\) and a height limited by \\(\\min(\\text{heights}[L], \\text{heights}[R'])\\). Because \\(R'\\) is to the left of \\(R\\), \\(\\text{heights}[R]\\) is irrelevant. Thus, moving \\(R\\) inward would only decrease the width, and the height would still be restricted by the relatively short \\(\\text{heights}[L]\\) or an even shorter height. Moving \\(L\\) inward (\\(\\text{increment } L\\)) is the only logical move, as it offers the possibility of finding a taller line that can increase the container's height, offsetting the loss of width.</p> </li> <li> <p>If \\(\\text{heights}[L] \\ge \\text{heights}[R]\\): The current container's height is limited by \\(\\text{heights}[R]\\). By the same logic, we must move the right pointer inward (\\(\\text{decrement } R\\)) to search for a potentially taller line at the right boundary.</p> </li> </ol> <p>The loop continues until the two pointers meet (\\(L &lt; R\\)). Since \\(L\\) and \\(R\\) traverse the array only once, and each iteration moves at least one pointer, the total time complexity is strictly \\(O(n)\\), making it a highly efficient solution.</p>"},{"location":"12/","title":"Problem 12","text":"<pre><code>class Solution:\n    def intToRoman(self, num: int) -&gt; str:\n\n        mappings = [\n            (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n            (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), \n            (5, \"V\"), (4, \"IV\"), (1, \"I\")\n        ]\n\n        result = []\n\n        for value, symbol in mappings:\n            if num == 0:\n                break\n\n            count, num = divmod(num, value)\n\n            result.append(symbol * count)\n\n        return \"\".join(result)\n</code></pre>"},{"location":"12/#12-integer-to-roman","title":"12. Integer to Roman","text":""},{"location":"12/#problem-statement-and-roman-numeral-system-basics","title":"Problem Statement and Roman Numeral System Basics","text":"<p>LeetCode problem 12, \"Integer to Roman,\" requires converting a given integer into its Roman numeral representation. The input is guaranteed to be within the standard range of Roman numeral representation, specifically from 1 to 3999 (inclusive). This constraint ensures that we do not need to deal with very large numbers requiring bars over the letters or other advanced Roman numeral notation.</p> <p>The Roman numeral system is based on seven symbols, each representing a specific value: \\(I=1, V=5, X=10, L=50, C=100, D=500, M=1000\\). The system uses additive notation (e.g., \\(VI = 5+1 = 6\\)) but also incorporates a crucial subtractive notation rule for four and nine units of magnitude. These subtractive pairs are: \\(IV=4, IX=9\\) (for tens), \\(XL=40, XC=90\\) (for hundreds), and \\(CD=400, CM=900\\) (for thousands). The solution must adhere to the standard convention of always choosing the largest possible symbol or subtractive combination at each place value.</p>"},{"location":"12/#the-greedy-approach-with-ordered-mappings","title":"The Greedy Approach with Ordered Mappings","text":"<p>Since the Roman numeral system has fixed values and the largest symbol is always preferred, this problem is perfectly suited for a Greedy Algorithm. A greedy approach makes the locally optimal choice at each step, and because the Roman numeral system is well-behaved in this range (e.g., you would never use two 'V's instead of one 'X'), this local optimum leads directly to the global optimum.</p> <p>The implementation involves defining two synchronized arrays (or a map of pairs) that store the values and their corresponding Roman symbols, ordered from largest value to smallest. This ordering is crucial because it includes the subtractive pairs (\\(900, 400, 90, 40, 9, 4\\)) which must be checked before their simpler, larger components (\\(1000, 500, 100, 50, 10, 5\\)). [Table showing Roman Numeral Mappings]</p>"},{"location":"12/#iteration-and-conversion-logic","title":"Iteration and Conversion Logic","text":"<p>We iterate through the ordered list of value-symbol pairs. For each pair \\((\\text{value}, \\text{symbol})\\), we check if the remaining input number, \\(num\\), is greater than or equal to \\(\\text{value}\\).</p> <p>If \\(num \\ge \\text{value}\\), it means the current symbol or combination is the largest possible representation that can be used at this stage. We apply the greedy choice: we append the \\(\\text{symbol}\\) to our result string and simultaneously subtract the \\(\\text{value}\\) from \\(num\\). We repeat this process with the same pair until \\(num\\) drops below \\(\\text{value}\\). This ensures that repeated symbols are correctly handled (e.g., \\(3000\\) requires three 'M's).</p>"},{"location":"12/#example-of-greedy-selection","title":"Example of Greedy Selection","text":"<p>Consider converting the number 1994. The algorithm proceeds as follows: 1.  Check 1000 (\\(M\\)): \\(1994 \\ge 1000\\). Result becomes \"M\", \\(num\\) becomes 994. 2.  Check 900 (\\(CM\\)): \\(994 \\ge 900\\). Result becomes \"MCM\", \\(num\\) becomes 94. 3.  Check 500 (\\(D\\)): \\(94 &lt; 500\\). Skip. 4.  ... 5.  Check 90 (\\(XC\\)): \\(94 \\ge 90\\). Result becomes \"MCMXC\", \\(num\\) becomes 4. 6.  Check 50 (\\(L\\)): \\(4 &lt; 50\\). Skip. 7.  Check 4 (\\(IV\\)): \\(4 \\ge 4\\). Result becomes \"MCMXCIV\", \\(num\\) becomes 0.</p> <p>The process stops when \\(num\\) reaches 0. Because the number of symbols in the mapping is a small constant (13 pairs), the number of iterations required is very small and does not depend on the magnitude of the input integer \\(num\\) but rather on the number of fixed place values. Therefore, the time complexity is effectively \\(O(1)\\) (constant time) due to the fixed constraint of the input range (1 to 3999).</p>"},{"location":"13/","title":"Problem 13","text":"<pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n\n        value_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = value_map[char]\n\n            if current_value &lt; prev_value:\n                total -= current_value\n            else:\n                total += current_value\n\n            prev_value = current_value\n\n        return total\n</code></pre>"},{"location":"13/#13-roman-to-integer","title":"13. Roman to Integer","text":""},{"location":"13/#problem-statement-and-the-subtraction-rule-challenge","title":"Problem Statement and The Subtraction Rule Challenge","text":"<p>LeetCode problem 13, \"Roman to Integer,\" involves converting a given Roman numeral string, \\(s\\), into its corresponding integer value. The input is guaranteed to be a valid Roman numeral within the standard range of 1 to 3999. Unlike converting from an integer to a Roman numeral (which relies on a greedy build-up), converting to an integer requires a careful sequential interpretation of the Roman characters.</p> <p>The main complexity arises from the subtractive notation. Normally, symbols are additive (e.g., \\(VI = 5 + 1 = 6\\)). However, a smaller value symbol placed before a larger value symbol indicates subtraction (e.g., \\(IV = 5 - 1 = 4\\), \\(CM = 1000 - 100 = 900\\)). The algorithm must correctly identify these subtractive pairs and adjust the running total accordingly, which cannot be done by simply summing the values of the individual characters from left to right.</p>"},{"location":"13/#mapping-and-initialization","title":"Mapping and Initialization","text":"<p>The solution begins by establishing a map or dictionary to store the integer value for each of the seven Roman symbols (\\(I, V, X, L, C, D, M\\)). [Table showing Roman Numeral Mappings] The conversion process must then handle the string \\(s\\) by processing it sequentially. A variable, often called <code>total</code> or <code>result</code>, is initialized to 0 to accumulate the final integer value.</p> <p>The most robust approach involves iterating through the Roman numeral string from left to right, comparing the value of the current symbol with the value of the next symbol. This lookahead comparison is the key mechanism for identifying the subtractive rule.</p>"},{"location":"13/#the-lookahead-comparison-logic","title":"The Lookahead Comparison Logic","text":"<p>We iterate through the string using an index \\(i\\) from the beginning up to the second-to-last character. In each step, we retrieve the value of the current symbol, \\(\\text{current\\_val} = \\text{map}[s[i]]\\), and the value of the next symbol, \\(\\text{next\\_val} = \\text{map}[s[i+1]]\\).</p> <ol> <li>Subtractive Case: If \\(\\text{current\\_val} &lt; \\text{next\\_val}\\) (e.g., \\(I\\) followed by \\(V\\) in \\(IV\\)), this signals a subtractive pair. The correct way to handle this is to subtract the current value from the running <code>total</code>. This is because the \\(\\text{current\\_val}\\) is not being added normally but is being used to subtract from the subsequent, larger value.</li> <li>Additive Case: If \\(\\text{current\\_val} \\ge \\text{next\\_val}\\) (e.g., \\(V\\) followed by \\(I\\) in \\(VI\\), or two identical symbols like \\(X\\) followed by \\(X\\)), the current value is purely additive. We add \\(\\text{current\\_val}\\) to the running <code>total</code>.</li> </ol>"},{"location":"13/#finalizing-the-conversion","title":"Finalizing the Conversion","text":"<p>After the loop completes, the last character of the Roman numeral string (at index \\(n-1\\)) will not have been processed, as the loop only goes up to \\(n-2\\) to allow for the \\(i+1\\) lookahead. The last symbol can never be part of a subtractive pair (as there is no symbol following it), so its value is always additive.</p> <p>Therefore, the final step is to retrieve the value of the last character, \\(\\text{map}[s[n-1]]\\), and add it to the accumulated <code>total</code>. This approach correctly handles all symbols and the subtractive rule, resulting in the correct integer. Since the algorithm requires only a single pass through the string, the time complexity is linear, \\(O(n)\\), where \\(n\\) is the length of the Roman numeral string. Given the input constraint of 1 to 3999, \\(n\\) is at most 15, so the time complexity is very fast in practice.</p>"},{"location":"14/","title":"Problem 14","text":"<pre><code>class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -&gt; str:\n\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            current_string = strs[i]\n\n            while current_string.find(prefix) != 0:\n                prefix = prefix[:-1]\n\n                if not prefix:\n                    return \"\"\n\n        return prefix\n</code></pre>"},{"location":"14/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":""},{"location":"14/#problem-statement-and-core-objective","title":"Problem Statement and Core Objective","text":"<p>LeetCode problem 14, \"Longest Common Prefix,\" is a fundamental string processing task. Given an array of strings, \\(\\text{strs}\\), the objective is to find the longest string that is a prefix of all strings within the array. If no common prefix exists among the strings (i.e., they all start with different characters), the function must return an empty string, \"\".</p> <p>This problem highlights the need for efficient comparison across multiple string inputs. The resulting Longest Common Prefix (LCP) must adhere strictly to the definition of a prefix, meaning it must be a contiguous substring starting at the beginning of each string. For example, in the array [\"flower\", \"flow\", \"flight\"], the LCP is \"fl\".</p>"},{"location":"14/#the-brute-force-and-vertical-scanning-approaches","title":"The Brute Force and Vertical Scanning Approaches","text":"<p>A brute force approach might involve checking every possible prefix of the shortest string against all other strings. This involves unnecessary repetition. A slightly more refined, but still potentially inefficient, method is Vertical Scanning. This method iterates through the characters of the strings from left to right, column by column.</p> <p>For index \\(j=0, 1, 2, \\dots\\), we check if the character at position \\(j\\) in the first string, \\(\\text{strs}[0][j]\\), is the same as the character at position \\(j\\) in all subsequent strings, \\(\\text{strs}[i][j]\\). If we find a mismatch at any string or if we reach the end of any string, the common prefix is the substring of \\(\\text{strs}[0]\\) up to index \\(j-1\\). While easier than Brute Force, Vertical Scanning can be slow if the array contains many long strings with a very long LCP, as it performs many redundant character comparisons. The worst-case time complexity is \\(O(S)\\), where \\(S\\) is the sum of the lengths of all strings, as in the scenario where all strings are identical.</p>"},{"location":"14/#the-optimized-horizontal-scanning-technique","title":"The Optimized Horizontal Scanning Technique","text":"<p>The most intuitive and often simplest efficient method is Horizontal Scanning. This approach works by incrementally refining a candidate LCP string by comparing it sequentially with every string in the input array.</p> <p>We start by assuming the first string in the array, \\(\\text{strs}[0]\\), is the initial LCP candidate. We then iterate through the rest of the strings, from \\(\\text{strs}[1]\\) to \\(\\text{strs}[n-1]\\). For each string \\(\\text{strs}[i]\\), we update the LCP to be the common prefix between the current LCP and \\(\\text{strs}[i]\\). [Diagram illustrating Horizontal Scanning for LCP]</p>"},{"location":"14/#details-of-the-lcp-refinement","title":"Details of the LCP Refinement","text":"<p>The refinement step for a string \\(\\text{strs}[i]\\) and the current LCP is performed using a simple check. We ask: \"Does \\(\\text{strs}[i]\\) start with the current LCP?\" In many programming languages, this is done with a function like <code>indexOf(LCP) == 0</code>.</p> <p>If \\(\\text{strs}[i]\\) does not start with the current LCP, it means the LCP is too long. We must shorten the current LCP by removing its last character (\\(\\text{LCP} = \\text{LCP}[:-1]\\)). We repeatedly shorten the LCP until \\(\\text{strs}[i]\\) does start with the truncated LCP, or until the LCP becomes empty. If the LCP becomes an empty string, we can immediately terminate the entire process and return \"\" because no subsequent string can possibly share a prefix with all previous strings. Once \\(\\text{strs}[i]\\)'s prefix is matched, we move on to the next string in the array with the new, refined LCP. Upon completing the iteration through all strings, the final remaining LCP is the correct answer. The worst-case time complexity for Horizontal Scanning is also \\(O(S)\\), but it often performs better in practice when the LCP is short.</p>"},{"location":"14/#other-advanced-approaches-trie-and-divide-and-conquer","title":"Other Advanced Approaches (Trie and Divide and Conquer)","text":"<p>More advanced solutions exist, such as using a Trie (Prefix Tree) or a Divide and Conquer approach. * Trie: By inserting all strings into a Trie, the LCP is represented by the longest path from the root that has only one child node (since it must be common to all strings). This method is optimal in terms of comparisons but adds \\(O(S)\\) overhead for building the Trie. * Divide and Conquer: This recursive approach divides the array of strings into two halves, finds the LCP of each half, and then finds the LCP of those two results. This has the same \\(O(S)\\) time complexity but is often less efficient due to recursion overhead compared to the simple iterative Horizontal Scanning.</p>"},{"location":"15/","title":"Problem 15","text":"<pre><code>class Solution:\n    def threeSum(self, nums: list[int]) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if nums[i] &gt; 0:\n                break\n\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            target = -nums[i]\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[L] + nums[R]\n\n                if current_sum == target:\n                    result.append([nums[i], nums[L], nums[R]])\n\n                    while L &lt; R and nums[L] == nums[L+1]:\n                        L += 1\n                    while L &lt; R and nums[R] == nums[R-1]:\n                        R -= 1\n\n                    L += 1\n                    R -= 1\n\n                elif current_sum &lt; target:\n                    L += 1\n\n                else:\n                    R -= 1\n\n        return result\n</code></pre>"},{"location":"16/","title":"Problem 16","text":"<pre><code>class Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -&gt; int:\n\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]\n\n        for i in range(n - 2):\n            L = i + 1\n            R = n - 1\n\n            while L &lt; R:\n                current_sum = nums[i] + nums[L] + nums[R]\n\n                if abs(current_sum - target) &lt; abs(closest_sum - target):\n                    closest_sum = current_sum\n\n                if current_sum &lt; target:\n                    L += 1\n                elif current_sum &gt; target:\n                    R -= 1\n                else:\n                    return current_sum\n\n        return closest_sum\n</code></pre>"},{"location":"17/","title":"Problem 17","text":"<pre><code>class Solution:\n    def letterCombinations(self, digits: str) -&gt; list[str]:\n\n        if not digits:\n            return []\n\n        mapping = {\n            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', \n            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n        }\n\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(\"\".join(path))\n                return\n\n            digit = digits[index]\n            letters = mapping[digit]\n\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return result\n</code></pre>"},{"location":"18/","title":"Problem 18","text":"<pre><code>class Solution:\n    def fourSum(self, nums: list[int], target: int) -&gt; list[list[int]]:\n\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 3):\n            if i &gt; 0 and nums[i] == nums[i-1]:\n                continue\n\n            for j in range(i + 1, n - 2):\n                if j &gt; i + 1 and nums[j] == nums[j-1]:\n                    continue\n\n                new_target = target - nums[i] - nums[j]\n                L = j + 1\n                R = n - 1\n\n                while L &lt; R:\n                    current_sum = nums[L] + nums[R]\n\n                    if current_sum == new_target:\n                        result.append([nums[i], nums[j], nums[L], nums[R]])\n\n                        while L &lt; R and nums[L] == nums[L+1]:\n                            L += 1\n                        while L &lt; R and nums[R] == nums[R-1]:\n                            R -= 1\n\n                        L += 1\n                        R -= 1\n\n                    elif current_sum &lt; new_target:\n                        L += 1\n                    else:\n                        R -= 1\n\n        return result\n</code></pre>"},{"location":"19/","title":"Problem 19","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode | None, n: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        fast = dummy\n        slow = dummy\n\n        for _ in range(n + 1):\n            if not fast:\n                return head\n            fast = fast.next\n\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n</code></pre>"},{"location":"2/","title":"Problem 2","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            total_sum = val1 + val2 + carry\n            carry = total_sum // 10\n            new_digit = total_sum % 10\n\n            current.next = ListNode(new_digit)\n            current = current.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy_head.next\n</code></pre>"},{"location":"2/#2-add-two-numbers","title":"2. Add Two Numbers","text":""},{"location":"2/#problem-statement-and-representation","title":"Problem Statement and Representation","text":"<p>LeetCode problem 2, \"Add Two Numbers,\" requires the simulation of adding two non-negative integers that are represented in a rather unusual format: as linked lists. Specifically, each digit of the number is stored in a separate node of the linked list, and the digits are stored in reverse order. For example, the number 342 would be represented by a linked list \\(2 \\rightarrow 4 \\rightarrow 3\\). The task is to take two such linked lists, \\(l1\\) and \\(l2\\), add the numbers they represent, and return the sum as a new linked list in the same reverse-digit format.</p> <p>The reversed storage order is a crucial design choice that greatly simplifies the addition process. It allows us to start adding from the least significant digit (the ones place, which is the head of the list) without needing to traverse the lists to find the end first, as would be necessary if the digits were stored in forward order. This structure inherently facilitates the standard, elementary-school method of addition, working from right to left.</p>"},{"location":"2/#the-iterative-addition-process","title":"The Iterative Addition Process","text":"<p>The most efficient and common solution to this problem is an iterative simulation of manual column addition, which naturally involves a concept known as the carry. We initialize a dummy head node for the resulting sum list, which simplifies the process of appending new nodes, and we maintain a current pointer to build the list. A crucial variable, <code>carry</code>, is initialized to 0.</p> <p>We traverse both input linked lists, \\(l1\\) and \\(l2\\), simultaneously. The iteration continues as long as there are remaining nodes in \\(l1\\) or \\(l2\\), or if the <code>carry</code> variable is still greater than zero. This third condition is vital, as it ensures that any final carry digit generated by the last sum is correctly included as the final node of the result list.</p>"},{"location":"2/#calculating-the-sum-and-carry","title":"Calculating the Sum and Carry","text":"<p>In each step of the iteration, we calculate the total sum for the current \"column\" of digits. This sum includes the value of the current node from \\(l1\\) (if it exists), the value of the current node from \\(l2\\) (if it exists), and the value of the <code>carry</code> from the previous step. If a list pointer has already reached the end, its value for that step is considered 0.</p> <p>Once the total sum (\\(\\text{sum}\\)) is computed, we determine the two components required for the next step: the digit for the current node and the new carry. The digit that should be placed in the new node of the result list is the \\(\\text{sum}\\) modulo 10, or \\(\\text{digit} = \\text{sum} \\pmod{10}\\). This calculation correctly isolates the single digit for the current place value. The new <code>carry</code> value that must be transferred to the next (more significant) place value is calculated by integer division: \\(\\text{carry} = \\text{sum} / 10\\). </p>"},{"location":"2/#building-the-result-list-and-complexity","title":"Building the Result List and Complexity","text":"<p>A new node containing the calculated \\(\\text{digit}\\) is created and appended to the result linked list using the current pointer. We then advance the pointers for \\(l1\\) and \\(l2\\) to their next respective nodes (if they exist) and move the result list's current pointer to the newly created node, preparing it for the next iteration.</p> <p>This iterative process guarantees that the resulting sum list is built correctly, digit by digit, from the least significant to the most significant. The time complexity of this solution is \\(O(\\max(m, n))\\), where \\(m\\) and \\(n\\) are the lengths of the two input linked lists. This is an optimal linear time complexity, as we must process every node at least once. The space complexity is also \\(O(\\max(m, n))\\) because a new linked list of up to that length must be created to store the result.</p>"},{"location":"20/","title":"Problem 20","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n\n        return not stack\n</code></pre>"},{"location":"21/","title":"Problem 21","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode | None, list2: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        current.next = list1 if list1 else list2\n\n        return dummy.next\n</code></pre>"},{"location":"22/","title":"Problem 22","text":"<pre><code>class Solution:\n    def generateParenthesis(self, n: int) -&gt; list[str]:\n\n        result = []\n\n        def backtrack(open_count, close_count, current_string):\n            if len(current_string) == 2 * n:\n                result.append(current_string)\n                return\n\n            if open_count &lt; n:\n                backtrack(open_count + 1, close_count, current_string + \"(\")\n\n            if close_count &lt; open_count:\n                backtrack(open_count, close_count + 1, current_string + \")\")\n\n        backtrack(0, 0, \"\")\n        return result\n</code></pre>"},{"location":"23/","title":"Problem 23","text":"<pre><code>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n\n            current.next = node\n            current = current.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n</code></pre>"},{"location":"24/","title":"Problem 24","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode | None) -&gt; ListNode | None:\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n\n            prev.next = second\n            first.next = second.next\n            second.next = first\n\n            prev = first\n\n        return dummy.next\n</code></pre>"},{"location":"25/","title":"Problem 25","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n\n        dummy = ListNode(0, head)\n        prev_group_tail = dummy\n\n        while True:\n            kth = head\n            for _ in range(k - 1):\n                if not kth:\n                    break\n                kth = kth.next\n\n            if not kth:\n                break\n\n            next_group_head = kth.next\n\n            curr, prev = head, next_group_head\n            for _ in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            prev_group_tail.next = prev\n            prev_group_tail = head\n            head = next_group_head\n\n        return dummy.next\n</code></pre>"},{"location":"26/","title":"Problem 26","text":"<pre><code>class Solution:\n    def removeDuplicates(self, nums: list[int]) -&gt; int:\n\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\n</code></pre>"},{"location":"27/","title":"Problem 27","text":"<pre><code>class Solution:\n    def removeElement(self, nums: list[int], val: int) -&gt; int:\n\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i] = nums[j]\n                i += 1\n\n        return i\n</code></pre>"},{"location":"28/","title":"Problem 28","text":"<pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1\n</code></pre>"},{"location":"29/","title":"Problem 29","text":"<pre><code>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n\n        MAX_INT = 2147483647\n        MIN_INT = -2147483648\n\n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n\n        negative = (dividend &lt; 0) != (divisor &lt; 0)\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        for i in range(31, -1, -1):\n            if (abs_dividend &gt;&gt; i) &gt;= abs_divisor:\n                quotient += (1 &lt;&lt; i)\n                abs_dividend -= (abs_divisor &lt;&lt; i)\n\n        if negative:\n            return -quotient\n        else:\n            return quotient\n</code></pre>"},{"location":"3/","title":"Problem 3","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        char_set = set()\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n</code></pre>"},{"location":"3/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":""},{"location":"3/#problem-statement-and-definition","title":"Problem Statement and Definition","text":"<p>LeetCode problem 3, \"Longest Substring Without Repeating Characters,\" is a classic string manipulation challenge. The objective is to determine the length of the longest substring within a given string \\(s\\) that does not contain any repeating characters. A substring must be a contiguous sequence of characters, meaning the characters must appear consecutively in the original string. The challenge is to find the maximum possible length of such a unique sequence.</p> <p>For instance, if the input string is \"abcabcbb\", the substrings without repeating characters are \"abc\", \"bca\", \"cab\", and \"cbb\". The longest among these is \"abc\", with a length of 3. If the input is \"pwwkew\", the longest substring is \"wke\" or \"kew\" (not \"pwke\" as 'w' repeats, and not \"pwwkew\" as 'w' repeats), which has a length of 3. The distinction between a substring and a subsequence is crucial: \"pwke\" is a subsequence but not a substring because the 'w's are separated in the original string by 'k' and 'e', thus violating the contiguity rule.</p>"},{"location":"3/#the-inefficient-brute-force-approach","title":"The Inefficient Brute Force Approach","text":"<p>A naive Brute Force solution would be to generate every possible substring of the input string \\(s\\) and, for each substring, check if all of its characters are unique. Generating all substrings takes \\(O(n^2)\\) time, where \\(n\\) is the length of \\(s\\), as there are \\(\\frac{n(n+1)}{2}\\) total substrings. For each generated substring, checking for uniqueness typically involves using a Set data structure or comparing every character against every other character within that substring, which can take up to \\(O(n)\\) time.</p> <p>Combining these steps leads to an overall time complexity of \\(O(n^3)\\). While this approach is correct, its cubic time complexity makes it highly impractical for strings of significant length. The need for a faster solution drives us toward a more sophisticated, linear-time algorithm.</p>"},{"location":"3/#the-optimized-sliding-window-technique","title":"The Optimized Sliding Window Technique","text":"<p>The problem is best solved using the Sliding Window pattern, which optimizes the search process to achieve \\(O(n)\\) time complexity. This technique involves maintaining a \"window,\" which is a contiguous range of elements (a substring) in the input string. The window dynamically expands or shrinks as we iterate through the input.</p> <p>In this specific application, the window is defined by two pointers, a left pointer \\(i\\) and a right pointer \\(j\\), representing the current substring \\([i, j)\\). We use a Hash Set (or a Map) to efficiently store the characters currently present within the window. The set allows us to check for the existence of a character in \\(O(1)\\) time on average. </p>"},{"location":"3/#mechanism-of-the-sliding-window","title":"Mechanism of the Sliding Window","text":"<p>The process begins by expanding the window using the right pointer \\(j\\). We examine the character \\(s[j]\\). 1.  Expansion: If the character \\(s[j]\\) is not currently present in our Hash Set, it means the current window \\([i, j]\\) is still valid (contains only unique characters). We add \\(s[j]\\) to the set, increment the right pointer \\(j\\), and update our record of the maximum length found so far: \\(\\text{max\\_len} = \\max(\\text{max\\_len}, j - i)\\). 2.  Contraction (Sliding): If the character \\(s[j]\\) is already present in the Hash Set, we have found a repeating character. The window \\([i, j]\\) is now invalid. We must shrink the window from the left by incrementing the left pointer \\(i\\). As we move \\(i\\) forward, we remove the character \\(s[i]\\) from the Hash Set. We continue this shrinking process until the repeating character is no longer inside the window, at which point the character \\(s[j]\\) can be safely added, and the expansion resumes.</p> <p>This single-pass, two-pointer approach is extremely efficient. The key insight is that both the left pointer \\(i\\) and the right pointer \\(j\\) traverse the string \\(s\\) at most once. Therefore, each character is visited, added to the set, and removed from the set at most once, leading to an overall linear time complexity of \\(O(n)\\). The space complexity is \\(O(k)\\), where \\(k\\) is the size of the character set (e.g., \\(k=26\\) for lowercase English letters, or \\(k=128\\) for ASCII characters), which is often considered \\(O(1)\\) since \\(k\\) is constant.</p>"},{"location":"30/","title":"Problem 30","text":"<pre><code>class Solution:\n    def findSubstring(self, s: str, words: list[str]) -&gt; list[int]:\n\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        from collections import Counter\n        word_count = Counter(words)\n        result = []\n\n        for i in range(word_len):\n            left = i\n            right = i\n            current_count = Counter()\n\n            while right + word_len &lt;= len(s):\n                word = s[right : right + word_len]\n                right += word_len\n\n                if word in word_count:\n                    current_count[word] += 1\n\n                    while current_count[word] &gt; word_count[word]:\n                        left_word = s[left : left + word_len]\n                        current_count[left_word] -= 1\n                        left += word_len\n\n                    if right - left == total_len:\n                        result.append(left)\n                else:\n                    current_count.clear()\n                    left = right\n\n        return result\n</code></pre>"},{"location":"31/","title":"Problem 31","text":"<pre><code>class Solution:\n    def nextPermutation(self, nums: list[int]) -&gt; None:\n\n        n = len(nums)\n        i = n - 2\n\n        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:\n            i -= 1\n\n        if i &gt;= 0:\n            j = n - 1\n            while nums[j] &lt;= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, n - 1\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n</code></pre>"},{"location":"32/","title":"Problem 32","text":"<pre><code>class Solution:\n    def longestValidParentheses(self, s: str) -&gt; int:\n\n        max_len = 0\n        stack = [-1]\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n</code></pre>"},{"location":"33/","title":"Problem 33","text":"<pre><code>class Solution:\n    def search(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[L] &lt;= nums[mid]:\n                if nums[L] &lt;= target &lt; nums[mid]:\n                    R = mid - 1\n                else:\n                    L = mid + 1\n            else:\n                if nums[mid] &lt; target &lt;= nums[R]:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n\n        return -1\n</code></pre>"},{"location":"34/","title":"Problem 34","text":"<pre><code>class Solution:\n    def searchRange(self, nums: list[int], target: int) -&gt; list[int]:\n\n        def find_bound(is_first):\n            L, R = 0, len(nums) - 1\n            idx = -1\n\n            while L &lt;= R:\n                mid = (L + R) // 2\n                if nums[mid] == target:\n                    idx = mid\n                    if is_first:\n                        R = mid - 1\n                    else:\n                        L = mid + 1\n                elif nums[mid] &lt; target:\n                    L = mid + 1\n                else:\n                    R = mid - 1\n            return idx\n\n        first = find_bound(True)\n        if first == -1:\n            return [-1, -1]\n\n        last = find_bound(False)\n        return [first, last]\n</code></pre>"},{"location":"35/","title":"Problem 35","text":"<pre><code>class Solution:\n    def searchInsert(self, nums: list[int], target: int) -&gt; int:\n\n        L, R = 0, len(nums) - 1\n\n        while L &lt;= R:\n            mid = (L + R) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                L = mid + 1\n            else:\n                R = mid - 1\n\n        return L\n</code></pre>"},{"location":"36/","title":"Problem 36","text":"<pre><code>class Solution:\n    def isValidSudoku(self, board: list[list[str]]) -&gt; bool:\n\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                char = board[r][c]\n                if char == '.':\n                    continue\n\n                box_index = (r // 3) * 3 + (c // 3)\n\n                if char in rows[r] or char in cols[c] or char in boxes[box_index]:\n                    return False\n\n                rows[r].add(char)\n                cols[c].add(char)\n                boxes[box_index].add(char)\n\n        return True\n</code></pre>"},{"location":"37/","title":"Problem 37","text":"<pre><code>class Solution:\n    def solveSudoku(self, board: list[list[str]]) -&gt; None:\n\n        def is_valid(r, c, val):\n            for i in range(9):\n                if board[r][i] == val or board[i][c] == val:\n                    return False\n\n            start_r, start_c = 3 * (r // 3), 3 * (c // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[start_r + i][start_c + j] == val:\n                        return False\n            return True\n\n        def backtrack():\n            for r in range(9):\n                for c in range(9):\n                    if board[r][c] == '.':\n                        for val_char in \"123456789\":\n                            if is_valid(r, c, val_char):\n                                board[r][c] = val_char\n                                if backtrack():\n                                    return True\n                                board[r][c] = '.'\n                        return False\n            return True\n\n        backtrack()\n</code></pre>"},{"location":"38/","title":"Problem 38","text":"<pre><code>class Solution:\n    def countAndSay(self, n: int) -&gt; str:\n\n        if n == 1:\n            return \"1\"\n\n        prev_sequence = self.countAndSay(n - 1)\n        result = []\n        i = 0\n\n        while i &lt; len(prev_sequence):\n            count = 1\n            j = i + 1\n            while j &lt; len(prev_sequence) and prev_sequence[j] == prev_sequence[i]:\n                count += 1\n                j += 1\n            result.append(str(count) + prev_sequence[i])\n            i = j\n\n        return \"\".join(result)\n</code></pre>"},{"location":"39/","title":"Problem 39","text":"<pre><code>class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"4/","title":"Problem 4","text":"<pre><code>class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        A, B = nums1, nums2\n        m, n = len(A), len(B)\n\n        if m &gt; n:\n            A, B = B, A\n            m, n = n, m\n\n        half_len = (m + n + 1) // 2\n\n        low = 0\n        high = m\n\n        while low &lt;= high:\n            partitionA = (low + high) // 2\n            partitionB = half_len - partitionA\n\n            maxLeftA = A[partitionA - 1] if partitionA &gt; 0 else float('-inf')\n            minRightA = A[partitionA] if partitionA &lt; m else float('inf')\n\n            maxLeftB = B[partitionB - 1] if partitionB &gt; 0 else float('-inf')\n            minRightB = B[partitionB] if partitionB &lt; n else float('inf')\n\n            if maxLeftA &lt;= minRightB and maxLeftB &lt;= minRightA:\n                if (m + n) % 2 == 1:\n                    return max(maxLeftA, maxLeftB)\n                else:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2\n\n            elif maxLeftA &gt; minRightB:\n                high = partitionA - 1\n\n            else:\n                low = partitionA + 1\n\n        return 0.0\n</code></pre>"},{"location":"4/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":""},{"location":"4/#problem-statement-and-efficiency-constraint","title":"Problem Statement and Efficiency Constraint","text":"<p>LeetCode problem 4, \"Median of Two Sorted Arrays,\" presents a significant challenge: given two already sorted arrays, \\(nums1\\) of size \\(m\\) and \\(nums2\\) of size \\(n\\), find the median of the single sorted array that would result from merging both inputs. Crucially, the problem imposes a stringent constraint on the required time complexity, demanding an \\(O(\\log(m+n))\\) solution. This logarithmic complexity immediately rules out simple merging of the arrays (\\(O(m+n)\\)) or any \\(O(n^2)\\) approaches, strongly suggesting the use of a Binary Search technique.</p> <p>The median is defined as the middle element of a sorted list. If the total number of elements \\((m+n)\\) is odd, the median is the single middle element. If the total number of elements is even, the median is the average of the two middle elements. The core difficulty lies in finding this median without explicitly merging the entire arrays.</p>"},{"location":"4/#the-partitioning-principle","title":"The Partitioning Principle","text":"<p>The solution hinges on the concept of partitioning the two arrays. The goal is to find a \"cut\" in \\(nums1\\) and a corresponding \"cut\" in \\(nums2\\) such that two conditions are simultaneously met:</p> <ol> <li>Equal-Sized Halves: The total number of elements in the left partitions (combined) must equal the total number of elements in the right partitions (combined). If the total length \\((m+n)\\) is odd, the left side can have one more element than the right. We aim for \\(\\text{length}(\\text{Left}) = \\lfloor(m+n+1)/2\\rfloor\\).</li> <li>Order Preservation: Every element in the combined left partition must be less than or equal to every element in the combined right partition. That is, \\(\\text{max}(\\text{Left}) \\le \\text{min}(\\text{Right})\\).</li> </ol>"},{"location":"4/#applying-binary-search","title":"Applying Binary Search","text":"<p>To efficiently find these ideal cuts, we apply binary search on the smaller of the two arrays (let's assume \\(nums1\\) is the smaller one, ensuring the search space is minimized, \\(O(\\log(\\min(m, n)))\\)). We search for the optimal partition index, \\(i\\), in \\(nums1\\).</p> <p>The partition index \\(i\\) divides \\(nums1\\) into a left part of size \\(i\\) and a right part of size \\(m-i\\). The corresponding partition index \\(j\\) in \\(nums2\\) is automatically determined by the total required size of the left half: \\(j = \\lfloor(m+n+1)/2\\rfloor - i\\).  This fixed relationship ensures the first condition (equal sizes) is always satisfied.</p>"},{"location":"4/#verification-and-adjustment","title":"Verification and Adjustment","text":"<p>With the cuts defined by \\(i\\) and \\(j\\), we identify the four key boundary elements: \\(\\text{L1} = nums1[i-1]\\), \\(\\text{R1} = nums1[i]\\), \\(\\text{L2} = nums2[j-1]\\), and \\(\\text{R2} = nums2[j]\\). (Edge cases, where \\(i=0, i=m, j=0,\\) or \\(j=n\\), must be handled by assigning \\(L\\) boundary values of \\(-\\infty\\) and \\(R\\) boundary values of \\(+\\infty\\)).</p> <p>The second condition, order preservation, requires that the largest element on the left side is less than or equal to the smallest element on the right side: \\(\\max(\\text{L1}, \\text{L2}) \\le \\min(\\text{R1}, \\text{R2})\\). This breaks down into two separate checks: 1.  \\(\\text{L1} \\le \\text{R2}\\) 2.  \\(\\text{L2} \\le \\text{R1}\\)</p>"},{"location":"4/#determining-the-median","title":"Determining the Median","text":"<p>The binary search loop continues by adjusting the search range for \\(i\\): * If \\(\\text{L1} &gt; \\text{R2}\\) (i.e., \\(nums1\\)'s cut is too far to the right), we move the binary search right boundary for \\(i\\) to \\(i-1\\). * If \\(\\text{L2} &gt; \\text{R1}\\) (i.e., \\(nums1\\)'s cut is too far to the left), we move the binary search left boundary for \\(i\\) to \\(i+1\\).</p> <p>Once the optimal partition is found (when both \\(\\text{L1} \\le \\text{R2}\\) and \\(\\text{L2} \\le \\text{R1}\\) hold), the median can be calculated: * If \\((m+n)\\) is odd: The median is the largest element in the left half, \\(\\text{Median} = \\max(\\text{L1}, \\text{L2})\\). * If \\((m+n)\\) is even: The median is the average of the largest element in the left half and the smallest element in the right half, \\(\\text{Median} = (\\max(\\text{L1}, \\text{L2}) + \\min(\\text{R1}, \\text{R2})) / 2\\). This logarithmic approach successfully meets the strict \\(O(\\log(m+n))\\) time complexity requirement.</p>"},{"location":"40/","title":"Problem 40","text":"<pre><code>class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n\n        candidates.sort()\n        result = []\n\n        def backtrack(remainder, combination, start):\n            if remainder == 0:\n                result.append(list(combination))\n                return\n            if remainder &lt; 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i &gt; start and candidates[i] == candidates[i-1]:\n                    continue\n\n                candidate = candidates[i]\n                combination.append(candidate)\n                backtrack(remainder - candidate, combination, i + 1)\n                combination.pop()\n\n        backtrack(target, [], 0)\n        return result\n</code></pre>"},{"location":"5/","title":"Problem 5","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\n        def expand_around_center(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        longest = \"\"\n        for i in range(len(s)):\n\n            # Odd length palindromes (center is s[i])\n            palindrome1 = expand_around_center(i, i)\n            if len(palindrome1) &gt; len(longest):\n                longest = palindrome1\n\n            # Even length palindromes (center is s[i] and s[i+1])\n            palindrome2 = expand_around_center(i, i + 1)\n            if len(palindrome2) &gt; len(longest):\n                longest = palindrome2\n\n        return longest\n</code></pre>"},{"location":"5/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":""},{"location":"5/#problem-statement-and-core-challenge","title":"Problem Statement and Core Challenge","text":"<p>LeetCode problem 5, \"Longest Palindromic Substring,\" requires finding the longest contiguous substring within a given string \\(s\\) that reads the same forwards and backwards. A string that exhibits this property is called a palindrome. The challenge lies in efficiently identifying this longest palindromic segment among all possible substrings.</p> <p>While the problem seems simple at first glance, the potentially large number of substrings makes a naive approach computationally prohibitive. For a string of length \\(N\\), there are \\(O(N^2)\\) possible substrings. Checking each substring for the palindromic property takes \\(O(N)\\) time, leading to an overall Brute Force complexity of \\(O(N^3)\\). We must seek an optimized solution that can handle input constraints effectively, ideally aiming for \\(O(N^2)\\) time or better.</p>"},{"location":"5/#dynamic-programming-solution-the-formal-approach","title":"Dynamic Programming Solution (The Formal Approach)","text":"<p>One structured way to solve this is using Dynamic Programming (DP), which offers an \\(O(N^2)\\) time complexity. We define a 2D boolean array, \\(\\text{dp}[i][j]\\), where \\(\\text{dp}[i][j]\\) is <code>true</code> if the substring \\(s[i \\dots j]\\) is a palindrome, and <code>false</code> otherwise.</p> <p>The base cases are: 1.  Single-character substrings: \\(\\text{dp}[i][i] = \\text{true}\\). 2.  Two-character substrings: \\(\\text{dp}[i][i+1] = (s[i] == s[i+1])\\).</p> <p>The transition relation is recursive: a substring \\(s[i \\dots j]\\) is a palindrome if and only if two conditions are met: 1. The outer characters match: \\(s[i] == s[j]\\). 2. The inner substring \\(s[i+1 \\dots j-1]\\) is also a palindrome (i.e., \\(\\text{dp}[i+1][j-1]\\) is true). By iterating through substrings of increasing lengths, we can fill the DP table and track the longest palindrome found. [Diagram showing DP transitions for Palindromic Substring] While effective and providing \\(O(N^2)\\) time and \\(O(N^2)\\) space complexity, the approach below is often simpler to implement.</p>"},{"location":"5/#the-expand-around-center-approach-the-practical-on2-solution","title":"The Expand Around Center Approach (The Practical \\(O(N^2)\\) Solution)","text":"<p>A more practical and generally preferred \\(O(N^2)\\) solution is the Expand Around Center technique. This method exploits the symmetry inherent in palindromes: every palindrome is defined by its center. The center can be a single character (for odd-length palindromes like \"racecar\") or the space between two identical characters (for even-length palindromes like \"abba\").</p> <p>This approach avoids the overhead of the DP table by immediately checking for palindromes outward from every potential center. The overall algorithm iterates through every index \\(i\\) in the string \\(s\\), and for each \\(i\\), it performs two independent expansion checks:</p>"},{"location":"5/#center-based-expansion-details","title":"Center-Based Expansion Details","text":"<ol> <li>Odd-Length Palindromes: We treat the single character at index \\(i\\) as the center. We initialize two pointers, \\(L=i\\) and \\(R=i\\). We expand outward, decrementing \\(L\\) and incrementing \\(R\\), as long as \\(L \\ge 0\\), \\(R &lt; N\\), and \\(s[L] == s[R]\\).</li> <li>Even-Length Palindromes: We treat the space between \\(s[i]\\) and \\(s[i+1]\\) as the center (if \\(i+1\\) is a valid index). We initialize \\(L=i\\) and \\(R=i+1\\). We expand outward similarly, decrementing \\(L\\) and incrementing \\(R\\), as long as the boundary and character equality conditions hold. </li> </ol> <p>In both expansion processes, we calculate the length of the current palindrome found \\((R - L - 1)\\) and continuously update a global record tracking the start index and length of the longest palindrome encountered so far. Since we check \\(2N-1\\) possible centers (N single-character centers and N-1 between-character centers), and each expansion takes at most \\(O(N)\\) time, the total time complexity remains \\(O(N^2)\\). However, this method uses only \\(O(1)\\) auxiliary space, making it spatially superior to the standard DP approach.</p>"},{"location":"6/","title":"Problem 6","text":"<pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        if numRows == 1 or len(s) &lt;= numRows:\n            return s\n\n        rows = [''] * numRows\n        current_row = 0\n        going_down = False\n\n        for char in s:\n            rows[current_row] += char\n\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            if going_down:\n                current_row += 1\n            else:\n                current_row -= 1\n\n        return \"\".join(rows)\n</code></pre>"},{"location":"6/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":""},{"location":"6/#problem-statement-and-visualization","title":"Problem Statement and Visualization","text":"<p>LeetCode problem 6, \"Zigzag Conversion,\" requires converting a given string \\(s\\) into a zigzag pattern across a specified number of rows, \\(numRows\\). After the conversion process, the string is read line by line, from left to right, and the resulting concatenated string must be returned. This is essentially a pattern recognition and string reconstruction problem.</p> <p>Imagine writing the string characters down a series of vertical lines, then diagonally up and to the right, forming a distinctive \"Z\" or \"N\" shape, repeated across the width of the input string. For \\(s=\\) \"PAYPALISHIRING\" and \\(numRows=3\\), the visual pattern looks like this:</p> <p>\"P A H N A P L S I I G Y I R\"</p> <p>When read row by row, the converted string is \"PAHNAPLSIIGYIR\". The core challenge is to derive the mathematical relationship between a character's index in the original string and its row in the final pattern, without needing to physically build a 2D matrix.</p>"},{"location":"6/#the-pattern-cycle-length","title":"The Pattern Cycle Length","text":"<p>The key to an efficient solution is recognizing and utilizing the repetitive nature of the zigzag movement. In the pattern, the characters travel down to the bottom row (\\(0\\) to \\(numRows-1\\)) and then diagonally back up to the top row (\\(numRows-1\\) to \\(1\\)). This movement constitutes a full cycle.</p> <p>The length of one complete cycle, which represents the distance between two characters that fall on the same row in adjacent \"V\" shapes, can be calculated. It includes the \\(numRows\\) characters going down and \\(numRows - 2\\) characters going back up (since the top and bottom rows are shared between cycles). Therefore, the cycle length is \\(\\text{CycleLength} = 2 \\times numRows - 2\\). For example, if \\(numRows=4\\), the cycle length is \\(2 \\times 4 - 2 = 6\\). A character at index \\(i\\) and the next character in the same row will be separated by \\(\\text{CycleLength}\\) distance, or \\(i + \\text{CycleLength}\\). </p>"},{"location":"6/#direct-access-and-row-by-row-construction","title":"Direct Access and Row-by-Row Construction","text":"<p>The most optimal solution uses Direct Access combined with the calculated cycle length. Instead of simulating the movement of pointers, we iterate through the rows, from row \\(0\\) to \\(numRows-1\\), and directly calculate which character indices belong to that specific row. This approach ensures \\(O(n)\\) time complexity, where \\(n\\) is the length of the string, as each character is appended to the result exactly once.</p> <p>The algorithm builds the result string row by row:</p> <ol> <li> <p>First and Last Rows (Row 0 and Row \\(numRows-1\\)): For the top (0) and bottom (\\(numRows-1\\)) rows, characters are spaced exactly by the \\(\\text{CycleLength}\\). The indices belonging to these rows are \\(k \\times \\text{CycleLength}\\), where \\(k\\) is \\(0, 1, 2, \\dots\\). We simply start at the row index and repeatedly add the \\(\\text{CycleLength}\\) until we exceed the string bounds.</p> </li> <li> <p>Intermediate Rows (Row \\(r\\), where \\(0 &lt; r &lt; numRows-1\\)): For any intermediate row \\(r\\), a character appears twice within each cycle:</p> <ul> <li>First Occurrence (Vertical): The character is found at the index \\(i_1 = k \\times \\text{CycleLength} + r\\).</li> <li>Second Occurrence (Diagonal): The character is found at a diagonal position, \\(i_2\\). The distance between \\(i_1\\) and \\(i_2\\) within the cycle is the shorter distance required to complete the diagonal move, which is \\(\\text{CycleLength} - 2r\\). Thus, \\(i_2 = i_1 + (\\text{CycleLength} - 2r)\\).</li> </ul> </li> </ol> <p>We iterate through \\(k = 0, 1, 2, \\dots\\) for each row \\(r\\), calculating both \\(i_1\\) and \\(i_2\\). We append the character at \\(i_1\\) if it is within bounds. Then, we calculate \\(i_2\\) and append its character if \\(i_2\\) is valid (within bounds and not the same index as \\(i_1\\), which only occurs if \\(2r\\) is zero or equal to the cycle length, but we filter this by the intermediate row condition). This systematic, row-based traversal correctly reconstructs the final string in \\(O(n)\\) time.</p>"},{"location":"7/","title":"Problem 7","text":"<pre><code>class Solution:\n    def reverse(self, x: int) -&gt; int:\n\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        reversed_x = 0\n\n        while x != 0:\n            digit = x % 10\n            if x &lt; 0 and digit &gt; 0:\n                digit -= 10\n\n            x = (x - digit) // 10\n\n            if reversed_x &gt; INT_MAX // 10 or (reversed_x == INT_MAX // 10 and digit &gt; 7):\n                return 0\n\n            if reversed_x &lt; INT_MIN // 10 or (reversed_x == INT_MIN // 10 and digit &lt; -8):\n                return 0\n\n            reversed_x = reversed_x * 10 + digit\n\n        return reversed_x\n</code></pre>"},{"location":"7/#7-reverse-integer","title":"7. Reverse Integer","text":""},{"location":"7/#problem-statement-and-the-integer-limit-constraint","title":"Problem Statement and The Integer Limit Constraint","text":"<p>LeetCode problem 7, \"Reverse Integer,\" asks us to take a given signed 32-bit integer \\(x\\) and return its digits in reverse order. The primary complication in this problem, beyond the mechanical reversal of digits, is handling the constraints imposed by the 32-bit signed integer range.</p> <p>A signed 32-bit integer can only hold values from a minimum of \\(-2^{31}\\) (\\(-2,147,483,648\\)) to a maximum of \\(2^{31}-1\\) (\\(2,147,483,647\\)). If the act of reversing the digits causes the resulting number to exceed this range (either overflowing the maximum or underflowing the minimum), the function is required to return 0. This necessity of preemptive overflow checking makes the problem non-trivial, as simple data type operations might lead to undefined behavior or incorrect values in many programming environments before the check can even be performed.</p>"},{"location":"7/#iterative-reversal-mechanism","title":"Iterative Reversal Mechanism","text":"<p>The digit reversal is achieved through a standard iterative process using arithmetic operations, avoiding string conversion for efficiency. We maintain a variable, let's call it <code>reversed_result</code>, initialized to 0. We then enter a loop that continues as long as the input \\(x\\) is not zero.</p> <p>In each iteration, we perform two steps: 1.  Extract the Last Digit: The last digit of \\(x\\) is isolated using the modulo operator: \\(\\text{digit} = x \\pmod{10}\\). 2.  Update the Reversed Result: The <code>reversed_result</code> is updated by shifting its current digits one position to the left (multiplying by 10) and then appending the new \\(\\text{digit}\\): \\(\\text{reversed\\_result} = \\text{reversed\\_result} \\times 10 + \\text{digit}\\). 3.  Truncate \\(x\\): The last digit is removed from \\(x\\) using integer division: \\(x = x / 10\\).</p> <p>This process effectively peels off the digits of \\(x\\) from right to left and reconstructs them into <code>reversed_result</code> from left to right.</p>"},{"location":"7/#the-critical-overflow-detection-logic","title":"The Critical Overflow Detection Logic","text":"<p>The most critical part of the solution is detecting potential overflow before it actually occurs in the calculation \\(\\text{reversed\\_result} \\times 10 + \\text{digit}\\). We must check the state of \\(\\text{reversed\\_result}\\) before the multiplication by 10. Let \\(\\text{INT\\_MAX} = 2,147,483,647\\) and \\(\\text{INT\\_MIN} = -2,147,483,648\\).</p> <p>We can categorize the overflow checks into three distinct scenarios for the positive case: 1.  Guaranteed Overflow (Positive): If \\(\\text{reversed\\_result}\\) is already greater than \\(\\text{INT\\_MAX} / 10\\) (which is \\(214,748,364\\)), then multiplying by 10 will definitely exceed \\(\\text{INT\\_MAX}\\). 2.  Edge Case Check (Positive): If \\(\\text{reversed\\_result}\\) is equal to \\(\\text{INT\\_MAX} / 10\\) (\\(214,748,364\\)), the overflow depends entirely on the next digit. Since \\(\\text{INT\\_MAX} \\pmod{10} = 7\\), an overflow occurs if the extracted \\(\\text{digit}\\) is greater than 7.</p>"},{"location":"7/#handling-negative-and-returning-zero","title":"Handling Negative and Returning Zero","text":"<p>A symmetrical set of checks must be performed for the negative integer range, using \\(\\text{INT\\_MIN}\\): 1.  Guaranteed Underflow (Negative): If \\(\\text{reversed\\_result}\\) is already less than \\(\\text{INT\\_MIN} / 10\\) (which is \\(-214,748,364\\)), then multiplying by 10 will definitely be less than \\(\\text{INT\\_MIN}\\). 2.  Edge Case Check (Negative): If \\(\\text{reversed\\_result}\\) is equal to \\(\\text{INT\\_MIN} / 10\\) (\\(-214,748,364\\)), the underflow depends on the next digit. Since \\(\\text{INT\\_MIN} \\pmod{10}\\) is \\(-8\\) (or \\(-7\\) depending on language specific signed division rules, but for \\(-2^{31}\\) it is 8), an underflow occurs if the extracted \\(\\text{digit}\\) is less than \\(-8\\) (or greater than 8 in magnitude). The safe check is simply if \\(\\text{reversed\\_result} &lt; \\text{INT\\_MIN} / 10\\) or \\((\\text{reversed\\_result} == \\text{INT\\_MIN} / 10 \\text{ and } \\text{digit} &lt; -8)\\).</p> <p>If any of these overflow/underflow conditions are met during the loop, the algorithm immediately terminates and returns 0, fulfilling the problem's requirement. If the loop completes without triggering any overflow, the final \\(\\text{reversed\\_result}\\) is returned. This approach maintains an \\(O(\\log_{10}|x|)\\) time complexity, which is proportional to the number of digits in \\(x\\).</p>"},{"location":"8/","title":"Problem 8","text":"<pre><code>class Solution:\n    def myAtoi(self, s: str) -&gt; int:\n\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        i = 0\n\n        if s[0] == '+':\n            i += 1\n        elif s[0] == '-':\n            sign = -1\n            i += 1\n\n        result = 0\n        INT_MAX = 2147483647\n        INT_MIN = -2147483648\n\n        while i &lt; len(s) and s[i].isdigit():\n            digit = int(s[i])\n\n            if sign == 1:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 7):\n                    return INT_MAX\n            else:\n                if result &gt; INT_MAX // 10 or (result == INT_MAX // 10 and digit &gt; 8):\n                    return INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        return result * sign\n</code></pre>"},{"location":"8/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":""},{"location":"8/#problem-statement-and-ambiguity-of-parsing","title":"Problem Statement and Ambiguity of Parsing","text":"<p>LeetCode problem 8, \"String to Integer (atoi),\" asks for the implementation of the \\(myAtoi(string s)\\) function, which converts a string into a 32-bit signed integer, mirroring the behavior of the C/C++ <code>atoi</code> function. This seemingly simple task is complicated by several strict parsing rules and edge cases that must be handled sequentially and correctly. The process is not a single conversion but a series of state transitions.</p> <p>The core difficulty lies in managing the strict sequence of parsing steps: first, ignoring leading whitespace; second, identifying and processing the optional sign; third, accumulating valid digits; and finally, handling potential overflow or underflow against the 32-bit integer limits. Any character encountered that does not fit the current expected state (e.g., a letter after a digit) must immediately terminate the parsing process, regardless of how many digits were successfully processed beforehand.</p>"},{"location":"8/#step-1-discarding-leading-whitespace","title":"Step 1: Discarding Leading Whitespace","text":"<p>The conversion process must begin by reading and discarding any leading whitespace characters (' ') until the first non-whitespace character is found. This stage requires a simple loop that increments an index past all spaces. If the entire string consists only of spaces, the result is 0.</p> <p>Once a non-whitespace character is hit, the algorithm must transition immediately to the next stage. It is crucial to remember that whitespace is only permissible at the very start of the string. Any space encountered after the sign or after the first digit is considered an invalid character and terminates parsing.</p>"},{"location":"8/#step-2-handling-the-optional-sign","title":"Step 2: Handling the Optional Sign","text":"<p>After skipping initial whitespace, the next character must be evaluated to determine the sign of the number. The sign is optional. If the character is a plus sign ('+'), the number is positive. If it is a minus sign ('-'), the number is negative. If the character is neither a '+' nor a '-' (and is a digit), the number is implicitly positive.</p> <p>A sign multiplier variable (e.g., <code>sign</code>, initialized to 1) is set to 1 or -1 accordingly. If a sign character is found, the index is advanced to the next character. A critical rule here is that if any character other than a '+' or '-' appears immediately after the whitespace, the parsing must jump straight to Step 3 (reading digits). If two signs, or a sign followed by a non-digit, or the end of the string is encountered, the conversion stops, and 0 is returned.</p>"},{"location":"8/#step-3-reading-and-accumulating-digits","title":"Step 3: Reading and Accumulating Digits","text":"<p>This is the core numerical processing stage. We iterate through the string starting from the character following the sign (or the first non-whitespace character). The loop continues only as long as the current character is a valid digit ('0' through '9').</p> <p>In each iteration, the character is converted into its numerical value, \\(\\text{digit}\\). The running result, \\(\\text{result}\\), is updated by multiplying the current result by 10 and adding the new digit: \\(\\text{result} = \\text{result} \\times 10 + \\text{digit}\\). [Diagram illustrating State Transitions for atoi] The first non-digit character encountered will immediately stop this accumulation phase.</p>"},{"location":"8/#step-4-overflow-and-underflow-clamping","title":"Step 4: Overflow and Underflow Clamping","text":"<p>The most challenging aspect, similar to the Reverse Integer problem, is the requirement to prevent and handle numerical overflow or underflow. The result must fit within the 32-bit signed integer range, which is \\(\\text{INT\\_MIN} = -2^{31}\\) and \\(\\text{INT\\_MAX} = 2^{31}-1\\).</p> <p>The overflow check must be performed inside the digit accumulation loop, before the multiplication and addition, to ensure that the intermediate calculation does not exceed the limits. If the current positive \\(\\text{result}\\) is already greater than \\(\\text{INT\\_MAX} / 10\\), or if it is equal to \\(\\text{INT\\_MAX} / 10\\) and the new \\(\\text{digit}\\) is greater than 7, then the final result would overflow. Symmetrical checks apply to the negative result against \\(\\text{INT\\_MIN}\\). If an overflow or underflow condition is met at any point, the algorithm must immediately stop and clamp the final value to \\(\\text{INT\\_MAX}\\) or \\(\\text{INT\\_MIN}\\) before returning. This careful sequence of state-dependent parsing and boundary checks ensures compliance with all \\(myAtoi\\) rules.</p>"},{"location":"9/","title":"Problem 9","text":"<pre><code>class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n\n        if x &lt; 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        while x &gt; reverted_number:\n            reverted_number = reverted_number * 10 + x % 10\n            x //= 10\n\n        return x == reverted_number or x == reverted_number // 10\n</code></pre>"},{"location":"9/#9-palindrome-number","title":"9. Palindrome Number","text":""},{"location":"9/#problem-statement-and-constraints","title":"Problem Statement and Constraints","text":"<p>LeetCode problem 9, \"Palindrome Number,\" asks for a determination of whether a given integer \\(x\\) is a palindrome. An integer is defined as a palindrome if it reads the same forwards and backwards. For instance, 121 is a palindrome, but 123 is not. The primary constraint on the solution is the requirement to solve the problem without converting the integer to a string. This mandates an approach using only mathematical operations, such as modulo and division.</p> <p>Initial checks reveal immediate non-palindromes: all negative numbers are non-palindromes because the minus sign only appears at the beginning (e.g., \\(-121\\) reads \\(121-\\) backward). Additionally, any positive number that ends in 0 (other than 0 itself, which is a palindrome) cannot be a palindrome, as the leading digit of the reversed number would be 0, which is invalid for an integer representation (e.g., \\(120\\) reverses to \\(021\\)). If \\(x\\) is negative or ends in 0 (and is not 0), we can immediately return <code>false</code>.</p>"},{"location":"9/#the-brute-force-reversal-pitfall","title":"The Brute Force Reversal Pitfall","text":"<p>A straightforward approach would be to fully reverse the entire integer \\(x\\) and then compare the reversed value with the original \\(x\\). While this method works for most integers, it suffers from the same vulnerability as the \"Reverse Integer\" problem (LeetCode 7): integer overflow. If the original number \\(x\\) is large, reversing it could cause the resulting number to exceed the maximum value allowed by the integer data type (\\(\\text{INT\\_MAX}\\)).</p> <p>Since the problem requires a robust solution, we must devise a method that avoids the potential for overflow entirely. Reversing the number and then performing the comparison, while simple to code, is mathematically risky without dedicated overflow handling, which complicates the logic unnecessarily when a safer method exists.</p>"},{"location":"9/#the-optimized-half-reversal-approach","title":"The Optimized Half-Reversal Approach","text":"<p>The most elegant and efficient solution involves reversing only the second half of the number. If a number is a palindrome, its second half, when reversed, must be identical to its first half. This technique avoids the risk of overflow because we are only building a reversed number that is at most half the length of the original.</p> <p>We use a loop to iteratively build a <code>reversed_half</code> variable. The loop continues as long as the original number \\(x\\) is greater than <code>reversed_half</code>. In each iteration: 1.  We extract the last digit of \\(x\\) using \\(\\text{digit} = x \\pmod{10}\\). 2.  We append this digit to <code>reversed_half</code>: \\(\\text{reversed\\_half} = \\text{reversed\\_half} \\times 10 + \\text{digit}\\). 3.  We remove the last digit from \\(x\\): \\(x = x / 10\\).</p> <p>This process effectively transfers the digits from the tail of \\(x\\) to the head of <code>reversed\\_half</code> until \\(x\\) is no longer greater than <code>reversed\\_half</code>, signifying that we have processed at least half the digits.</p>"},{"location":"9/#final-comparison-and-edge-case-handling","title":"Final Comparison and Edge Case Handling","text":"<p>When the loop terminates, we compare the remaining portion of \\(x\\) with the constructed <code>reversed_half</code>. Two distinct scenarios are possible, depending on the length of the original number:</p> <ol> <li>Even Number of Digits: If the original number had an even number of digits (e.g., 1221), the loop stops when \\(x\\) and <code>reversed_half</code> have the same value (i.e., \\(x = 12\\) and \\(\\text{reversed\\_half} = 12\\)). The palindrome check is simply \\(x == \\text{reversed\\_half}\\).</li> <li>Odd Number of Digits: If the original number had an odd number of digits (e.g., 121), the loop stops when the middle digit has been transferred to \\(\\text{reversed\\_half}\\) (i.e., \\(x = 1\\) and \\(\\text{reversed\\_half} = 12\\)). The middle digit of an odd-length palindrome is irrelevant to the comparison. To align the values, we remove the middle digit from <code>reversed_half</code> via integer division: \\(\\text{reversed\\_half} / 10\\). The palindrome check is \\(x == \\text{reversed\\_half} / 10\\).</li> </ol> <p>By combining these two checks with a logical OR operation, we can cover all valid cases: \\(x == \\text{reversed\\_half}\\) OR \\(x == \\text{reversed\\_half} / 10\\). This half-reversal strategy ensures an optimal \\(O(\\log_{10} x)\\) time complexity, which is proportional to the number of digits, and maintains \\(O(1)\\) space complexity without risking integer overflow.</p>"}]}